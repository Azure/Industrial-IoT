// ------------------------------------------------------------
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//  Licensed under the MIT License (MIT). See License.txt in the repo root for license information.
// ------------------------------------------------------------

namespace Azure.IIoT.OpcUa.Publisher.Services
{
    using Azure.IIoT.OpcUa.Publisher.Stack.Extensions;
    using Azure.IIoT.OpcUa.Publisher.Stack.Models;
    using Azure.IIoT.OpcUa.Publisher.Stack;
    using Azure.IIoT.OpcUa.Publisher.Models;
    using Furly.Extensions.Serializers;
    using Furly.Extensions.Messaging;
    using Microsoft.Extensions.Logging;
    using Opc.Ua.Client.ComplexTypes;
    using Opc.Ua;
    using Opc.Ua.Extensions;
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using Nito.AsyncEx;

    /// <summary>
    /// Data set writer sources wrap the source of a data set writer
    /// and handles the updates to the writer configuration.
    /// </summary>
    internal class DataSetWriter
    {
        /// <summary>
        /// State of the source
        /// </summary>
        [Flags]
        public enum State
        {
            /// <summary>
            /// Ready
            /// </summary>
            Ready,

            /// <summary>
            /// Preparing
            /// </summary>
            NeedsUpdate = 1,

            /// <summary>
            /// Error state
            /// </summary>
            Error = 2,
        }

        /// <summary>
        /// Current state
        /// </summary>
        public State CurrentState { get; private set; }

        /// <summary>
        /// Current metadata
        /// </summary>
        public DataSetMetaDataType? CurrentMetaData =>
            _metaDataLoader.IsValueCreated ? _metaDataLoader.Value.MetaData : null;

        /// <summary>
        /// Number of items the writer is managing
        /// </summary>
        public abstract int Count { get; }
        public string Id { get; }

        /// <summary>
        /// Data set
        /// </summary>
        /// <param name="id"></param>
        /// <param name="logger"></param>
        public DataSetWriter(string id, ILoggerFactory logger)
        {
            Id = id;
            _logger = logger;
            _metaDataLoader = new Lazy<DataSetMetaDataLoader>(() =>
                new DataSetMetaDataLoader(this), true);
        }

        /// <summary>
        /// Update data set with new dataset configuration
        /// </summary>
        /// <returns></returns>
        public virtual void ProcessChange(DataSetWriterModel dataSetWriter)
        {
            var newItems = dataSetWriter?.DataSet?.ExtensionFields?
                .Select(e => (e.Key, new ExtensionField(Guid.NewGuid(), e.Value)))
                .ToList();
            if (!(newItems?.Count > 0))
            {
                _extensionFields.Clear();
                return;
            }
            _extensionFields = Merge(_extensionFields, newItems, out var updated);
            if (updated)
            {
                CurrentState |= State.NeedsUpdate;
            }
        }

        /// <summary>
        /// Update the configuration using the session
        /// </summary>
        /// <param name="session"></param>
        /// <param name="ct"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public async ValueTask UpdateAsync(IOpcUaSession session, CancellationToken ct)
        {
            // 1. Resolve node
            await ResolveBrowsePath(session, ct).ConfigureAwait(false);

            // 2. Resolve display names
            await ResolveFieldNamesAsync(session, ct).ConfigureAwait(false);

            // 3. Resolve queue names
            await ResolveQueueNamesAsync(session, ct).ConfigureAwait(false);

            // 4. Resolve Metadata
            if (_metadataChanged)
            {
                var threshold =
                    _dataSetWriter.Configuration.DataSet?.DataSetMetaData?.AsyncMetaDataLoadThreshold
                        ?? 30; // Synchronous loading for 30 or less items
                var tcs = (Count <= threshold) ? new TaskCompletionSource() : null;
                var args = new DataSetMetaDataLoader.MetaDataLoaderArguments(tcs, session,
                    session.MessageContext.NamespaceUris);
                _metaDataLoader.Value.Reload(args);
                if (tcs != null)
                {
                    await tcs.Task.ConfigureAwait(false);
                }
                _metadataChanged = false;
            }

            CurrentState = State.Ready;
        }

        /// <summary>
        /// Resolve browse names
        /// </summary>
        /// <param name="session"></param>
        /// <param name="ct"></param>
        /// <returns></returns>
        protected abstract ValueTask ResolveBrowsePath(IOpcUaSession session,
            CancellationToken ct);

        /// <summary>
        /// Resolve field names
        /// </summary>
        /// <param name="session"></param>
        /// <param name="ct"></param>
        /// <returns></returns>
        protected abstract ValueTask ResolveFieldNamesAsync(IOpcUaSession session,
            CancellationToken ct);

        /// <summary>
        /// Resolve queue names
        /// </summary>
        /// <param name="session"></param>
        /// <param name="ct"></param>
        /// <returns></returns>
        protected abstract ValueTask ResolveQueueNamesAsync(IOpcUaSession session,
            CancellationToken ct);

        /// <summary>
        /// Get meta data
        /// </summary>
        /// <param name="session"></param>
        /// <param name="typeSystem"></param>
        /// <param name="fields"></param>
        /// <param name="dataTypes"></param>
        /// <param name="ct"></param>
        /// <returns></returns>
        public virtual ValueTask GetMetaDataAsync(IOpcUaSession session,
            ComplexTypeSystem? typeSystem, Opc.Ua.FieldMetaDataCollection fields,
            Opc.Ua.NodeIdDictionary<DataTypeDescription> dataTypes,
            CancellationToken ct)
        {
            foreach (var (Name, Field) in _extensionFields)
            {
                return AddVariableFieldAsync(fields, dataTypes, session, typeSystem,
                    new VariableNode
                    {
                        DataType = (int)BuiltInType.Variant
                    }, Name, (Uuid)Field.DataSetFieldGuid, ct);
            }
            return ValueTask.CompletedTask;
        }

        /// <summary>
        /// Add veriable field metadata
        /// </summary>
        /// <param name="fields"></param>
        /// <param name="dataTypes"></param>
        /// <param name="session"></param>
        /// <param name="typeSystem"></param>
        /// <param name="variable"></param>
        /// <param name="fieldName"></param>
        /// <param name="dataSetClassFieldId"></param>
        /// <param name="ct"></param>
        protected async ValueTask AddVariableFieldAsync(FieldMetaDataCollection fields,
            NodeIdDictionary<DataTypeDescription> dataTypes, IOpcUaSession session,
            ComplexTypeSystem? typeSystem, VariableNode variable,
            string fieldName, Uuid dataSetClassFieldId, CancellationToken ct)
        {
            byte builtInType = 0;
            try
            {
                builtInType = (byte)await TypeInfo.GetBuiltInTypeAsync(variable.DataType,
                    session.TypeTree, ct).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogInformation("{Item}: Failed to get built in type for type {DataType}" +
                    " with message: {Message}", this, variable.DataType, ex.Message);
            }
            fields.Add(new FieldMetaData
            {
                Name = fieldName,
                DataSetFieldId = dataSetClassFieldId,
                FieldFlags = 0, // Set to 1 << 1 for PromotedField fields.
                DataType = variable.DataType,
                ArrayDimensions = variable.ArrayDimensions?.Count > 0
                    ? variable.ArrayDimensions : null,
                Description = variable.Description,
                ValueRank = variable.ValueRank,
                MaxStringLength = 0,
                // If the Property is EngineeringUnits, the unit of the Field Value
                // shall match the unit of the FieldMetaData.
                Properties = null, // TODO: Add engineering units etc. to properties
                BuiltInType = builtInType
            });
            await AddDataTypesAsync(dataTypes, variable.DataType, session, typeSystem,
                ct).ConfigureAwait(false);
        }

        /// <summary>
        /// Add data types to the metadata
        /// </summary>
        /// <param name="dataTypes"></param>
        /// <param name="dataTypeId"></param>
        /// <param name="session"></param>
        /// <param name="typeSystem"></param>
        /// <param name="ct"></param>
        protected async ValueTask AddDataTypesAsync(NodeIdDictionary<DataTypeDescription> dataTypes,
            NodeId dataTypeId, IOpcUaSession session, ComplexTypeSystem? typeSystem,
            CancellationToken ct)
        {
            if (IsBuiltInType(dataTypeId))
            {
                return;
            }

            var baseType = dataTypeId;
            while (!NodeId.IsNull(baseType))
            {
                try
                {
                    var dataType = await session.NodeCache.FetchNodeAsync(baseType,
                        ct).ConfigureAwait(false);
                    if (dataType == null)
                    {
                        _logger.LogWarning(
                            "{Item}: Failed to find node for data type {BaseType}!",
                            this, baseType);
                        break;
                    }

                    dataTypeId = dataType.NodeId;
                    Debug.Assert(!NodeId.IsNull(dataTypeId));
                    if (IsBuiltInType(dataTypeId))
                    {
                        // Do not add builtin types
                        break;
                    }

                    var builtInType = await TypeInfo.GetBuiltInTypeAsync(dataTypeId,
                        session.TypeTree, ct).ConfigureAwait(false);
                    baseType = await session.TypeTree.FindSuperTypeAsync(dataTypeId,
                        ct).ConfigureAwait(false);

                    switch (builtInType)
                    {
                        case BuiltInType.Enumeration:
                        case BuiltInType.ExtensionObject:
                            var types = typeSystem?.GetDataTypeDefinitionsForDataType(
                                dataType.NodeId);
                            if (types == null || types.Count == 0)
                            {
                                dataTypes.AddOrUpdate(dataType.NodeId,
                                    GetDefault(dataType, builtInType));
                                break;
                            }
                            foreach (var type in types)
                            {
                                if (!dataTypes.ContainsKey(type.Key))
                                {
                                    var description = type.Value switch
                                    {
                                        StructureDefinition s =>
                                            new StructureDescription
                                            {
                                                DataTypeId = type.Key,
                                                Name = dataType.BrowseName,
                                                StructureDefinition = s
                                            },
                                        EnumDefinition e =>
                                            new EnumDescription
                                            {
                                                DataTypeId = type.Key,
                                                Name = dataType.BrowseName,
                                                EnumDefinition = e
                                            },
                                        _ => GetDefault(dataType, builtInType),
                                    };
                                    dataTypes.AddOrUpdate(type.Key, description);
                                }
                            }
                            break;
                        default:
                            dataTypes.AddOrUpdate(dataTypeId, new SimpleTypeDescription
                            {
                                DataTypeId = dataTypeId,
                                Name = dataType.BrowseName,
                                BaseDataType = baseType,
                                BuiltInType = (byte)builtInType
                            });
                            break;
                    }
                }
                catch (Exception ex) when (ex is not OperationCanceledException)
                {
                    _logger.LogInformation("{Item}: Failed to get meta data for type " +
                        "{DataType} (base: {BaseType}) with message: {Message}", this,
                        dataTypeId, baseType, ex.Message);
                    break;
                }
            }

            static bool IsBuiltInType(NodeId dataTypeId)
            {
                if (dataTypeId.NamespaceIndex == 0 && dataTypeId.IdType == IdType.Numeric)
                {
                    var id = (BuiltInType)(int)(uint)dataTypeId.Identifier;
                    if (id >= BuiltInType.Null && id <= BuiltInType.Enumeration)
                    {
                        return true;
                    }
                }
                return false;
            }
            static DataTypeDescription GetDefault(Node dataType, BuiltInType builtInType)
            {
                return builtInType == BuiltInType.Enumeration
                    ? new EnumDescription
                    {
                        DataTypeId = dataType.NodeId,
                        Name = dataType.BrowseName
                    } : new StructureDescription
                    {
                        DataTypeId = dataType.NodeId,
                        Name = dataType.BrowseName
                    };
            }
        }

        /// <summary>
        /// Create queue name
        /// </summary>
        /// <param name="dataSetWriter"></param>
        /// <param name="subPath"></param>
        /// <param name="includeNamespaceIndex"></param>
        /// <returns></returns>
        protected static string ToQueueName(DataSetWriterModel dataSetWriter,
            RelativePath subPath, bool includeNamespaceIndex)
        {
            Debug.Assert(dataSetWriter.Publishing != null);
            var sb = new StringBuilder().Append(dataSetWriter.Publishing.QueueName);
            foreach (var path in subPath.Elements)
            {
                sb.Append('/');
                if (path.TargetName.NamespaceIndex != 0 && includeNamespaceIndex)
                {
                    sb.Append(path.TargetName.NamespaceIndex).Append(':');
                }
                sb.Append(TopicFilter.Escape(path.TargetName.Name));
            }
            return sb.ToString();
        }

        /// <summary>
        /// Merge items
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="oldItems"></param>
        /// <param name="newItems"></param>
        /// <param name="updated"></param>
        /// <returns></returns>
        protected static List<(string Key, T)> Merge<T>(List<(string Key, T)> oldItems,
            IEnumerable<(string Key, T)> newItems, out bool updated)
        {
            var newList = new List<(string, T)>();
            updated = false;
            foreach (var item in newItems)
            {
                if (oldItems.Count > 0)
                {
                    var i = oldItems.FindIndex(i => i.Key == item.Key);
                    if (i != -1)
                    {
                        newList.Add(oldItems[i]);
                        oldItems.RemoveRange(0, i + 1);
                        continue;
                    }
                }
                newList.Add(item);
                updated = true;
            }
            return newList;
        }

        /// <summary>
        /// Loader abstraction
        /// </summary>
        private sealed class DataSetMetaDataLoader : IAsyncDisposable
        {
            /// <summary>
            /// Current meta data
            /// </summary>
            public DataSetMetaDataType? MetaData { get; private set; }

            /// <summary>
            /// The target data set to load metadata for
            /// </summary>
            public PublishedDataSetModel? DataSet => _dataSet._dataSetWriter.Configuration.DataSet;

            /// <summary>
            /// Create loader
            /// </summary>
            /// <param name="dataSet"></param>
            public DataSetMetaDataLoader(DataSetWriter dataSet)
            {
                _dataSet = dataSet;
                _loader = StartAsync(_cts.Token);
            }

            /// <inheritdoc/>
            public async ValueTask DisposeAsync()
            {
                try
                {
                    await _cts.CancelAsync().ConfigureAwait(false);
                    await _loader.ConfigureAwait(false);
                }
                catch (OperationCanceledException) { }
                finally
                {
                    _cts.Dispose();
                }
            }

            /// <summary>
            /// Load meta data
            /// </summary>
            /// <param name="arguments"></param>
            public void Reload(MetaDataLoaderArguments arguments)
            {
                Interlocked.Exchange(ref _arguments, arguments)?.tcs?.TrySetCanceled();
                _trigger.Set();
            }

            /// <summary>
            /// Meta data loader task
            /// </summary>
            /// <param name="ct"></param>
            /// <returns></returns>
            private async Task StartAsync(CancellationToken ct)
            {
                while (!ct.IsCancellationRequested)
                {
                    await _trigger.WaitAsync(ct).ConfigureAwait(false);

                    var args = Interlocked.Exchange(ref _arguments, null);
                    if (args == null)
                    {
                        continue;
                    }
                    try
                    {
                        await UpdateMetaDataAsync(args, ct).ConfigureAwait(false);
                        args.tcs?.TrySetResult();
                    }
                    catch (OperationCanceledException)
                    {
                        args.tcs?.TrySetCanceled(ct);
                    }
                    catch (Exception ex)
                    {
                        _dataSet._logger.LogError(
                            "Failed to get metadata for {Subscription} with error {Error}",
                            this, ex.Message);

                        args.tcs?.TrySetException(ex);
                    }
                }
            }

            /// <summary>
            /// Update metadata
            /// </summary>
            /// <param name="args"></param>
            /// <param name="ct"></param>
            /// <returns></returns>
            internal async Task UpdateMetaDataAsync(MetaDataLoaderArguments args,
                CancellationToken ct = default)
            {
                var metadata = DataSet?.DataSetMetaData;
                if (metadata == null)
                {
                    // Metadata disabled
                    MetaData = null;
                    return;
                }

                //
                // Use the date time to version across reboots. This could be done
                // more elegantly by saving the last version to persistent storage
                // such as twin, but this is ok for the sake of being able to have
                // an incremental version number defining metadata changes.
                //
                var metaDataVersion = DateTime.UtcNow.ToBinary();
                var major = (uint)(metaDataVersion >> 32);
                var minor = (uint)metaDataVersion;

                _dataSet._logger.LogDebug(
                    "Loading Metadata {Major}.{Minor} for {Subscription}...",
                    major, minor, this);

                var sw = Stopwatch.StartNew();
                var typeSystem = await args.sessionHandle.GetComplexTypeSystemAsync(
                    ct).ConfigureAwait(false);
                var dataTypes = new NodeIdDictionary<DataTypeDescription>();
                var fields = new FieldMetaDataCollection();

                await _dataSet.GetMetaDataAsync(args.sessionHandle, typeSystem, fields,
                    dataTypes, ct).ConfigureAwait(false);

                _dataSet._logger.LogInformation(
                    "Loading Metadata {Major}.{Minor} for {Subscription} took {Duration}.",
                    major, minor, this, sw.Elapsed);

                MetaData = new DataSetMetaDataType
                {
                    Name = metadata.Name,
                    DataSetClassId = (Uuid)metadata.DataSetClassId,
                    Namespaces = args.namespaces.ToArray(),
                    EnumDataTypes = dataTypes.Values.OfType<EnumDescription>().ToArray(),
                    StructureDataTypes = dataTypes.Values.OfType<StructureDescription>().ToArray(),
                    SimpleDataTypes = dataTypes.Values.OfType<SimpleTypeDescription>().ToArray(),
                    Fields = fields,
                    Description = metadata.Description,
                    ConfigurationVersion = new ConfigurationVersionDataType
                    {
                        MajorVersion = major,
                        MinorVersion = minor
                    }
                };
            }

            internal record MetaDataLoaderArguments(TaskCompletionSource? tcs,
                IOpcUaSession sessionHandle, NamespaceTable namespaces);

            private MetaDataLoaderArguments? _arguments;
            private readonly Task _loader;
            private readonly CancellationTokenSource _cts = new();
            private readonly AsyncAutoResetEvent _trigger = new();
            private readonly DataSetWriter _dataSet;
        }

        /// <summary>
        /// UA-Data data set items
        /// </summary>
        private sealed class PublishedDataItems : DataSetWriter
        {
            /// <inheritdoc/>
            public override int Count => _items.Count;

            /// <summary>
            /// Create event item
            /// </summary>
            /// <param name="loggerFactory"></param>
            public PublishedDataItems(ILoggerFactory loggerFactory) :
                base(loggerFactory.CreateLogger<PublishedDataItems>())
            {
            }

            /// <inheritdoc/>
            public override void ProcessChange(DataSetWriterModel dataSetWriter)
            {
                var newItems =
                    dataSetWriter.DataSet?.DataSetSource?.PublishedVariables?.PublishedData?
                    .Select((item, index) => (item.GetUniqueId(index), item.Clone()))
                    .ToList();
                if (newItems == null)
                {
                    CurrentState = State.Ready;
                    _items.Clear();
                }
                else
                {
                    _items = Merge(_items, newItems, out var updated);
                    if (updated)
                    {
                        CurrentState |= State.NeedsUpdate;
                    }
                }
                base.ProcessChange(dataSetWriter);
            }

            /// <inheritdoc/>
            public override async ValueTask GetMetaDataAsync(IOpcUaSession session,
                ComplexTypeSystem? typeSystem, FieldMetaDataCollection fields,
                NodeIdDictionary<DataTypeDescription> dataTypes, CancellationToken ct)
            {
                foreach (var item in _items.Select(i => i.Value))
                {
                    Debug.Assert(item.DataSetFieldName != null);
                    var nodeId = item.PublishedVariableNodeId.ToNodeId(session.MessageContext);
                    if (NodeId.IsNull(nodeId))
                    {
                        // Failed.
                        return;
                    }
                    try
                    {
                        var node = await session.NodeCache.FetchNodeAsync(nodeId,
                            ct).ConfigureAwait(false);
                        if (node is VariableNode variable)
                        {
                            await AddVariableFieldAsync(fields, dataTypes, session,
                                typeSystem, variable, item.DataSetFieldName,
                                (Uuid)item.DataSetClassFieldId, ct).ConfigureAwait(false);
                        }
                    }
                    catch (Exception ex) when (ex is not OperationCanceledException)
                    {
                        _logger.LogDebug("{Item}: Failed to get meta data for field {Field} " +
                            "with node {NodeId} with message {Message}.", this, item.DataSetFieldName,
                            nodeId, ex.Message);
                    }
                }
                await base.GetMetaDataAsync(session, typeSystem, fields, dataTypes,
                    ct).ConfigureAwait(false);
            }

            /// <inheritdoc/>
            protected override async ValueTask ResolveBrowsePath(IOpcUaSession session,
                CancellationToken ct)
            {
                var limits = await session.GetOperationLimitsAsync(ct).ConfigureAwait(false);
                foreach (var resolvers in _items
                    .Select(i => i.Value)
                    .Where(v => v.BrowsePath?.Count > 0)
                    .Batch(limits.GetMaxNodesPerTranslatePathsToNodeIds()))
                {
                    var response = await session.Services.TranslateBrowsePathsToNodeIdsAsync(
                        new RequestHeader(), new BrowsePathCollection(resolvers
                            .Select(a => new BrowsePath
                            {
                                StartingNode = a!.PublishedVariableNodeId.ToNodeId(
                                    session.MessageContext),
                                RelativePath = a.BrowsePath.ToRelativePath(
                                    session.MessageContext)
                            })), ct).ConfigureAwait(false);

                    var results = response.Validate(response.Results, s => s.StatusCode,
                        response.DiagnosticInfos, resolvers);
                    if (results.ErrorInfo != null)
                    {
                        // Could not do anything...
                        _logger.LogWarning(
                            "Failed to resolve browse path in {Subscription} due to {ErrorInfo}...",
                            this, results.ErrorInfo);
                        // return false;
                        // Error handling
                        CurrentState |= State.Error;
                        continue;
                    }
                    foreach (var result in results)
                    {
                        if (result.ErrorInfo == null && result.Result.Targets.Count > 0)
                        {
                            if (result.Result.Targets.Count > 1)
                            {
                                _logger.LogInformation(
                                    "Ambiguous browse path for {NodeId} - using first.",
                                    result.Request!.PublishedVariableNodeId);
                            }
                            result.Request!.PublishedVariableNodeId =
                                result.Result.Targets[0].TargetId.AsString(session.MessageContext,
                                    NamespaceFormat.Expanded);
                            result.Request.BrowsePath = null;
                        }
                        else
                        {
                            _logger.LogWarning(
                                "Failed resolve browse path of {NodeId} due to '{ServiceResult}'",
                                result.Request!.PublishedVariableNodeId, result.ErrorInfo);
                        }
                    }
                }
            }

            /// <inheritdoc/>
            protected override async ValueTask ResolveFieldNamesAsync(IOpcUaSession session,
                CancellationToken ct)
            {
                // Get limits to batch requests during resolve
                var limits = await session.GetOperationLimitsAsync(ct).ConfigureAwait(false);
                foreach (var item in _items.Select(i => i.Value))
                {
                    item.DataSetFieldName ??= item.DataSetFieldName;
                }
                foreach (var displayNameUpdates in _items
                    .Select(i => i.Value)
                    .Where(p => p.DataSetFieldName == null)
                    .Batch(limits.GetMaxNodesPerRead()))
                {
                    var response = await session.Services.ReadAsync(new RequestHeader(),
                        0, Opc.Ua.TimestampsToReturn.Neither, new ReadValueIdCollection(
                        displayNameUpdates.Select(a => new ReadValueId
                        {
                            NodeId = a!.PublishedVariableNodeId.ToNodeId(session.MessageContext),
                            AttributeId = (uint)NodeAttribute.DisplayName
                        })), ct).ConfigureAwait(false);
                    var results = response.Validate(response.Results,
                        s => s.StatusCode, response.DiagnosticInfos, displayNameUpdates);

                    if (results.ErrorInfo == null)
                    {
                        foreach (var result in results)
                        {
                            if (result.Result.Value is not null)
                            {
                                result.Request!.DataSetFieldName =
                                    (result.Result.Value as LocalizedText)?.ToString();
                                // metadataChanged = true;
                            }
                            else
                            {
                                _logger.LogWarning("Failed to read display name for {NodeId} " +
                                    "due to '{ServiceResult}'",
                                    result.Request!.PublishedVariableNodeId, result.ErrorInfo);
                            }
                        }
                    }
                    else
                    {
                        _logger.LogWarning(
                            "Failed to resolve display name in {Subscription} due to {ErrorInfo}...",
                            this, results.ErrorInfo);

                        // We will retry later.
                        // noErrorFound = false;
                    }
                }
            }

            /// <inheritdoc/>
            protected override async ValueTask ResolveQueueNamesAsync(IOpcUaSession session,
                CancellationToken ct)
            {
                var limits = await session.GetOperationLimitsAsync(ct).ConfigureAwait(false);
                foreach (var getPathsBatch in _items
                    .Select(i => i.Value)
                    .Where(i => i.Publishing?.QueueName == null)
                    .Batch(100))
                {
                    var getPath = getPathsBatch.ToList();
                    var paths = await session.GetBrowsePathsFromRootAsync(new RequestHeader(),
                        getPath.Select(n => n.PublishedVariableNodeId
                            .ToNodeId(session.MessageContext)),
                        ct).ConfigureAwait(false);
                    for (var index = 0; index < paths.Count; index++)
                    {
                        var item = getPath[index].Publishing
                            ??= new PublishingQueueSettingsModel();
                        item.QueueName = ToQueueName(paths[index].Path, true); // TODO
                        if (paths[index].ErrorInfo != null)
                        {
                            _logger.LogWarning(
                                "Failed to get root path for {NodeId} due to '{ServiceResult}'",
                                getPath[index]!.PublishedVariableNodeId, paths[index].ErrorInfo);
                        }
                    }
                }
            }

            private List<(string Id, PublishedDataSetVariableModel Value)> _items = new();
        }

        /// <summary>
        /// UA-Event items
        /// </summary>
        private sealed class PublishedEventItems : DataSetWriter
        {
            /// <inheritdoc/>
            public override int Count => _items.Count;

            /// <summary>
            /// Create event item
            /// </summary>
            /// <param name="loggerFactory"></param>
            public PublishedEventItems(ILoggerFactory loggerFactory) :
                base(loggerFactory.CreateLogger<PublishedEventItems>())
            {
            }

            /// <inheritdoc/>
            public override void ProcessChange(DataSetWriterModel dataSetWriter)
            {
                var newItems =
                    dataSetWriter.DataSet?.DataSetSource?.PublishedEvents?.PublishedData?
                    .Select((item, index) => (item.GetUniqueId(index), item.Clone()))
                    .ToList();
                if (newItems != null)
                {
                    _items = Merge(_items, newItems, out var updated);
                    if (updated)
                    {
                        CurrentState |= State.NeedsUpdate;
                    }
                }
                else
                {
                    CurrentState = State.Ready;
                    _items.Clear();
                }
                base.ProcessChange(dataSetWriter);
            }

            /// <inheritdoc/>
            public override async ValueTask GetMetaDataAsync(IOpcUaSession session,
                ComplexTypeSystem? typeSystem, FieldMetaDataCollection fields,
                NodeIdDictionary<DataTypeDescription> dataTypes, CancellationToken ct)
            {
                foreach (var (_, eventFilter) in _items)
                {
                    try
                    {
                        Debug.Assert(eventFilter.SelectedFields != null);
                        for (var i = 0; i < eventFilter.SelectedFields.Count; i++)
                        {
                            var selectClause = eventFilter.SelectedFields[i];
                            var fieldName = selectClause.DisplayName;
                            if (fieldName == null)
                            {
                                continue;
                            }
                            var dataSetClassFieldId = (Uuid)selectClause.DataSetClassFieldId;
                            var targetNode = await FindNodeWithBrowsePathAsync(session,
                                selectClause.BrowsePath, selectClause.TypeDefinitionId,
                                ct).ConfigureAwait(false);
                            if (targetNode is VariableNode variable)
                            {
                                await AddVariableFieldAsync(fields, dataTypes, session,
                                    typeSystem, variable, fieldName, dataSetClassFieldId,
                                    ct).ConfigureAwait(false);
                            }
                            else
                            {
                                fields.Add(new FieldMetaData
                                {
                                    Name = fieldName,
                                    DataSetFieldId = dataSetClassFieldId
                                });
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        _logger.LogDebug(e, "{Item}: Failed to get metadata for event.", this);
                        throw;
                    }
                }
            }

            /// <inheritdoc/>
            protected override async ValueTask ResolveQueueNamesAsync(IOpcUaSession session,
                CancellationToken ct)
            {
                var limits = await session.GetOperationLimitsAsync(ct).ConfigureAwait(false);
                foreach (var getPathsBatch in _items
                    .Select(i => i.Value)
                    .Where(i => i.Publishing?.QueueName == null)
                    .Batch(100))
                {
                    var getPath = getPathsBatch.ToList();
                    var paths = await session.GetBrowsePathsFromRootAsync(new RequestHeader(),
                        getPath.Select(n => n!.EventNotifier.ToNodeId(session.MessageContext)),
                        ct).ConfigureAwait(false);
                    for (var index = 0; index < paths.Count; index++)
                    {
                        var item = getPath[index].Publishing ??= new PublishingQueueSettingsModel();
                        item.QueueName = ToQueueName(paths[index].Path, true); // TODO
                        if (paths[index].ErrorInfo != null)
                        {
                            _logger.LogWarning(
                                "Failed to get root path for {NodeId} due to '{ServiceResult}'",
                                getPath[index]!.EventNotifier, paths[index].ErrorInfo);
                        }
                    }
                }
            }

            /// <inheritdoc/>
            protected override async ValueTask ResolveBrowsePath(IOpcUaSession session,
                CancellationToken ct)
            {
                var limits = await session.GetOperationLimitsAsync(ct).ConfigureAwait(false);
                foreach (var resolvers in _items
                    .Select(i => i.Value)
                    .Where(v => v.BrowsePath?.Count > 0)
                    .Batch(limits.GetMaxNodesPerTranslatePathsToNodeIds()))
                {
                    var response = await session.Services.TranslateBrowsePathsToNodeIdsAsync(
                        new RequestHeader(), new BrowsePathCollection(resolvers
                            .Select(a => new BrowsePath
                            {
                                StartingNode = a!.EventNotifier.ToNodeId(
                                    session.MessageContext),
                                RelativePath = a.BrowsePath.ToRelativePath(
                                    session.MessageContext)
                            })), ct).ConfigureAwait(false);

                    var results = response.Validate(response.Results, s => s.StatusCode,
                        response.DiagnosticInfos, resolvers);
                    if (results.ErrorInfo != null)
                    {
                        // Could not do anything...
                        _logger.LogWarning(
                            "Failed to resolve browse path in {Subscription} due to {ErrorInfo}...",
                            this, results.ErrorInfo);
                        // return false;
                        // Error handling
                        continue;
                    }
                    foreach (var result in results)
                    {
                        if (result.ErrorInfo == null && result.Result.Targets.Count > 0)
                        {
                            if (result.Result.Targets.Count > 1)
                            {
                                _logger.LogInformation(
                                    "Ambiguous browse path for {NodeId} - using first.",
                                    result.Request!.EventNotifier);
                            }
                            result.Request!.EventNotifier =
                                result.Result.Targets[0].TargetId.AsString(session.MessageContext,
                                    NamespaceFormat.Expanded);
                            result.Request.BrowsePath = null;
                        }
                        else
                        {
                            _logger.LogWarning(
                                "Failed resolve browse path of {NodeId} due to '{ServiceResult}'",
                                result.Request!.EventNotifier, result.ErrorInfo);
                        }
                    }
                }
            }

            /// <inheritdoc/>
            protected override async ValueTask ResolveFieldNamesAsync(IOpcUaSession session,
                CancellationToken ct)
            {
                foreach (var dataSetEvent in _items.Select(e => e.Value))
                {
                    if (dataSetEvent.SelectedFields == null && dataSetEvent.Filter == null)
                    {
                        if (string.IsNullOrEmpty(dataSetEvent.TypeDefinitionId))
                        {
                            dataSetEvent.TypeDefinitionId = ObjectTypeIds.BaseEventType
                                .AsString(session.MessageContext, NamespaceFormat.Expanded);
                        }

                        // Resolve the simple event
                        await ResolveFilterForEventTypeDefinitionId(session,
                            dataSetEvent, ct).ConfigureAwait(false);
                    }

                    Debug.Assert(dataSetEvent.SelectedFields != null);
                    Debug.Assert(dataSetEvent.Filter != null);

                    dataSetEvent.TypeDefinitionId = null;
                    foreach (var field in dataSetEvent.SelectedFields)
                    {
                        if (field.DataSetClassFieldId == Guid.Empty)
                        {
                            field.DataSetClassFieldId = Guid.NewGuid();
                        }
                    }
                }

                // Get limits to batch requests during resolve
                var limits = await session.GetOperationLimitsAsync(ct).ConfigureAwait(false);
                foreach (var item in _items.Select(i => i.Value))
                {
                    item.Id ??= item.PublishedEventName;
                }
                foreach (var displayNameUpdates in _items
                    .Select(i => i.Value)
                    .Where(p => p.Id == null)
                    .Batch(limits.GetMaxNodesPerRead()))
                {
                    var response = await session.Services.ReadAsync(new RequestHeader(),
                        0, Opc.Ua.TimestampsToReturn.Neither, new ReadValueIdCollection(
                        displayNameUpdates.Select(a => new ReadValueId
                        {
                            NodeId = (a.TypeDefinitionId ?? a.EventNotifier)
                                .ToNodeId(session.MessageContext),
                            AttributeId = (uint)NodeAttribute.DisplayName
                        })), ct).ConfigureAwait(false);

                    var results = response.Validate(response.Results,
                        s => s.StatusCode, response.DiagnosticInfos, displayNameUpdates);
                    if (results.ErrorInfo != null)
                    {
                        _logger.LogWarning("Failed to resolve display name due to {ErrorInfo}...",
                            results.ErrorInfo);

                        // We will retry later.
                        // noErrorFound = false;
                        continue;
                    }
                    foreach (var result in results)
                    {
                        if (result.Result.Value is not null)
                        {
                            var name = (result.Result.Value as LocalizedText)?.ToString();
                            result.Request!.Id = name;
                            if (result.Request.TypeDefinitionId != null)
                            {
                                result.Request.PublishedEventName ??= name;
                            }
                            // metadataChanged = true;
                        }
                        else
                        {
                            _logger.LogWarning("Failed to read display name for {NodeId} " +
                                "due to '{ServiceResult}'", result.Request.TypeDefinitionId
                                    ?? result.Request.EventNotifier, result.ErrorInfo);
                        }
                    }
                }
            }

            /// <summary>
            /// Builds select clause and where clause by using OPC UA reflection
            /// </summary>
            /// <param name="session"></param>
            /// <param name="dataSetEvent"></param>
            /// <param name="ct"></param>
            /// <returns></returns>
            private static async ValueTask ResolveFilterForEventTypeDefinitionId(
                IOpcUaSession session, PublishedDataSetEventModel dataSetEvent,
                CancellationToken ct)
            {
                Debug.Assert(dataSetEvent.TypeDefinitionId != null);
                var selectedFields = new List<SimpleAttributeOperandModel>();

                // Resolve select clauses
                var typeDefinitionId = dataSetEvent.TypeDefinitionId.ToNodeId(
                    session.MessageContext);
                var nodes = new List<Node>();
                ExpandedNodeId? superType = null;
                var typeDefinitionNode = await session.NodeCache.FetchNodeAsync(
                    typeDefinitionId, ct).ConfigureAwait(false);
                nodes.Insert(0, typeDefinitionNode);
                do
                {
                    superType = nodes[0].GetSuperType(session.TypeTree);
                    if (superType != null)
                    {
                        typeDefinitionNode = await session.NodeCache.FetchNodeAsync(
                            superType, ct).ConfigureAwait(false);
                        nodes.Insert(0, typeDefinitionNode);
                    }
                }
                while (superType != null);

                var fieldNames = new List<QualifiedName>();
                foreach (var node in nodes)
                {
                    await ParseFieldsAsync(session, fieldNames, node, string.Empty,
                        ct).ConfigureAwait(false);
                }

                fieldNames = fieldNames
                    .Distinct()
                    .OrderBy(x => x.Name).ToList();

                // We add ConditionId first if event is derived from ConditionType
                if (nodes.Any(x => x.NodeId == ObjectTypeIds.ConditionType))
                {
                    selectedFields.Add(new SimpleAttributeOperandModel()
                    {
                        BrowsePath = Array.Empty<string>(),
                        TypeDefinitionId = ObjectTypeIds.ConditionType.AsString(
                            session.MessageContext, NamespaceFormat.Expanded),
                        DataSetClassFieldId = Guid.NewGuid(), // Todo: Use constant here
                        IndexRange = null,
                        DisplayName = "ConditionId",
                        AttributeId = NodeAttribute.NodeId
                    });
                }

                foreach (var fieldName in fieldNames)
                {
                    var selectClause = new SimpleAttributeOperandModel()
                    {
                        TypeDefinitionId = ObjectTypeIds.BaseEventType.AsString( // IS this correct?
                            session.MessageContext, NamespaceFormat.Expanded),
                        DataSetClassFieldId = Guid.NewGuid(),
                        DisplayName = fieldName.Name,
                        IndexRange = null,
                        AttributeId = NodeAttribute.Value,
                        BrowsePath = fieldName.Name
                            .Split('|')
                            .Select(x => new QualifiedName(x, fieldName.NamespaceIndex)
                                .AsString(session.MessageContext, NamespaceFormat.Expanded))
                            .ToArray()
                    };
                    selectedFields.Add(selectClause);
                }

                // Simple filter of type type definition
                dataSetEvent.Filter = new ContentFilterModel
                {
                    Elements = new[]
                    {
                    new ContentFilterElementModel
                    {
                        FilterOperator = FilterOperatorType.OfType,
                        FilterOperands = new []
                        {
                            new FilterOperandModel
                            {
                                NodeId = dataSetEvent.TypeDefinitionId
                            }
                        }
                    }
                }
                };
                dataSetEvent.SelectedFields = selectedFields;
                dataSetEvent.TypeDefinitionId = null;
            }

            /// <summary>
            /// Get all the fields of a type definition node to build the
            /// select clause.
            /// </summary>
            /// <param name="session"></param>
            /// <param name="fieldNames"></param>
            /// <param name="node"></param>
            /// <param name="browsePathPrefix"></param>
            /// <param name="ct"></param>
            private static async ValueTask ParseFieldsAsync(IOpcUaSession session,
                List<QualifiedName> fieldNames, Node node, string browsePathPrefix,
                CancellationToken ct)
            {
                foreach (var reference in node.ReferenceTable)
                {
                    if (reference.ReferenceTypeId == ReferenceTypeIds.HasComponent &&
                        !reference.IsInverse)
                    {
                        var componentNode = await session.NodeCache.FetchNodeAsync(reference.TargetId,
                            ct).ConfigureAwait(false);
                        if (componentNode.NodeClass == Opc.Ua.NodeClass.Variable)
                        {
                            var fieldName = browsePathPrefix + componentNode.BrowseName.Name;
                            fieldNames.Add(new QualifiedName(
                                fieldName, componentNode.BrowseName.NamespaceIndex));
                            await ParseFieldsAsync(session, fieldNames, componentNode,
                                $"{fieldName}|", ct).ConfigureAwait(false);
                        }
                    }
                    else if (reference.ReferenceTypeId == ReferenceTypeIds.HasProperty)
                    {
                        var propertyNode = await session.NodeCache.FetchNodeAsync(reference.TargetId,
                            ct).ConfigureAwait(false);
                        var fieldName = browsePathPrefix + propertyNode.BrowseName.Name;
                        fieldNames.Add(new QualifiedName(
                            fieldName, propertyNode.BrowseName.NamespaceIndex));
                    }
                }
            }

            /// <summary>
            /// Find node by browse path
            /// </summary>
            /// <param name="session"></param>
            /// <param name="browsePath"></param>
            /// <param name="nodeId"></param>
            /// <param name="ct"></param>
            /// <returns></returns>
            private static async ValueTask<INode?> FindNodeWithBrowsePathAsync(IOpcUaSession session,
                IReadOnlyList<string>? browsePath, ExpandedNodeId nodeId, CancellationToken ct)
            {
                INode? found = null;
                browsePath ??= Array.Empty<string>();
                foreach (var browseName in browsePath.Select(b => b.ToQualifiedName(session.MessageContext)))
                {
                    found = null;
                    while (found == null)
                    {
                        found = await session.NodeCache.FindAsync(nodeId, ct).ConfigureAwait(false);
                        if (found is not Node node)
                        {
                            return null;
                        }

                        //
                        // Get all hierarchical references of the node and
                        // match browse name
                        //
                        foreach (var reference in node.ReferenceTable.Find(
                            ReferenceTypeIds.HierarchicalReferences, false,
                                true, session.TypeTree))
                        {
                            var target = await session.NodeCache.FindAsync(reference.TargetId,
                                ct).ConfigureAwait(false);
                            if (target?.BrowseName == browseName)
                            {
                                nodeId = target.NodeId;
                                found = target;
                                break;
                            }
                        }

                        if (found == null)
                        {
                            // Try super type
                            nodeId = await session.TypeTree.FindSuperTypeAsync(nodeId,
                                ct).ConfigureAwait(false);
                            if (Opc.Ua.NodeId.IsNull(nodeId))
                            {
                                // Nothing can be found since there is no more super type
                                return null;
                            }
                        }
                    }
                    nodeId = found.NodeId;
                }
                return found;
            }

            private List<(string Id, PublishedDataSetEventModel Value)> _items = new();
        }

        private record struct ExtensionField(Guid DataSetFieldGuid, VariantValue Value);
        private List<(string Key, ExtensionField Field)> _extensionFields = new();
        private bool _metadataChanged;
        protected readonly ILogger _logger;
        protected readonly DataSetWriter _dataSetWriter;
        private readonly Lazy<DataSetMetaDataLoader> _metaDataLoader;
    }
}
