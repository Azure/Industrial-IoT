// Package azureiiotopcvault implements the Azure ARM Azureiiotopcvault service
// API version v2.
//
// Azure Industrial IoT OPC UA Vault Service
package azureiiotopcvault

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Azureiiotopcvault
DefaultBaseURI = "/vault")

// BaseClient is the base client for Azureiiotopcvault.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // AcceptRequest the request is in the 'Accepted' state after this call.
    // Requires Writer role.
        // Parameters:
            // requestID - the certificate request id
    func (client BaseClient) AcceptRequest(ctx context.Context, requestID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.AcceptRequest")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.AcceptRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "AcceptRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.AcceptRequestSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "AcceptRequest", resp, "Failure sending request")
                return
                }

                result, err = client.AcceptRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "AcceptRequest", resp, "Failure responding to request")
                }

        return
        }

        // AcceptRequestPreparer prepares the AcceptRequest request.
        func (client BaseClient) AcceptRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/{requestId}/accept",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // AcceptRequestSender sends the AcceptRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) AcceptRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // AcceptRequestResponder handles the response to the AcceptRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) AcceptRequestResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // AddTrustRelationship define trust between two entities.  The entities are
    // identifiers
    // of application, groups, or endpoints.
        // Parameters:
            // entityID - the entity identifier, e.g. group, etc.
            // trustedEntityID - the trusted entity identifier
    func (client BaseClient) AddTrustRelationship(ctx context.Context, entityID string, trustedEntityID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.AddTrustRelationship")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.AddTrustRelationshipPreparer(ctx, entityID, trustedEntityID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "AddTrustRelationship", nil , "Failure preparing request")
        return
        }

                resp, err := client.AddTrustRelationshipSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "AddTrustRelationship", resp, "Failure sending request")
                return
                }

                result, err = client.AddTrustRelationshipResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "AddTrustRelationship", resp, "Failure responding to request")
                }

        return
        }

        // AddTrustRelationshipPreparer prepares the AddTrustRelationship request.
        func (client BaseClient) AddTrustRelationshipPreparer(ctx context.Context, entityID string, trustedEntityID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "entityId": autorest.Encode("path",entityID),
                "trustedEntityId": autorest.Encode("path",trustedEntityID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/trustlists/{entityId}/{trustedEntityId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // AddTrustRelationshipSender sends the AddTrustRelationship request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) AddTrustRelationshipSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // AddTrustRelationshipResponder handles the response to the AddTrustRelationship request. The method always
    // closes the http.Response Body.
    func (client BaseClient) AddTrustRelationshipResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ApproveRequest validates the request with the application database.
    // - If Approved:
    // - New Key Pair request: Creates the new key pair
    // in the requested format, signs the certificate and stores the
    // private key for later securely in KeyVault.
    // - Cert Signing Request: Creates and signs the certificate.
    // Deletes the CSR from the database.
    // Stores the signed certificate for later use in the Database.
    // The request is in the 'Approved' or 'Rejected' state after this call.
    // Requires Approver role.
    // Approver needs signing rights in KeyVault.
        // Parameters:
            // requestID - the certificate request id
    func (client BaseClient) ApproveRequest(ctx context.Context, requestID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ApproveRequest")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ApproveRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ApproveRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.ApproveRequestSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ApproveRequest", resp, "Failure sending request")
                return
                }

                result, err = client.ApproveRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ApproveRequest", resp, "Failure responding to request")
                }

        return
        }

        // ApproveRequestPreparer prepares the ApproveRequest request.
        func (client BaseClient) ApproveRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/{requestId}/approve",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ApproveRequestSender sends the ApproveRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ApproveRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ApproveRequestResponder handles the response to the ApproveRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ApproveRequestResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // CreateGroup requires manager role.
        // Parameters:
            // request - the create request
    func (client BaseClient) CreateGroup(ctx context.Context, request TrustGroupRegistrationRequestAPIModel) (result TrustGroupRegistrationResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "request.ParentID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "request.SubjectName", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcvault.BaseClient", "CreateGroup", err.Error())
                }

                    req, err := client.CreateGroupPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "CreateGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "CreateGroup", resp, "Failure sending request")
                return
                }

                result, err = client.CreateGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "CreateGroup", resp, "Failure responding to request")
                }

        return
        }

        // CreateGroupPreparer prepares the CreateGroup request.
        func (client BaseClient) CreateGroupPreparer(ctx context.Context, request TrustGroupRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/groups"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateGroupSender sends the CreateGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateGroupSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CreateGroupResponder handles the response to the CreateGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateGroupResponder(resp *http.Response) (result TrustGroupRegistrationResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateRoot requires manager role.
        // Parameters:
            // request - the create request
    func (client BaseClient) CreateRoot(ctx context.Context, request TrustGroupRootCreateRequestAPIModel) (result TrustGroupRegistrationResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateRoot")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.Name", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "request.SubjectName", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "request.Lifetime", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcvault.BaseClient", "CreateRoot", err.Error())
                }

                    req, err := client.CreateRootPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "CreateRoot", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateRootSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "CreateRoot", resp, "Failure sending request")
                return
                }

                result, err = client.CreateRootResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "CreateRoot", resp, "Failure responding to request")
                }

        return
        }

        // CreateRootPreparer prepares the CreateRoot request.
        func (client BaseClient) CreateRootPreparer(ctx context.Context, request TrustGroupRootCreateRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/groups/root"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateRootSender sends the CreateRoot request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateRootSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CreateRootResponder handles the response to the CreateRoot request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateRootResponder(resp *http.Response) (result TrustGroupRegistrationResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteGroup after this operation the Issuer CA, CRLs and keys become
    // inaccessible.
    // Use this function with extreme caution.
    // Requires manager role.
        // Parameters:
            // groupID - the group id
    func (client BaseClient) DeleteGroup(ctx context.Context, groupID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteGroup")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteGroupPreparer(ctx, groupID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "DeleteGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteGroupSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "DeleteGroup", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "DeleteGroup", resp, "Failure responding to request")
                }

        return
        }

        // DeleteGroupPreparer prepares the DeleteGroup request.
        func (client BaseClient) DeleteGroupPreparer(ctx context.Context, groupID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "groupId": autorest.Encode("path",groupID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/groups/{groupId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteGroupSender sends the DeleteGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteGroupSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteGroupResponder handles the response to the DeleteGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteGroupResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteRequest by purging the request it is actually physically deleted from
    // the
    // database, including the public key and other information.
    // Requires Manager role.
        // Parameters:
            // requestID - the certificate request id
    func (client BaseClient) DeleteRequest(ctx context.Context, requestID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteRequest")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "DeleteRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteRequestSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "DeleteRequest", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "DeleteRequest", resp, "Failure responding to request")
                }

        return
        }

        // DeleteRequestPreparer prepares the DeleteRequest request.
        func (client BaseClient) DeleteRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/{requestId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteRequestSender sends the DeleteRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteRequestResponder handles the response to the DeleteRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteRequestResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // FinishNewKeyPairRequest can be called in any state.
    // Fetches private key in 'Completed' state.
    // After a successful fetch in 'Completed' state, the request is
    // moved into 'Accepted' state.
    // Requires Writer role.
    func (client BaseClient) FinishNewKeyPairRequest(ctx context.Context, requestID string) (result FinishNewKeyPairRequestResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.FinishNewKeyPairRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.FinishNewKeyPairRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "FinishNewKeyPairRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.FinishNewKeyPairRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "FinishNewKeyPairRequest", resp, "Failure sending request")
                return
                }

                result, err = client.FinishNewKeyPairRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "FinishNewKeyPairRequest", resp, "Failure responding to request")
                }

        return
        }

        // FinishNewKeyPairRequestPreparer prepares the FinishNewKeyPairRequest request.
        func (client BaseClient) FinishNewKeyPairRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/keypair/{requestId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // FinishNewKeyPairRequestSender sends the FinishNewKeyPairRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) FinishNewKeyPairRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // FinishNewKeyPairRequestResponder handles the response to the FinishNewKeyPairRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) FinishNewKeyPairRequestResponder(resp *http.Response) (result FinishNewKeyPairRequestResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // FinishSigningRequest can be called in any state.
    // After a successful fetch in 'Completed' state, the request is
    // moved into 'Accepted' state.
    // Requires Writer role.
    func (client BaseClient) FinishSigningRequest(ctx context.Context, requestID string) (result FinishSigningRequestResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.FinishSigningRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.FinishSigningRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "FinishSigningRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.FinishSigningRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "FinishSigningRequest", resp, "Failure sending request")
                return
                }

                result, err = client.FinishSigningRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "FinishSigningRequest", resp, "Failure responding to request")
                }

        return
        }

        // FinishSigningRequestPreparer prepares the FinishSigningRequest request.
        func (client BaseClient) FinishSigningRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/sign/{requestId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // FinishSigningRequestSender sends the FinishSigningRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) FinishSigningRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // FinishSigningRequestResponder handles the response to the FinishSigningRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) FinishSigningRequestResponder(resp *http.Response) (result FinishSigningRequestResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetGroup a trust group has a root certificate which issues certificates
    // to entities.  Entities can be part of a trust group and thus
    // trust the root certificate and all entities that the root has
    // issued certificates for.
        // Parameters:
            // groupID - the group id
    func (client BaseClient) GetGroup(ctx context.Context, groupID string) (result TrustGroupRegistrationAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetGroupPreparer(ctx, groupID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetGroup", resp, "Failure sending request")
                return
                }

                result, err = client.GetGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetGroup", resp, "Failure responding to request")
                }

        return
        }

        // GetGroupPreparer prepares the GetGroup request.
        func (client BaseClient) GetGroupPreparer(ctx context.Context, groupID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "groupId": autorest.Encode("path",groupID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/groups/{groupId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetGroupSender sends the GetGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetGroupSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetGroupResponder handles the response to the GetGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGroupResponder(resp *http.Response) (result TrustGroupRegistrationAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetIssuerCertificateChain sends the get issuer certificate chain request.
        // Parameters:
            // serialNumber - the serial number of the
            // Issuer CA Certificate
    func (client BaseClient) GetIssuerCertificateChain(ctx context.Context, serialNumber string) (result X509CertificateChainAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetIssuerCertificateChain")
            defer func() {
                sc := -1
                if result.xccam.Response.Response != nil {
                    sc = result.xccam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getIssuerCertificateChainNextResults
        req, err := client.GetIssuerCertificateChainPreparer(ctx, serialNumber)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCertificateChain", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetIssuerCertificateChainSender(req)
                if err != nil {
                result.xccam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCertificateChain", resp, "Failure sending request")
                return
                }

                result.xccam, err = client.GetIssuerCertificateChainResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCertificateChain", resp, "Failure responding to request")
                }

        return
        }

        // GetIssuerCertificateChainPreparer prepares the GetIssuerCertificateChain request.
        func (client BaseClient) GetIssuerCertificateChainPreparer(ctx context.Context, serialNumber string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "serialNumber": autorest.Encode("path",serialNumber),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/certificates/{serialNumber}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetIssuerCertificateChainSender sends the GetIssuerCertificateChain request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetIssuerCertificateChainSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetIssuerCertificateChainResponder handles the response to the GetIssuerCertificateChain request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetIssuerCertificateChainResponder(resp *http.Response) (result X509CertificateChainAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getIssuerCertificateChainNextResults retrieves the next set of results, if any.
                func (client BaseClient) getIssuerCertificateChainNextResults(ctx context.Context, lastResults X509CertificateChainAPIModel) (result X509CertificateChainAPIModel, err error) {
                req, err := lastResults.x509CertificateChainAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "getIssuerCertificateChainNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetIssuerCertificateChainSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "getIssuerCertificateChainNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetIssuerCertificateChainResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "getIssuerCertificateChainNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetIssuerCertificateChainComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetIssuerCertificateChainComplete(ctx context.Context, serialNumber string) (result X509CertificateChainAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetIssuerCertificateChain")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetIssuerCertificateChain(ctx, serialNumber)
                    return
            }

    // GetIssuerCertificateChain1 sends the get issuer certificate chain 1 request.
    func (client BaseClient) GetIssuerCertificateChain1(ctx context.Context, serialNumber string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetIssuerCertificateChain1")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetIssuerCertificateChain1Preparer(ctx, serialNumber)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCertificateChain1", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetIssuerCertificateChain1Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCertificateChain1", resp, "Failure sending request")
                return
                }

                result, err = client.GetIssuerCertificateChain1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCertificateChain1", resp, "Failure responding to request")
                }

        return
        }

        // GetIssuerCertificateChain1Preparer prepares the GetIssuerCertificateChain1 request.
        func (client BaseClient) GetIssuerCertificateChain1Preparer(ctx context.Context, serialNumber string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "serialNumber": autorest.Encode("path",serialNumber),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/issuer/{serialNumber}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetIssuerCertificateChain1Sender sends the GetIssuerCertificateChain1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetIssuerCertificateChain1Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetIssuerCertificateChain1Responder handles the response to the GetIssuerCertificateChain1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetIssuerCertificateChain1Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetIssuerCrlChain sends the get issuer crl chain request.
        // Parameters:
            // serialNumber - the serial number of the Issuer
            // CA Certificate
    func (client BaseClient) GetIssuerCrlChain(ctx context.Context, serialNumber string) (result X509CrlChainAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetIssuerCrlChain")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetIssuerCrlChainPreparer(ctx, serialNumber)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCrlChain", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetIssuerCrlChainSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCrlChain", resp, "Failure sending request")
                return
                }

                result, err = client.GetIssuerCrlChainResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCrlChain", resp, "Failure responding to request")
                }

        return
        }

        // GetIssuerCrlChainPreparer prepares the GetIssuerCrlChain request.
        func (client BaseClient) GetIssuerCrlChainPreparer(ctx context.Context, serialNumber string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "serialNumber": autorest.Encode("path",serialNumber),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/certificates/{serialNumber}/crl",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetIssuerCrlChainSender sends the GetIssuerCrlChain request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetIssuerCrlChainSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetIssuerCrlChainResponder handles the response to the GetIssuerCrlChain request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetIssuerCrlChainResponder(resp *http.Response) (result X509CrlChainAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetIssuerCrlChain1 sends the get issuer crl chain 1 request.
    func (client BaseClient) GetIssuerCrlChain1(ctx context.Context, serialNumber string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetIssuerCrlChain1")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetIssuerCrlChain1Preparer(ctx, serialNumber)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCrlChain1", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetIssuerCrlChain1Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCrlChain1", resp, "Failure sending request")
                return
                }

                result, err = client.GetIssuerCrlChain1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetIssuerCrlChain1", resp, "Failure responding to request")
                }

        return
        }

        // GetIssuerCrlChain1Preparer prepares the GetIssuerCrlChain1 request.
        func (client BaseClient) GetIssuerCrlChain1Preparer(ctx context.Context, serialNumber string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "serialNumber": autorest.Encode("path",serialNumber),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/crl/{serialNumber}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetIssuerCrlChain1Sender sends the GetIssuerCrlChain1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetIssuerCrlChain1Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetIssuerCrlChain1Responder handles the response to the GetIssuerCrlChain1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetIssuerCrlChain1Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetRequest sends the get request request.
        // Parameters:
            // requestID - the certificate request id
    func (client BaseClient) GetRequest(ctx context.Context, requestID string) (result CertificateRequestRecordAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetRequest", resp, "Failure sending request")
                return
                }

                result, err = client.GetRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetRequest", resp, "Failure responding to request")
                }

        return
        }

        // GetRequestPreparer prepares the GetRequest request.
        func (client BaseClient) GetRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/{requestId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetRequestSender sends the GetRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetRequestResponder handles the response to the GetRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetRequestResponder(resp *http.Response) (result CertificateRequestRecordAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetStatus sends the get status request.
    func (client BaseClient) GetStatus(ctx context.Context) (result StatusResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetStatusPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "GetStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetStatusPreparer prepares the GetStatus request.
        func (client BaseClient) GetStatusPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/status"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetStatusSender sends the GetStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetStatusResponder handles the response to the GetStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetStatusResponder(resp *http.Response) (result StatusResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ListGroups a trust group has a root certificate which issues certificates
    // to entities.  Entities can be part of a trust group and thus
    // trust the root certificate and all entities that the root has
    // issued certificates for.
        // Parameters:
            // nextPageLink - optional, link to next page
            // pageSize - optional, the maximum number of result per page
    func (client BaseClient) ListGroups(ctx context.Context, nextPageLink string, pageSize *int32) (result TrustGroupRegistrationListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ListGroups")
            defer func() {
                sc := -1
                if result.tgrlam.Response.Response != nil {
                    sc = result.tgrlam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.listGroupsNextResults
        req, err := client.ListGroupsPreparer(ctx, nextPageLink, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListGroups", nil , "Failure preparing request")
        return
        }

                resp, err := client.ListGroupsSender(req)
                if err != nil {
                result.tgrlam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListGroups", resp, "Failure sending request")
                return
                }

                result.tgrlam, err = client.ListGroupsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListGroups", resp, "Failure responding to request")
                }

        return
        }

        // ListGroupsPreparer prepares the ListGroups request.
        func (client BaseClient) ListGroupsPreparer(ctx context.Context, nextPageLink string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(nextPageLink) > 0 {
                queryParameters["nextPageLink"] = autorest.Encode("query",nextPageLink)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/groups"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ListGroupsSender sends the ListGroups request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ListGroupsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ListGroupsResponder handles the response to the ListGroups request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ListGroupsResponder(resp *http.Response) (result TrustGroupRegistrationListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // listGroupsNextResults retrieves the next set of results, if any.
                func (client BaseClient) listGroupsNextResults(ctx context.Context, lastResults TrustGroupRegistrationListAPIModel) (result TrustGroupRegistrationListAPIModel, err error) {
                req, err := lastResults.trustGroupRegistrationListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listGroupsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.ListGroupsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listGroupsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.ListGroupsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listGroupsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // ListGroupsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) ListGroupsComplete(ctx context.Context, nextPageLink string, pageSize *int32) (result TrustGroupRegistrationListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ListGroups")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.ListGroups(ctx, nextPageLink, pageSize)
                    return
            }

    // ListRequests get all certificate requests in paged form or continue a
    // current listing or
    // query.
    // The returned model can contain a link to the next page if more results are
    // available.
        // Parameters:
            // nextPageLink - optional, link to next page
            // pageSize - optional, the maximum number of result per page
    func (client BaseClient) ListRequests(ctx context.Context, nextPageLink string, pageSize *int32) (result CertificateRequestQueryResponseAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ListRequests")
            defer func() {
                sc := -1
                if result.crqram.Response.Response != nil {
                    sc = result.crqram.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.listRequestsNextResults
        req, err := client.ListRequestsPreparer(ctx, nextPageLink, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListRequests", nil , "Failure preparing request")
        return
        }

                resp, err := client.ListRequestsSender(req)
                if err != nil {
                result.crqram.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListRequests", resp, "Failure sending request")
                return
                }

                result.crqram, err = client.ListRequestsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListRequests", resp, "Failure responding to request")
                }

        return
        }

        // ListRequestsPreparer prepares the ListRequests request.
        func (client BaseClient) ListRequestsPreparer(ctx context.Context, nextPageLink string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(nextPageLink) > 0 {
                queryParameters["nextPageLink"] = autorest.Encode("query",nextPageLink)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/requests"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ListRequestsSender sends the ListRequests request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ListRequestsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ListRequestsResponder handles the response to the ListRequests request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ListRequestsResponder(resp *http.Response) (result CertificateRequestQueryResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // listRequestsNextResults retrieves the next set of results, if any.
                func (client BaseClient) listRequestsNextResults(ctx context.Context, lastResults CertificateRequestQueryResponseAPIModel) (result CertificateRequestQueryResponseAPIModel, err error) {
                req, err := lastResults.certificateRequestQueryResponseAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listRequestsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.ListRequestsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listRequestsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.ListRequestsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listRequestsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // ListRequestsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) ListRequestsComplete(ctx context.Context, nextPageLink string, pageSize *int32) (result CertificateRequestQueryResponseAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ListRequests")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.ListRequests(ctx, nextPageLink, pageSize)
                    return
            }

    // ListTrustedCertificates returns all certificates the entity should trust
    // based on the
    // applied trust configuration.
        // Parameters:
            // nextPageLink - optional, link to next page
            // pageSize - optional, the maximum number of result per page
    func (client BaseClient) ListTrustedCertificates(ctx context.Context, entityID string, nextPageLink string, pageSize *int32) (result X509CertificateListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ListTrustedCertificates")
            defer func() {
                sc := -1
                if result.xclam.Response.Response != nil {
                    sc = result.xclam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.listTrustedCertificatesNextResults
        req, err := client.ListTrustedCertificatesPreparer(ctx, entityID, nextPageLink, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListTrustedCertificates", nil , "Failure preparing request")
        return
        }

                resp, err := client.ListTrustedCertificatesSender(req)
                if err != nil {
                result.xclam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListTrustedCertificates", resp, "Failure sending request")
                return
                }

                result.xclam, err = client.ListTrustedCertificatesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "ListTrustedCertificates", resp, "Failure responding to request")
                }

        return
        }

        // ListTrustedCertificatesPreparer prepares the ListTrustedCertificates request.
        func (client BaseClient) ListTrustedCertificatesPreparer(ctx context.Context, entityID string, nextPageLink string, pageSize *int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "entityId": autorest.Encode("path",entityID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(nextPageLink) > 0 {
                queryParameters["nextPageLink"] = autorest.Encode("query",nextPageLink)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/trustlists/{entityId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ListTrustedCertificatesSender sends the ListTrustedCertificates request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ListTrustedCertificatesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ListTrustedCertificatesResponder handles the response to the ListTrustedCertificates request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ListTrustedCertificatesResponder(resp *http.Response) (result X509CertificateListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // listTrustedCertificatesNextResults retrieves the next set of results, if any.
                func (client BaseClient) listTrustedCertificatesNextResults(ctx context.Context, lastResults X509CertificateListAPIModel) (result X509CertificateListAPIModel, err error) {
                req, err := lastResults.x509CertificateListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listTrustedCertificatesNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.ListTrustedCertificatesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listTrustedCertificatesNextResults", resp, "Failure sending next results request")
                }
                result, err = client.ListTrustedCertificatesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "listTrustedCertificatesNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // ListTrustedCertificatesComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) ListTrustedCertificatesComplete(ctx context.Context, entityID string, nextPageLink string, pageSize *int32) (result X509CertificateListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ListTrustedCertificates")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.ListTrustedCertificates(ctx, entityID, nextPageLink, pageSize)
                    return
            }

    // QueryRequests get all certificate requests in paged form.
    // The returned model can contain a link to the next page if more results are
    // available.  Use ListRequests to continue.
        // Parameters:
            // query - optional, query filter
            // pageSize - optional, the maximum number of result per page
    func (client BaseClient) QueryRequests(ctx context.Context, query *CertificateRequestQueryRequestAPIModel, pageSize *int32) (result CertificateRequestQueryResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryRequests")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryRequestsPreparer(ctx, query, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "QueryRequests", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryRequestsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "QueryRequests", resp, "Failure sending request")
                return
                }

                result, err = client.QueryRequestsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "QueryRequests", resp, "Failure responding to request")
                }

        return
        }

        // QueryRequestsPreparer prepares the QueryRequests request.
        func (client BaseClient) QueryRequestsPreparer(ctx context.Context, query *CertificateRequestQueryRequestAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/requests/query"),
        autorest.WithQueryParameters(queryParameters))
                if query != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(query))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryRequestsSender sends the QueryRequests request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryRequestsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryRequestsResponder handles the response to the QueryRequests request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryRequestsResponder(resp *http.Response) (result CertificateRequestQueryResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RejectRequest the request is in the 'Rejected' state after this call.
    // Requires Approver role.
    // Approver needs signing rights in KeyVault.
        // Parameters:
            // requestID - the certificate request id
    func (client BaseClient) RejectRequest(ctx context.Context, requestID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RejectRequest")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RejectRequestPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RejectRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.RejectRequestSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RejectRequest", resp, "Failure sending request")
                return
                }

                result, err = client.RejectRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RejectRequest", resp, "Failure responding to request")
                }

        return
        }

        // RejectRequestPreparer prepares the RejectRequest request.
        func (client BaseClient) RejectRequestPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/requests/{requestId}/reject",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RejectRequestSender sends the RejectRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RejectRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // RejectRequestResponder handles the response to the RejectRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RejectRequestResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // RemoveTrustRelationship removes trust between two entities.  The entities
    // are identifiers
    // of application, groups, or endpoints.
        // Parameters:
            // entityID - the entity identifier, e.g. group, etc.
            // untrustedEntityID - the trusted entity identifier
    func (client BaseClient) RemoveTrustRelationship(ctx context.Context, entityID string, untrustedEntityID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveTrustRelationship")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveTrustRelationshipPreparer(ctx, entityID, untrustedEntityID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RemoveTrustRelationship", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveTrustRelationshipSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RemoveTrustRelationship", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveTrustRelationshipResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RemoveTrustRelationship", resp, "Failure responding to request")
                }

        return
        }

        // RemoveTrustRelationshipPreparer prepares the RemoveTrustRelationship request.
        func (client BaseClient) RemoveTrustRelationshipPreparer(ctx context.Context, entityID string, untrustedEntityID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "entityId": autorest.Encode("path",entityID),
                "untrustedEntityId": autorest.Encode("path",untrustedEntityID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/trustlists/{entityId}/{untrustedEntityId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveTrustRelationshipSender sends the RemoveTrustRelationship request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveTrustRelationshipSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // RemoveTrustRelationshipResponder handles the response to the RemoveTrustRelationship request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveTrustRelationshipResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // RenewIssuerCertificate sends the renew issuer certificate request.
    func (client BaseClient) RenewIssuerCertificate(ctx context.Context, groupID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RenewIssuerCertificate")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RenewIssuerCertificatePreparer(ctx, groupID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RenewIssuerCertificate", nil , "Failure preparing request")
        return
        }

                resp, err := client.RenewIssuerCertificateSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RenewIssuerCertificate", resp, "Failure sending request")
                return
                }

                result, err = client.RenewIssuerCertificateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "RenewIssuerCertificate", resp, "Failure responding to request")
                }

        return
        }

        // RenewIssuerCertificatePreparer prepares the RenewIssuerCertificate request.
        func (client BaseClient) RenewIssuerCertificatePreparer(ctx context.Context, groupID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "groupId": autorest.Encode("path",groupID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/groups/{groupId}/renew",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RenewIssuerCertificateSender sends the RenewIssuerCertificate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RenewIssuerCertificateSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // RenewIssuerCertificateResponder handles the response to the RenewIssuerCertificate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RenewIssuerCertificateResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // StartNewKeyPairRequest the request is in the 'New' state after this call.
    // Requires Writer or Manager role.
        // Parameters:
            // newKeyPairRequest - the new key pair request parameters
    func (client BaseClient) StartNewKeyPairRequest(ctx context.Context, newKeyPairRequest StartNewKeyPairRequestAPIModel) (result StartNewKeyPairRequestResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StartNewKeyPairRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: newKeyPairRequest,
                 Constraints: []validation.Constraint{	{Target: "newKeyPairRequest.EntityID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "newKeyPairRequest.GroupID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "newKeyPairRequest.SubjectName", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcvault.BaseClient", "StartNewKeyPairRequest", err.Error())
                }

                    req, err := client.StartNewKeyPairRequestPreparer(ctx, newKeyPairRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "StartNewKeyPairRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.StartNewKeyPairRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "StartNewKeyPairRequest", resp, "Failure sending request")
                return
                }

                result, err = client.StartNewKeyPairRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "StartNewKeyPairRequest", resp, "Failure responding to request")
                }

        return
        }

        // StartNewKeyPairRequestPreparer prepares the StartNewKeyPairRequest request.
        func (client BaseClient) StartNewKeyPairRequestPreparer(ctx context.Context, newKeyPairRequest StartNewKeyPairRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/requests/keypair"),
        autorest.WithJSON(newKeyPairRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StartNewKeyPairRequestSender sends the StartNewKeyPairRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StartNewKeyPairRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // StartNewKeyPairRequestResponder handles the response to the StartNewKeyPairRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StartNewKeyPairRequestResponder(resp *http.Response) (result StartNewKeyPairRequestResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // StartSigningRequest the request is in the 'New' state after this call.
    // Requires Writer or Manager role.
        // Parameters:
            // signingRequest - the signing request parameters
    func (client BaseClient) StartSigningRequest(ctx context.Context, signingRequest StartSigningRequestAPIModel) (result StartSigningRequestResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StartSigningRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: signingRequest,
                 Constraints: []validation.Constraint{	{Target: "signingRequest.EntityID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "signingRequest.GroupID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "signingRequest.CertificateRequest", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcvault.BaseClient", "StartSigningRequest", err.Error())
                }

                    req, err := client.StartSigningRequestPreparer(ctx, signingRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "StartSigningRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.StartSigningRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "StartSigningRequest", resp, "Failure sending request")
                return
                }

                result, err = client.StartSigningRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "StartSigningRequest", resp, "Failure responding to request")
                }

        return
        }

        // StartSigningRequestPreparer prepares the StartSigningRequest request.
        func (client BaseClient) StartSigningRequestPreparer(ctx context.Context, signingRequest StartSigningRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/requests/sign"),
        autorest.WithJSON(signingRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StartSigningRequestSender sends the StartSigningRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StartSigningRequestSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // StartSigningRequestResponder handles the response to the StartSigningRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StartSigningRequestResponder(resp *http.Response) (result StartSigningRequestResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateGroup use this function with care and only if you are aware of
    // the security implications.
    // Requires manager role.
        // Parameters:
            // groupID - the group id
            // request - the group configuration
    func (client BaseClient) UpdateGroup(ctx context.Context, groupID string, request TrustGroupUpdateRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateGroup")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateGroupPreparer(ctx, groupID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "UpdateGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateGroupSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "UpdateGroup", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcvault.BaseClient", "UpdateGroup", resp, "Failure responding to request")
                }

        return
        }

        // UpdateGroupPreparer prepares the UpdateGroup request.
        func (client BaseClient) UpdateGroupPreparer(ctx context.Context, groupID string, request TrustGroupUpdateRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "groupId": autorest.Encode("path",groupID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/groups/{groupId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateGroupSender sends the UpdateGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateGroupSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateGroupResponder handles the response to the UpdateGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateGroupResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

