// Package azureiiotopcregistry implements the Azure ARM Azureiiotopcregistry
// service API version v2.
//
// Azure Industrial IoT OPC UA Registry Service
package azureiiotopcregistry

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Azureiiotopcregistry
DefaultBaseURI = "http://localhost")

// BaseClient is the base client for Azureiiotopcregistry.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // ActivateEndpoint activates an endpoint for subsequent use in twin service.
    // All endpoints must be activated using this API or through a
    // activation filter during application registration or discovery.
        // Parameters:
            // endpointID - endpoint identifier
    func (client BaseClient) ActivateEndpoint(ctx context.Context, endpointID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ActivateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ActivateEndpointPreparer(ctx, endpointID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.ActivateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.ActivateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // ActivateEndpointPreparer prepares the ActivateEndpoint request.
        func (client BaseClient) ActivateEndpointPreparer(ctx context.Context, endpointID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}/activate",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ActivateEndpointSender sends the ActivateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ActivateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ActivateEndpointResponder handles the response to the ActivateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ActivateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // CreateApplication the application is registered using the provided
    // information, but it
    // is not associated with a supervisor.  This is useful for when you need
    // to register clients or you want to register a server that is located
    // in a network not reachable through a Twin module.
        // Parameters:
            // request - application registration request
    func (client BaseClient) CreateApplication(ctx context.Context, request ApplicationRegistrationRequestAPIModel) (result ApplicationRegistrationResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateApplication")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.ApplicationURI", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "request.Capabilities", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "request.Capabilities", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "request.DiscoveryUrls", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "request.DiscoveryUrls", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError("azureiiotopcregistry.BaseClient", "CreateApplication", err.Error())
                }

                    req, err := client.CreateApplicationPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateApplicationSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", resp, "Failure sending request")
                return
                }

                result, err = client.CreateApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", resp, "Failure responding to request")
                }

        return
        }

        // CreateApplicationPreparer prepares the CreateApplication request.
        func (client BaseClient) CreateApplicationPreparer(ctx context.Context, request ApplicationRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateApplicationSender sends the CreateApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CreateApplicationResponder handles the response to the CreateApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateApplicationResponder(resp *http.Response) (result ApplicationRegistrationResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeactivateEndpoint deactivates the endpoint and disable access through twin
    // service.
        // Parameters:
            // endpointID - endpoint identifier
    func (client BaseClient) DeactivateEndpoint(ctx context.Context, endpointID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeactivateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeactivateEndpointPreparer(ctx, endpointID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeactivateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.DeactivateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // DeactivateEndpointPreparer prepares the DeactivateEndpoint request.
        func (client BaseClient) DeactivateEndpointPreparer(ctx context.Context, endpointID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}/deactivate",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeactivateEndpointSender sends the DeactivateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeactivateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeactivateEndpointResponder handles the response to the DeactivateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeactivateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteAllDisabledApplications purges all applications that have not been
    // seen for a specified amount of time.
        // Parameters:
            // notSeenFor - a duration in milliseconds
    func (client BaseClient) DeleteAllDisabledApplications(ctx context.Context, notSeenFor string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteAllDisabledApplications")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteAllDisabledApplicationsPreparer(ctx, notSeenFor)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteAllDisabledApplicationsSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteAllDisabledApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", resp, "Failure responding to request")
                }

        return
        }

        // DeleteAllDisabledApplicationsPreparer prepares the DeleteAllDisabledApplications request.
        func (client BaseClient) DeleteAllDisabledApplicationsPreparer(ctx context.Context, notSeenFor string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(notSeenFor) > 0 {
                queryParameters["notSeenFor"] = autorest.Encode("query",notSeenFor)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteAllDisabledApplicationsSender sends the DeleteAllDisabledApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteAllDisabledApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteAllDisabledApplicationsResponder handles the response to the DeleteAllDisabledApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteAllDisabledApplicationsResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteApplication unregisters and deletes application and all its associated
    // endpoints.
        // Parameters:
            // applicationID - the identifier of the application
    func (client BaseClient) DeleteApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", resp, "Failure responding to request")
                }

        return
        }

        // DeleteApplicationPreparer prepares the DeleteApplication request.
        func (client BaseClient) DeleteApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteApplicationSender sends the DeleteApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteApplicationResponder handles the response to the DeleteApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DisableApplication a manager can disable an application.
        // Parameters:
            // applicationID - the application id
    func (client BaseClient) DisableApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DisableApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DisableApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.DisableApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", resp, "Failure sending request")
                return
                }

                result, err = client.DisableApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", resp, "Failure responding to request")
                }

        return
        }

        // DisableApplicationPreparer prepares the DisableApplication request.
        func (client BaseClient) DisableApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}/disable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DisableApplicationSender sends the DisableApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DisableApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DisableApplicationResponder handles the response to the DisableApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DisableApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DiscoverServer registers servers by running a discovery scan in a
    // supervisor's
    // network. Requires that the onboarding agent service is running.
        // Parameters:
            // request - discovery request
    func (client BaseClient) DiscoverServer(ctx context.Context, request DiscoveryRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DiscoverServer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DiscoverServerPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.DiscoverServerSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", resp, "Failure sending request")
                return
                }

                result, err = client.DiscoverServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", resp, "Failure responding to request")
                }

        return
        }

        // DiscoverServerPreparer prepares the DiscoverServer request.
        func (client BaseClient) DiscoverServerPreparer(ctx context.Context, request DiscoveryRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/discover"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DiscoverServerSender sends the DiscoverServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DiscoverServerSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DiscoverServerResponder handles the response to the DiscoverServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DiscoverServerResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // EnableApplication a manager can enable an application.
        // Parameters:
            // applicationID - the application id
    func (client BaseClient) EnableApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.EnableApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.EnableApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.EnableApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", resp, "Failure sending request")
                return
                }

                result, err = client.EnableApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", resp, "Failure responding to request")
                }

        return
        }

        // EnableApplicationPreparer prepares the EnableApplication request.
        func (client BaseClient) EnableApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}/enable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // EnableApplicationSender sends the EnableApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) EnableApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // EnableApplicationResponder handles the response to the EnableApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) EnableApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetApplicationRegistration sends the get application registration request.
        // Parameters:
            // applicationID - application id for the server
    func (client BaseClient) GetApplicationRegistration(ctx context.Context, applicationID string) (result ApplicationRegistrationAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetApplicationRegistration")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetApplicationRegistrationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetApplicationRegistrationSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", resp, "Failure sending request")
                return
                }

                result, err = client.GetApplicationRegistrationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", resp, "Failure responding to request")
                }

        return
        }

        // GetApplicationRegistrationPreparer prepares the GetApplicationRegistration request.
        func (client BaseClient) GetApplicationRegistrationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetApplicationRegistrationSender sends the GetApplicationRegistration request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetApplicationRegistrationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetApplicationRegistrationResponder handles the response to the GetApplicationRegistration request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationRegistrationResponder(resp *http.Response) (result ApplicationRegistrationAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetEndpoint gets information about an endpoint.
        // Parameters:
            // endpointID - endpoint identifier
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
    func (client BaseClient) GetEndpoint(ctx context.Context, endpointID string, onlyServerState *bool) (result EndpointInfoAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetEndpoint")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetEndpointPreparer(ctx, endpointID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetEndpointSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.GetEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // GetEndpointPreparer prepares the GetEndpoint request.
        func (client BaseClient) GetEndpointPreparer(ctx context.Context, endpointID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetEndpointSender sends the GetEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetEndpointResponder handles the response to the GetEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEndpointResponder(resp *http.Response) (result EndpointInfoAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfApplications get a list of applications filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfApplications operation using the token to retrieve
    // more results.
        // Parameters:
            // query - applications Query model
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfApplications(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (result ApplicationInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfApplications")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfApplicationsPreparer(ctx, query, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfApplicationsPreparer prepares the GetFilteredListOfApplications request.
        func (client BaseClient) GetFilteredListOfApplicationsPreparer(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfApplicationsSender sends the GetFilteredListOfApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfApplicationsResponder handles the response to the GetFilteredListOfApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfEndpoints get a list of endpoints filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfEndpoints operation using the token to retrieve
    // more results.
        // Parameters:
            // URLParameter - endoint url for direct server access
            // userAuthentication - type of credential selected for authentication
            // certificate - certificate of the endpoint
            // securityMode - security Mode
            // securityPolicy - security policy uri
            // activated - whether the endpoint was activated
            // connected - whether the endpoint is connected on supervisor.
            // endpointState - the last state of the the activated endpoint
            // includeNotSeenSince - whether to include endpoints that were soft
            // deleted
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - optional number of results to
            // return
    func (client BaseClient) GetFilteredListOfEndpoints(ctx context.Context, URLParameter string, userAuthentication string, certificate []byte, securityMode string, securityPolicy string, activated *bool, connected *bool, endpointState string, includeNotSeenSince *bool, onlyServerState *bool, pageSize *int32) (result EndpointInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfEndpoints")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfEndpointsPreparer(ctx, URLParameter, userAuthentication, certificate, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfEndpointsPreparer prepares the GetFilteredListOfEndpoints request.
        func (client BaseClient) GetFilteredListOfEndpointsPreparer(ctx context.Context, URLParameter string, userAuthentication string, certificate []byte, securityMode string, securityPolicy string, activated *bool, connected *bool, endpointState string, includeNotSeenSince *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(URLParameter) > 0 {
                queryParameters["Url"] = autorest.Encode("query",URLParameter)
                }
                if len(string(userAuthentication)) > 0 {
                queryParameters["UserAuthentication"] = autorest.Encode("query",userAuthentication)
                }
                if certificate != nil && len(certificate) > 0 {
                queryParameters["Certificate"] = autorest.Encode("query",certificate)
                }
                if len(string(securityMode)) > 0 {
                queryParameters["SecurityMode"] = autorest.Encode("query",securityMode)
                }
                if len(securityPolicy) > 0 {
                queryParameters["SecurityPolicy"] = autorest.Encode("query",securityPolicy)
                }
                if activated != nil {
                queryParameters["Activated"] = autorest.Encode("query",*activated)
                }
                if connected != nil {
                queryParameters["Connected"] = autorest.Encode("query",*connected)
                }
                if len(string(endpointState)) > 0 {
                queryParameters["EndpointState"] = autorest.Encode("query",endpointState)
                }
                if includeNotSeenSince != nil {
                queryParameters["IncludeNotSeenSince"] = autorest.Encode("query",*includeNotSeenSince)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfEndpointsSender sends the GetFilteredListOfEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfEndpointsResponder handles the response to the GetFilteredListOfEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfSupervisors get a list of supervisors filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfSupervisors operation using the token to retrieve
    // more results.
        // Parameters:
            // siteID - site of the supervisor
            // discovery - discovery mode of supervisor
            // connected - included connected or disconnected
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfSupervisors(ctx context.Context, siteID string, discovery string, connected *bool, onlyServerState *bool, pageSize *int32) (result SupervisorListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfSupervisors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfSupervisorsPreparer(ctx, siteID, discovery, connected, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfSupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfSupervisorsPreparer prepares the GetFilteredListOfSupervisors request.
        func (client BaseClient) GetFilteredListOfSupervisorsPreparer(ctx context.Context, siteID string, discovery string, connected *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["SiteId"] = autorest.Encode("query",siteID)
                }
                if len(string(discovery)) > 0 {
                queryParameters["Discovery"] = autorest.Encode("query",discovery)
                }
                if connected != nil {
                queryParameters["Connected"] = autorest.Encode("query",*connected)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfSupervisorsSender sends the GetFilteredListOfSupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfSupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfSupervisorsResponder handles the response to the GetFilteredListOfSupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfSupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetListOfApplications get all registered applications in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // continuationToken - optional Continuation
            // token
            // pageSize - optional number of results to
            // return
    func (client BaseClient) GetListOfApplications(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationInfoListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfApplications")
            defer func() {
                sc := -1
                if result.ailam.Response.Response != nil {
                    sc = result.ailam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfApplicationsNextResults
        req, err := client.GetListOfApplicationsPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfApplicationsSender(req)
                if err != nil {
                result.ailam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", resp, "Failure sending request")
                return
                }

                result.ailam, err = client.GetListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfApplicationsPreparer prepares the GetListOfApplications request.
        func (client BaseClient) GetListOfApplicationsPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfApplicationsSender sends the GetListOfApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfApplicationsResponder handles the response to the GetListOfApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfApplicationsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfApplicationsNextResults(ctx context.Context, lastResults ApplicationInfoListAPIModel) (result ApplicationInfoListAPIModel, err error) {
                req, err := lastResults.applicationInfoListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfApplicationsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfApplicationsComplete(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationInfoListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfApplications")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfApplications(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfEndpoints get all registered endpoints in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfEndpoints(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result EndpointInfoListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfEndpoints")
            defer func() {
                sc := -1
                if result.eilam.Response.Response != nil {
                    sc = result.eilam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfEndpointsNextResults
        req, err := client.GetListOfEndpointsPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfEndpointsSender(req)
                if err != nil {
                result.eilam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", resp, "Failure sending request")
                return
                }

                result.eilam, err = client.GetListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfEndpointsPreparer prepares the GetListOfEndpoints request.
        func (client BaseClient) GetListOfEndpointsPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfEndpointsSender sends the GetListOfEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfEndpointsResponder handles the response to the GetListOfEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfEndpointsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfEndpointsNextResults(ctx context.Context, lastResults EndpointInfoListAPIModel) (result EndpointInfoListAPIModel, err error) {
                req, err := lastResults.endpointInfoListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfEndpointsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfEndpointsComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result EndpointInfoListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfEndpoints")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfEndpoints(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetListOfSites list all sites applications are registered in.
        // Parameters:
            // continuationToken - optional Continuation
            // token
            // pageSize - optional number of results to
            // return
    func (client BaseClient) GetListOfSites(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationSiteListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSites")
            defer func() {
                sc := -1
                if result.aslam.Response.Response != nil {
                    sc = result.aslam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfSitesNextResults
        req, err := client.GetListOfSitesPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfSitesSender(req)
                if err != nil {
                result.aslam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", resp, "Failure sending request")
                return
                }

                result.aslam, err = client.GetListOfSitesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfSitesPreparer prepares the GetListOfSites request.
        func (client BaseClient) GetListOfSitesPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/sites"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfSitesSender sends the GetListOfSites request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfSitesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfSitesResponder handles the response to the GetListOfSites request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfSitesResponder(resp *http.Response) (result ApplicationSiteListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfSitesNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfSitesNextResults(ctx context.Context, lastResults ApplicationSiteListAPIModel) (result ApplicationSiteListAPIModel, err error) {
                req, err := lastResults.applicationSiteListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfSitesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfSitesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfSitesComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfSitesComplete(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationSiteListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSites")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfSites(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfSupervisors get all registered supervisors and therefore twin
    // modules in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfSupervisors(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result SupervisorListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSupervisors")
            defer func() {
                sc := -1
                if result.slam.Response.Response != nil {
                    sc = result.slam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfSupervisorsNextResults
        req, err := client.GetListOfSupervisorsPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfSupervisorsSender(req)
                if err != nil {
                result.slam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", resp, "Failure sending request")
                return
                }

                result.slam, err = client.GetListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfSupervisorsPreparer prepares the GetListOfSupervisors request.
        func (client BaseClient) GetListOfSupervisorsPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfSupervisorsSender sends the GetListOfSupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfSupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfSupervisorsResponder handles the response to the GetListOfSupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfSupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfSupervisorsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfSupervisorsNextResults(ctx context.Context, lastResults SupervisorListAPIModel) (result SupervisorListAPIModel, err error) {
                req, err := lastResults.supervisorListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfSupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfSupervisorsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfSupervisorsComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result SupervisorListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSupervisors")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfSupervisors(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetStatus sends the get status request.
    func (client BaseClient) GetStatus(ctx context.Context) (result StatusResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetStatusPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetStatusPreparer prepares the GetStatus request.
        func (client BaseClient) GetStatusPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/status"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetStatusSender sends the GetStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetStatusResponder handles the response to the GetStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetStatusResponder(resp *http.Response) (result StatusResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSupervisor returns a supervisor's registration and connectivity
    // information.
    // A supervisor id corresponds to the twin modules module identity.
        // Parameters:
            // supervisorID - supervisor identifier
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
    func (client BaseClient) GetSupervisor(ctx context.Context, supervisorID string, onlyServerState *bool) (result SupervisorAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSupervisor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSupervisorPreparer(ctx, supervisorID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSupervisorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.GetSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // GetSupervisorPreparer prepares the GetSupervisor request.
        func (client BaseClient) GetSupervisorPreparer(ctx context.Context, supervisorID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSupervisorSender sends the GetSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSupervisorResponder handles the response to the GetSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSupervisorResponder(resp *http.Response) (result SupervisorAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSupervisorStatus allows a caller to get runtime status for a supervisor.
        // Parameters:
            // supervisorID - supervisor identifier
    func (client BaseClient) GetSupervisorStatus(ctx context.Context, supervisorID string) (result SupervisorStatusAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSupervisorStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSupervisorStatusPreparer(ctx, supervisorID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSupervisorStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetSupervisorStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetSupervisorStatusPreparer prepares the GetSupervisorStatus request.
        func (client BaseClient) GetSupervisorStatusPreparer(ctx context.Context, supervisorID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}/status",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSupervisorStatusSender sends the GetSupervisorStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSupervisorStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSupervisorStatusResponder handles the response to the GetSupervisorStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSupervisorStatusResponder(resp *http.Response) (result SupervisorStatusAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryApplications list applications that match a query model.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfApplications operation using the token to retrieve
    // more results.
        // Parameters:
            // query - application query
            // pageSize - optional number of results to
            // return
    func (client BaseClient) QueryApplications(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (result ApplicationInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryApplications")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryApplicationsPreparer(ctx, query, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", resp, "Failure sending request")
                return
                }

                result, err = client.QueryApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", resp, "Failure responding to request")
                }

        return
        }

        // QueryApplicationsPreparer prepares the QueryApplications request.
        func (client BaseClient) QueryApplicationsPreparer(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryApplicationsSender sends the QueryApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryApplicationsResponder handles the response to the QueryApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryApplicationsByID a query model which supports the OPC UA Global
    // Discovery Server query.
    func (client BaseClient) QueryApplicationsByID(ctx context.Context, query *ApplicationRecordQueryAPIModel) (result ApplicationRecordListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryApplicationsByID")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryApplicationsByIDPreparer(ctx, query)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplicationsByID", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryApplicationsByIDSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplicationsByID", resp, "Failure sending request")
                return
                }

                result, err = client.QueryApplicationsByIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplicationsByID", resp, "Failure responding to request")
                }

        return
        }

        // QueryApplicationsByIDPreparer prepares the QueryApplicationsByID request.
        func (client BaseClient) QueryApplicationsByIDPreparer(ctx context.Context, query *ApplicationRecordQueryAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/querybyid"))
                if query != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(query))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryApplicationsByIDSender sends the QueryApplicationsByID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryApplicationsByIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryApplicationsByIDResponder handles the response to the QueryApplicationsByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryApplicationsByIDResponder(resp *http.Response) (result ApplicationRecordListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryEndpoints return endpoints that match the specified query.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfEndpoints operation using the token to retrieve
    // more results.
        // Parameters:
            // query - query to match
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // pageSize - optional number of results to return
    func (client BaseClient) QueryEndpoints(ctx context.Context, query EndpointRegistrationQueryAPIModel, onlyServerState *bool, pageSize *int32) (result EndpointInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryEndpoints")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryEndpointsPreparer(ctx, query, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", resp, "Failure sending request")
                return
                }

                result, err = client.QueryEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // QueryEndpointsPreparer prepares the QueryEndpoints request.
        func (client BaseClient) QueryEndpointsPreparer(ctx context.Context, query EndpointRegistrationQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryEndpointsSender sends the QueryEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryEndpointsResponder handles the response to the QueryEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QuerySupervisors get all supervisors that match a specified query.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfSupervisors operation using the token to retrieve
    // more results.
        // Parameters:
            // query - supervisors query model
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
            // pageSize - number of results to return
    func (client BaseClient) QuerySupervisors(ctx context.Context, query SupervisorQueryAPIModel, onlyServerState *bool, pageSize *int32) (result SupervisorListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QuerySupervisors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QuerySupervisorsPreparer(ctx, query, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.QuerySupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", resp, "Failure sending request")
                return
                }

                result, err = client.QuerySupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", resp, "Failure responding to request")
                }

        return
        }

        // QuerySupervisorsPreparer prepares the QuerySupervisors request.
        func (client BaseClient) QuerySupervisorsPreparer(ctx context.Context, query SupervisorQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QuerySupervisorsSender sends the QuerySupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QuerySupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QuerySupervisorsResponder handles the response to the QuerySupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QuerySupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RegisterServer registers a server solely using a discovery url. Requires
    // that
    // the onboarding agent service is running and the server can be
    // located by a supervisor in its network using the discovery url.
        // Parameters:
            // request - server registration request
    func (client BaseClient) RegisterServer(ctx context.Context, request ServerRegistrationRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RegisterServer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.DiscoveryURL", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcregistry.BaseClient", "RegisterServer", err.Error())
                }

                    req, err := client.RegisterServerPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.RegisterServerSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", resp, "Failure sending request")
                return
                }

                result, err = client.RegisterServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", resp, "Failure responding to request")
                }

        return
        }

        // RegisterServerPreparer prepares the RegisterServer request.
        func (client BaseClient) RegisterServerPreparer(ctx context.Context, request ServerRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RegisterServerSender sends the RegisterServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RegisterServerSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // RegisterServerResponder handles the response to the RegisterServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RegisterServerResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ResetSupervisor allows a caller to reset the twin module using its
    // supervisor
    // identity identifier.
        // Parameters:
            // supervisorID - supervisor identifier
    func (client BaseClient) ResetSupervisor(ctx context.Context, supervisorID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ResetSupervisor")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ResetSupervisorPreparer(ctx, supervisorID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.ResetSupervisorSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.ResetSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // ResetSupervisorPreparer prepares the ResetSupervisor request.
        func (client BaseClient) ResetSupervisorPreparer(ctx context.Context, supervisorID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}/reset",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ResetSupervisorSender sends the ResetSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ResetSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ResetSupervisorResponder handles the response to the ResetSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ResetSupervisorResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateApplicationRegistration the application information is updated with
    // new properties.  Note that
    // this information might be overridden if the application is re-discovered
    // during a discovery run (recurring or one-time).
        // Parameters:
            // applicationID - the identifier of the application
            // request - application update request
    func (client BaseClient) UpdateApplicationRegistration(ctx context.Context, applicationID string, request ApplicationRegistrationUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateApplicationRegistration")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateApplicationRegistrationPreparer(ctx, applicationID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateApplicationRegistrationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateApplicationRegistrationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", resp, "Failure responding to request")
                }

        return
        }

        // UpdateApplicationRegistrationPreparer prepares the UpdateApplicationRegistration request.
        func (client BaseClient) UpdateApplicationRegistrationPreparer(ctx context.Context, applicationID string, request ApplicationRegistrationUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateApplicationRegistrationSender sends the UpdateApplicationRegistration request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateApplicationRegistrationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateApplicationRegistrationResponder handles the response to the UpdateApplicationRegistration request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateApplicationRegistrationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateEndpoint sends the update endpoint request.
        // Parameters:
            // endpointID - endpoint identifier
            // request - endpoint update request
    func (client BaseClient) UpdateEndpoint(ctx context.Context, endpointID string, request EndpointRegistrationUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateEndpointPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // UpdateEndpointPreparer prepares the UpdateEndpoint request.
        func (client BaseClient) UpdateEndpointPreparer(ctx context.Context, endpointID string, request EndpointRegistrationUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateEndpointSender sends the UpdateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateEndpointResponder handles the response to the UpdateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateSupervisor allows a caller to configure recurring discovery runs on
    // the twin module
    // identified by the supervisor id or update site information.
        // Parameters:
            // supervisorID - supervisor identifier
            // request - patch request
    func (client BaseClient) UpdateSupervisor(ctx context.Context, supervisorID string, request SupervisorUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateSupervisor")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateSupervisorPreparer(ctx, supervisorID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateSupervisorSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // UpdateSupervisorPreparer prepares the UpdateSupervisor request.
        func (client BaseClient) UpdateSupervisorPreparer(ctx context.Context, supervisorID string, request SupervisorUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateSupervisorSender sends the UpdateSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateSupervisorResponder handles the response to the UpdateSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateSupervisorResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

