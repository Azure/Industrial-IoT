// Package azureiiotopcregistry implements the Azure ARM Azureiiotopcregistry
// service API version v2.
//
// Azure Industrial IoT OPC UA Registry Service
package azureiiotopcregistry

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Azureiiotopcregistry
DefaultBaseURI = "/registry")

// BaseClient is the base client for Azureiiotopcregistry.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // ActivateEndpoint activates an endpoint for subsequent use in twin service.
    // All endpoints must be activated using this API or through a
    // activation filter during application registration or discovery.
        // Parameters:
            // endpointID - endpoint identifier
    func (client BaseClient) ActivateEndpoint(ctx context.Context, endpointID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ActivateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ActivateEndpointPreparer(ctx, endpointID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.ActivateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.ActivateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // ActivateEndpointPreparer prepares the ActivateEndpoint request.
        func (client BaseClient) ActivateEndpointPreparer(ctx context.Context, endpointID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}/activate",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ActivateEndpointSender sends the ActivateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ActivateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ActivateEndpointResponder handles the response to the ActivateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ActivateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Cancel cancels a discovery request using the request identifier.
        // Parameters:
            // requestID - discovery request
    func (client BaseClient) Cancel(ctx context.Context, requestID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Cancel")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CancelPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Cancel", nil , "Failure preparing request")
        return
        }

                resp, err := client.CancelSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Cancel", resp, "Failure sending request")
                return
                }

                result, err = client.CancelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Cancel", resp, "Failure responding to request")
                }

        return
        }

        // CancelPreparer prepares the Cancel request.
        func (client BaseClient) CancelPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/discover/{requestId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CancelSender sends the Cancel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CancelSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CancelResponder handles the response to the Cancel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CancelResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // CreateApplication the application is registered using the provided
    // information, but it
    // is not associated with a supervisor.  This is useful for when you need
    // to register clients or you want to register a server that is located
    // in a network not reachable through a Twin module.
        // Parameters:
            // request - application registration request
    func (client BaseClient) CreateApplication(ctx context.Context, request ApplicationRegistrationRequestAPIModel) (result ApplicationRegistrationResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateApplication")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.ApplicationURI", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "request.Capabilities", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "request.Capabilities", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "request.DiscoveryUrls", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "request.DiscoveryUrls", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError("azureiiotopcregistry.BaseClient", "CreateApplication", err.Error())
                }

                    req, err := client.CreateApplicationPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateApplicationSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", resp, "Failure sending request")
                return
                }

                result, err = client.CreateApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", resp, "Failure responding to request")
                }

        return
        }

        // CreateApplicationPreparer prepares the CreateApplication request.
        func (client BaseClient) CreateApplicationPreparer(ctx context.Context, request ApplicationRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateApplicationSender sends the CreateApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CreateApplicationResponder handles the response to the CreateApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateApplicationResponder(resp *http.Response) (result ApplicationRegistrationResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeactivateEndpoint deactivates the endpoint and disable access through twin
    // service.
        // Parameters:
            // endpointID - endpoint identifier
    func (client BaseClient) DeactivateEndpoint(ctx context.Context, endpointID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeactivateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeactivateEndpointPreparer(ctx, endpointID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeactivateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.DeactivateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // DeactivateEndpointPreparer prepares the DeactivateEndpoint request.
        func (client BaseClient) DeactivateEndpointPreparer(ctx context.Context, endpointID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}/deactivate",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeactivateEndpointSender sends the DeactivateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeactivateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeactivateEndpointResponder handles the response to the DeactivateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeactivateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteAllDisabledApplications purges all applications that have not been
    // seen for a specified amount of time.
        // Parameters:
            // notSeenFor - a duration in milliseconds
    func (client BaseClient) DeleteAllDisabledApplications(ctx context.Context, notSeenFor string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteAllDisabledApplications")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteAllDisabledApplicationsPreparer(ctx, notSeenFor)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteAllDisabledApplicationsSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteAllDisabledApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", resp, "Failure responding to request")
                }

        return
        }

        // DeleteAllDisabledApplicationsPreparer prepares the DeleteAllDisabledApplications request.
        func (client BaseClient) DeleteAllDisabledApplicationsPreparer(ctx context.Context, notSeenFor string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(notSeenFor) > 0 {
                queryParameters["notSeenFor"] = autorest.Encode("query",notSeenFor)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteAllDisabledApplicationsSender sends the DeleteAllDisabledApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteAllDisabledApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteAllDisabledApplicationsResponder handles the response to the DeleteAllDisabledApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteAllDisabledApplicationsResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteApplication unregisters and deletes application and all its associated
    // endpoints.
        // Parameters:
            // applicationID - the identifier of the application
    func (client BaseClient) DeleteApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", resp, "Failure responding to request")
                }

        return
        }

        // DeleteApplicationPreparer prepares the DeleteApplication request.
        func (client BaseClient) DeleteApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteApplicationSender sends the DeleteApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteApplicationResponder handles the response to the DeleteApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DisableApplication a manager can disable an application.
        // Parameters:
            // applicationID - the application id
    func (client BaseClient) DisableApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DisableApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DisableApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.DisableApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", resp, "Failure sending request")
                return
                }

                result, err = client.DisableApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", resp, "Failure responding to request")
                }

        return
        }

        // DisableApplicationPreparer prepares the DisableApplication request.
        func (client BaseClient) DisableApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}/disable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DisableApplicationSender sends the DisableApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DisableApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DisableApplicationResponder handles the response to the DisableApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DisableApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DiscoverServer registers servers by running a discovery scan in a
    // supervisor's
    // network. Requires that the onboarding agent service is running.
        // Parameters:
            // request - discovery request
    func (client BaseClient) DiscoverServer(ctx context.Context, request DiscoveryRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DiscoverServer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DiscoverServerPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.DiscoverServerSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", resp, "Failure sending request")
                return
                }

                result, err = client.DiscoverServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", resp, "Failure responding to request")
                }

        return
        }

        // DiscoverServerPreparer prepares the DiscoverServer request.
        func (client BaseClient) DiscoverServerPreparer(ctx context.Context, request DiscoveryRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/discover"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DiscoverServerSender sends the DiscoverServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DiscoverServerSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DiscoverServerResponder handles the response to the DiscoverServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DiscoverServerResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // EnableApplication a manager can enable an application.
        // Parameters:
            // applicationID - the application id
    func (client BaseClient) EnableApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.EnableApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.EnableApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.EnableApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", resp, "Failure sending request")
                return
                }

                result, err = client.EnableApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", resp, "Failure responding to request")
                }

        return
        }

        // EnableApplicationPreparer prepares the EnableApplication request.
        func (client BaseClient) EnableApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}/enable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // EnableApplicationSender sends the EnableApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) EnableApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // EnableApplicationResponder handles the response to the EnableApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) EnableApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetApplicationRegistration sends the get application registration request.
        // Parameters:
            // applicationID - application id for the server
    func (client BaseClient) GetApplicationRegistration(ctx context.Context, applicationID string) (result ApplicationRegistrationAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetApplicationRegistration")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetApplicationRegistrationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetApplicationRegistrationSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", resp, "Failure sending request")
                return
                }

                result, err = client.GetApplicationRegistrationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", resp, "Failure responding to request")
                }

        return
        }

        // GetApplicationRegistrationPreparer prepares the GetApplicationRegistration request.
        func (client BaseClient) GetApplicationRegistrationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetApplicationRegistrationSender sends the GetApplicationRegistration request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetApplicationRegistrationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetApplicationRegistrationResponder handles the response to the GetApplicationRegistration request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationRegistrationResponder(resp *http.Response) (result ApplicationRegistrationAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetEndpoint gets information about an endpoint.
        // Parameters:
            // endpointID - endpoint identifier
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
    func (client BaseClient) GetEndpoint(ctx context.Context, endpointID string, onlyServerState *bool) (result EndpointInfoAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetEndpoint")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetEndpointPreparer(ctx, endpointID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetEndpointSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.GetEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // GetEndpointPreparer prepares the GetEndpoint request.
        func (client BaseClient) GetEndpointPreparer(ctx context.Context, endpointID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetEndpointSender sends the GetEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetEndpointResponder handles the response to the GetEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEndpointResponder(resp *http.Response) (result EndpointInfoAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfApplications get a list of applications filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfApplications operation using the token to retrieve
    // more results.
        // Parameters:
            // query - applications Query model
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfApplications(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (result ApplicationInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfApplications")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfApplicationsPreparer(ctx, query, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfApplicationsPreparer prepares the GetFilteredListOfApplications request.
        func (client BaseClient) GetFilteredListOfApplicationsPreparer(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfApplicationsSender sends the GetFilteredListOfApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfApplicationsResponder handles the response to the GetFilteredListOfApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfEndpoints get a list of endpoints filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfEndpoints operation using the token to retrieve
    // more results.
        // Parameters:
            // URLParameter - endoint url for direct server access
            // certificate - certificate of the endpoint
            // securityMode - security Mode
            // securityPolicy - security policy uri
            // activated - whether the endpoint was activated
            // connected - whether the endpoint is connected on supervisor.
            // endpointState - the last state of the the activated endpoint
            // includeNotSeenSince - whether to include endpoints that were soft
            // deleted
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - optional number of results to
            // return
    func (client BaseClient) GetFilteredListOfEndpoints(ctx context.Context, URLParameter string, certificate []byte, securityMode string, securityPolicy string, activated *bool, connected *bool, endpointState string, includeNotSeenSince *bool, onlyServerState *bool, pageSize *int32) (result EndpointInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfEndpoints")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfEndpointsPreparer(ctx, URLParameter, certificate, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfEndpointsPreparer prepares the GetFilteredListOfEndpoints request.
        func (client BaseClient) GetFilteredListOfEndpointsPreparer(ctx context.Context, URLParameter string, certificate []byte, securityMode string, securityPolicy string, activated *bool, connected *bool, endpointState string, includeNotSeenSince *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(URLParameter) > 0 {
                queryParameters["Url"] = autorest.Encode("query",URLParameter)
                }
                if certificate != nil && len(certificate) > 0 {
                queryParameters["Certificate"] = autorest.Encode("query",certificate)
                }
                if len(string(securityMode)) > 0 {
                queryParameters["SecurityMode"] = autorest.Encode("query",securityMode)
                }
                if len(securityPolicy) > 0 {
                queryParameters["SecurityPolicy"] = autorest.Encode("query",securityPolicy)
                }
                if activated != nil {
                queryParameters["Activated"] = autorest.Encode("query",*activated)
                }
                if connected != nil {
                queryParameters["Connected"] = autorest.Encode("query",*connected)
                }
                if len(string(endpointState)) > 0 {
                queryParameters["EndpointState"] = autorest.Encode("query",endpointState)
                }
                if includeNotSeenSince != nil {
                queryParameters["IncludeNotSeenSince"] = autorest.Encode("query",*includeNotSeenSince)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfEndpointsSender sends the GetFilteredListOfEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfEndpointsResponder handles the response to the GetFilteredListOfEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfPublisher get a list of publishers filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfPublisher operation using the token to retrieve
    // more results.
        // Parameters:
            // siteID - site of the publisher
            // connected - included connected or disconnected
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfPublisher(ctx context.Context, siteID string, connected *bool, onlyServerState *bool, pageSize *int32) (result PublisherListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfPublisher")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfPublisherPreparer(ctx, siteID, connected, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfPublisher", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfPublisher", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfPublisherPreparer prepares the GetFilteredListOfPublisher request.
        func (client BaseClient) GetFilteredListOfPublisherPreparer(ctx context.Context, siteID string, connected *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["SiteId"] = autorest.Encode("query",siteID)
                }
                if connected != nil {
                queryParameters["Connected"] = autorest.Encode("query",*connected)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfPublisherSender sends the GetFilteredListOfPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfPublisherResponder handles the response to the GetFilteredListOfPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfPublisherResponder(resp *http.Response) (result PublisherListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfSupervisors get a list of supervisors filtered using the
    // specified query parameters.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfSupervisors operation using the token to retrieve
    // more results.
        // Parameters:
            // siteID - site of the supervisor
            // discovery - discovery mode of supervisor
            // connected - included connected or disconnected
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfSupervisors(ctx context.Context, siteID string, discovery string, connected *bool, onlyServerState *bool, pageSize *int32) (result SupervisorListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfSupervisors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfSupervisorsPreparer(ctx, siteID, discovery, connected, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfSupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfSupervisorsPreparer prepares the GetFilteredListOfSupervisors request.
        func (client BaseClient) GetFilteredListOfSupervisorsPreparer(ctx context.Context, siteID string, discovery string, connected *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["SiteId"] = autorest.Encode("query",siteID)
                }
                if len(string(discovery)) > 0 {
                queryParameters["Discovery"] = autorest.Encode("query",discovery)
                }
                if connected != nil {
                queryParameters["Connected"] = autorest.Encode("query",*connected)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfSupervisorsSender sends the GetFilteredListOfSupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfSupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfSupervisorsResponder handles the response to the GetFilteredListOfSupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfSupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetListOfApplications get all registered applications in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // continuationToken - optional Continuation
            // token
            // pageSize - optional number of results to
            // return
    func (client BaseClient) GetListOfApplications(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationInfoListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfApplications")
            defer func() {
                sc := -1
                if result.ailam.Response.Response != nil {
                    sc = result.ailam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfApplicationsNextResults
        req, err := client.GetListOfApplicationsPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfApplicationsSender(req)
                if err != nil {
                result.ailam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", resp, "Failure sending request")
                return
                }

                result.ailam, err = client.GetListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfApplicationsPreparer prepares the GetListOfApplications request.
        func (client BaseClient) GetListOfApplicationsPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfApplicationsSender sends the GetListOfApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfApplicationsResponder handles the response to the GetListOfApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfApplicationsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfApplicationsNextResults(ctx context.Context, lastResults ApplicationInfoListAPIModel) (result ApplicationInfoListAPIModel, err error) {
                req, err := lastResults.applicationInfoListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfApplicationsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfApplicationsComplete(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationInfoListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfApplications")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfApplications(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfEndpoints get all registered endpoints in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfEndpoints(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result EndpointInfoListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfEndpoints")
            defer func() {
                sc := -1
                if result.eilam.Response.Response != nil {
                    sc = result.eilam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfEndpointsNextResults
        req, err := client.GetListOfEndpointsPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfEndpointsSender(req)
                if err != nil {
                result.eilam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", resp, "Failure sending request")
                return
                }

                result.eilam, err = client.GetListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfEndpointsPreparer prepares the GetListOfEndpoints request.
        func (client BaseClient) GetListOfEndpointsPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfEndpointsSender sends the GetListOfEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfEndpointsResponder handles the response to the GetListOfEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfEndpointsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfEndpointsNextResults(ctx context.Context, lastResults EndpointInfoListAPIModel) (result EndpointInfoListAPIModel, err error) {
                req, err := lastResults.endpointInfoListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfEndpointsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfEndpointsComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result EndpointInfoListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfEndpoints")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfEndpoints(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetListOfPublisher get all registered publishers and therefore twin modules
    // in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfPublisher(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result PublisherListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfPublisher")
            defer func() {
                sc := -1
                if result.plam.Response.Response != nil {
                    sc = result.plam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfPublisherNextResults
        req, err := client.GetListOfPublisherPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfPublisherSender(req)
                if err != nil {
                result.plam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfPublisher", resp, "Failure sending request")
                return
                }

                result.plam, err = client.GetListOfPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfPublisher", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfPublisherPreparer prepares the GetListOfPublisher request.
        func (client BaseClient) GetListOfPublisherPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfPublisherSender sends the GetListOfPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfPublisherResponder handles the response to the GetListOfPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfPublisherResponder(resp *http.Response) (result PublisherListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfPublisherNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfPublisherNextResults(ctx context.Context, lastResults PublisherListAPIModel) (result PublisherListAPIModel, err error) {
                req, err := lastResults.publisherListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfPublisherNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfPublisherNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfPublisherNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfPublisherComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfPublisherComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result PublisherListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfPublisher")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfPublisher(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetListOfSites list all sites applications are registered in.
        // Parameters:
            // continuationToken - optional Continuation
            // token
            // pageSize - optional number of results to
            // return
    func (client BaseClient) GetListOfSites(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationSiteListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSites")
            defer func() {
                sc := -1
                if result.aslam.Response.Response != nil {
                    sc = result.aslam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfSitesNextResults
        req, err := client.GetListOfSitesPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfSitesSender(req)
                if err != nil {
                result.aslam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", resp, "Failure sending request")
                return
                }

                result.aslam, err = client.GetListOfSitesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfSitesPreparer prepares the GetListOfSites request.
        func (client BaseClient) GetListOfSitesPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/sites"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfSitesSender sends the GetListOfSites request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfSitesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfSitesResponder handles the response to the GetListOfSites request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfSitesResponder(resp *http.Response) (result ApplicationSiteListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfSitesNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfSitesNextResults(ctx context.Context, lastResults ApplicationSiteListAPIModel) (result ApplicationSiteListAPIModel, err error) {
                req, err := lastResults.applicationSiteListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfSitesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfSitesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfSitesComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfSitesComplete(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationSiteListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSites")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfSites(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfSupervisors get all registered supervisors and therefore twin
    // modules in paged form.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call this operation again using the token to retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfSupervisors(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result SupervisorListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSupervisors")
            defer func() {
                sc := -1
                if result.slam.Response.Response != nil {
                    sc = result.slam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfSupervisorsNextResults
        req, err := client.GetListOfSupervisorsPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfSupervisorsSender(req)
                if err != nil {
                result.slam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", resp, "Failure sending request")
                return
                }

                result.slam, err = client.GetListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfSupervisorsPreparer prepares the GetListOfSupervisors request.
        func (client BaseClient) GetListOfSupervisorsPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfSupervisorsSender sends the GetListOfSupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfSupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfSupervisorsResponder handles the response to the GetListOfSupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfSupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfSupervisorsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfSupervisorsNextResults(ctx context.Context, lastResults SupervisorListAPIModel) (result SupervisorListAPIModel, err error) {
                req, err := lastResults.supervisorListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfSupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfSupervisorsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfSupervisorsComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result SupervisorListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSupervisors")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfSupervisors(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetPublisher returns a publisher's registration and connectivity
    // information.
    // A publisher id corresponds to the twin modules module identity.
        // Parameters:
            // publisherID - publisher identifier
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
    func (client BaseClient) GetPublisher(ctx context.Context, publisherID string, onlyServerState *bool) (result PublisherAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPublisher")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPublisherPreparer(ctx, publisherID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetPublisher", resp, "Failure sending request")
                return
                }

                result, err = client.GetPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetPublisher", resp, "Failure responding to request")
                }

        return
        }

        // GetPublisherPreparer prepares the GetPublisher request.
        func (client BaseClient) GetPublisherPreparer(ctx context.Context, publisherID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "publisherId": autorest.Encode("path",publisherID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/publishers/{publisherId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPublisherSender sends the GetPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetPublisherResponder handles the response to the GetPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPublisherResponder(resp *http.Response) (result PublisherAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetStatus sends the get status request.
    func (client BaseClient) GetStatus(ctx context.Context) (result StatusResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetStatusPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetStatusPreparer prepares the GetStatus request.
        func (client BaseClient) GetStatusPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/status"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetStatusSender sends the GetStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetStatusResponder handles the response to the GetStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetStatusResponder(resp *http.Response) (result StatusResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSupervisor returns a supervisor's registration and connectivity
    // information.
    // A supervisor id corresponds to the twin modules module identity.
        // Parameters:
            // supervisorID - supervisor identifier
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
    func (client BaseClient) GetSupervisor(ctx context.Context, supervisorID string, onlyServerState *bool) (result SupervisorAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSupervisor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSupervisorPreparer(ctx, supervisorID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSupervisorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.GetSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // GetSupervisorPreparer prepares the GetSupervisor request.
        func (client BaseClient) GetSupervisorPreparer(ctx context.Context, supervisorID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSupervisorSender sends the GetSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSupervisorResponder handles the response to the GetSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSupervisorResponder(resp *http.Response) (result SupervisorAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSupervisorStatus allows a caller to get runtime status for a supervisor.
        // Parameters:
            // supervisorID - supervisor identifier
    func (client BaseClient) GetSupervisorStatus(ctx context.Context, supervisorID string) (result SupervisorStatusAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSupervisorStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSupervisorStatusPreparer(ctx, supervisorID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSupervisorStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetSupervisorStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetSupervisorStatusPreparer prepares the GetSupervisorStatus request.
        func (client BaseClient) GetSupervisorStatusPreparer(ctx context.Context, supervisorID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}/status",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSupervisorStatusSender sends the GetSupervisorStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSupervisorStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSupervisorStatusResponder handles the response to the GetSupervisorStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSupervisorStatusResponder(resp *http.Response) (result SupervisorStatusAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryApplications list applications that match a query model.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfApplications operation using the token to retrieve
    // more results.
        // Parameters:
            // query - application query
            // pageSize - optional number of results to
            // return
    func (client BaseClient) QueryApplications(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (result ApplicationInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryApplications")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryApplicationsPreparer(ctx, query, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", resp, "Failure sending request")
                return
                }

                result, err = client.QueryApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", resp, "Failure responding to request")
                }

        return
        }

        // QueryApplicationsPreparer prepares the QueryApplications request.
        func (client BaseClient) QueryApplicationsPreparer(ctx context.Context, query ApplicationRegistrationQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryApplicationsSender sends the QueryApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryApplicationsResponder handles the response to the QueryApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryApplicationsByID a query model which supports the OPC UA Global
    // Discovery Server query.
    func (client BaseClient) QueryApplicationsByID(ctx context.Context, query *ApplicationRecordQueryAPIModel) (result ApplicationRecordListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryApplicationsByID")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryApplicationsByIDPreparer(ctx, query)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplicationsByID", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryApplicationsByIDSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplicationsByID", resp, "Failure sending request")
                return
                }

                result, err = client.QueryApplicationsByIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplicationsByID", resp, "Failure responding to request")
                }

        return
        }

        // QueryApplicationsByIDPreparer prepares the QueryApplicationsByID request.
        func (client BaseClient) QueryApplicationsByIDPreparer(ctx context.Context, query *ApplicationRecordQueryAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/querybyid"))
                if query != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(query))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryApplicationsByIDSender sends the QueryApplicationsByID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryApplicationsByIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryApplicationsByIDResponder handles the response to the QueryApplicationsByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryApplicationsByIDResponder(resp *http.Response) (result ApplicationRecordListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryEndpoints return endpoints that match the specified query.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfEndpoints operation using the token to retrieve
    // more results.
        // Parameters:
            // query - query to match
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if available
            // pageSize - optional number of results to return
    func (client BaseClient) QueryEndpoints(ctx context.Context, query EndpointRegistrationQueryAPIModel, onlyServerState *bool, pageSize *int32) (result EndpointInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryEndpoints")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryEndpointsPreparer(ctx, query, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", resp, "Failure sending request")
                return
                }

                result, err = client.QueryEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // QueryEndpointsPreparer prepares the QueryEndpoints request.
        func (client BaseClient) QueryEndpointsPreparer(ctx context.Context, query EndpointRegistrationQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryEndpointsSender sends the QueryEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryEndpointsResponder handles the response to the QueryEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryPublisher get all publishers that match a specified query.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfPublisher operation using the token to retrieve
    // more results.
        // Parameters:
            // query - publisher query model
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
            // pageSize - number of results to return
    func (client BaseClient) QueryPublisher(ctx context.Context, query PublisherQueryAPIModel, onlyServerState *bool, pageSize *int32) (result PublisherListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryPublisher")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryPublisherPreparer(ctx, query, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryPublisher", resp, "Failure sending request")
                return
                }

                result, err = client.QueryPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryPublisher", resp, "Failure responding to request")
                }

        return
        }

        // QueryPublisherPreparer prepares the QueryPublisher request.
        func (client BaseClient) QueryPublisherPreparer(ctx context.Context, query PublisherQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryPublisherSender sends the QueryPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryPublisherResponder handles the response to the QueryPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryPublisherResponder(resp *http.Response) (result PublisherListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QuerySupervisors get all supervisors that match a specified query.
    // The returned model can contain a continuation token if more results are
    // available.
    // Call the GetListOfSupervisors operation using the token to retrieve
    // more results.
        // Parameters:
            // query - supervisors query model
            // onlyServerState - whether to include only server
            // state, or display current client state of the endpoint if
            // available
            // pageSize - number of results to return
    func (client BaseClient) QuerySupervisors(ctx context.Context, query SupervisorQueryAPIModel, onlyServerState *bool, pageSize *int32) (result SupervisorListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QuerySupervisors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QuerySupervisorsPreparer(ctx, query, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.QuerySupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", resp, "Failure sending request")
                return
                }

                result, err = client.QuerySupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", resp, "Failure responding to request")
                }

        return
        }

        // QuerySupervisorsPreparer prepares the QuerySupervisors request.
        func (client BaseClient) QuerySupervisorsPreparer(ctx context.Context, query SupervisorQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/query"),
        autorest.WithJSON(query),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QuerySupervisorsSender sends the QuerySupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QuerySupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QuerySupervisorsResponder handles the response to the QuerySupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QuerySupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RegisterServer registers a server solely using a discovery url. Requires
    // that
    // the onboarding agent service is running and the server can be
    // located by a supervisor in its network using the discovery url.
        // Parameters:
            // request - server registration request
    func (client BaseClient) RegisterServer(ctx context.Context, request ServerRegistrationRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RegisterServer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.DiscoveryURL", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcregistry.BaseClient", "RegisterServer", err.Error())
                }

                    req, err := client.RegisterServerPreparer(ctx, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.RegisterServerSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", resp, "Failure sending request")
                return
                }

                result, err = client.RegisterServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", resp, "Failure responding to request")
                }

        return
        }

        // RegisterServerPreparer prepares the RegisterServer request.
        func (client BaseClient) RegisterServerPreparer(ctx context.Context, request ServerRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RegisterServerSender sends the RegisterServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RegisterServerSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // RegisterServerResponder handles the response to the RegisterServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RegisterServerResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ResetSupervisor allows a caller to reset the twin module using its
    // supervisor
    // identity identifier.
        // Parameters:
            // supervisorID - supervisor identifier
    func (client BaseClient) ResetSupervisor(ctx context.Context, supervisorID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ResetSupervisor")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ResetSupervisorPreparer(ctx, supervisorID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.ResetSupervisorSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.ResetSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // ResetSupervisorPreparer prepares the ResetSupervisor request.
        func (client BaseClient) ResetSupervisorPreparer(ctx context.Context, supervisorID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}/reset",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ResetSupervisorSender sends the ResetSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ResetSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ResetSupervisorResponder handles the response to the ResetSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ResetSupervisorResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SetDiscoveryMode allows a caller to configure recurring discovery runs on
    // the
    // discovery module identified by the module id.
        // Parameters:
            // supervisorID - supervisor identifier
            // mode - discovery mode
            // config - discovery configuration
    func (client BaseClient) SetDiscoveryMode(ctx context.Context, supervisorID string, mode string, config *DiscoveryConfigAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SetDiscoveryMode")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SetDiscoveryModePreparer(ctx, supervisorID, mode, config)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SetDiscoveryMode", nil , "Failure preparing request")
        return
        }

                resp, err := client.SetDiscoveryModeSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SetDiscoveryMode", resp, "Failure sending request")
                return
                }

                result, err = client.SetDiscoveryModeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SetDiscoveryMode", resp, "Failure responding to request")
                }

        return
        }

        // SetDiscoveryModePreparer prepares the SetDiscoveryMode request.
        func (client BaseClient) SetDiscoveryModePreparer(ctx context.Context, supervisorID string, mode string, config *DiscoveryConfigAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

                        queryParameters := map[string]interface{} {
            "mode": autorest.Encode("query",mode),
            }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{supervisorId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
                if config != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(config))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SetDiscoveryModeSender sends the SetDiscoveryMode request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SetDiscoveryModeSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SetDiscoveryModeResponder handles the response to the SetDiscoveryMode request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SetDiscoveryModeResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe register a client to receive application events through SignalR.
        // Parameters:
            // userID - the user that will receive application
            // events.
    func (client BaseClient) Subscribe(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubscribePreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubscribeSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe", resp, "Failure sending request")
                return
                }

                result, err = client.SubscribeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe", resp, "Failure responding to request")
                }

        return
        }

        // SubscribePreparer prepares the Subscribe request.
        func (client BaseClient) SubscribePreparer(ctx context.Context, userID string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/events"))
                if len(userID) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(userID))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubscribeSender sends the Subscribe request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubscribeSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SubscribeResponder handles the response to the Subscribe request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubscribeResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe1 register a user to receive endpoint events through SignalR.
        // Parameters:
            // userID - the user id that will receive endpoint
            // events.
    func (client BaseClient) Subscribe1(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe1")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe1Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe1", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe1Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe1", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe1", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe1Preparer prepares the Subscribe1 request.
        func (client BaseClient) Subscribe1Preparer(ctx context.Context, userID string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/events"))
                if len(userID) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(userID))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe1Sender sends the Subscribe1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe1Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe1Responder handles the response to the Subscribe1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe1Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe2 register a user to receive publisher events through SignalR.
        // Parameters:
            // userID - the user id that will receive publisher
            // events.
    func (client BaseClient) Subscribe2(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe2")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe2Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe2", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe2Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe2", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe2", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe2Preparer prepares the Subscribe2 request.
        func (client BaseClient) Subscribe2Preparer(ctx context.Context, userID string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers/events"))
                if len(userID) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(userID))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe2Sender sends the Subscribe2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe2Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe2Responder handles the response to the Subscribe2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe2Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe3 register a user to receive supervisor events through SignalR.
        // Parameters:
            // userID - the user id that will receive supervisor
            // events.
    func (client BaseClient) Subscribe3(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe3")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe3Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe3", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe3Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe3", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe3Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe3", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe3Preparer prepares the Subscribe3 request.
        func (client BaseClient) Subscribe3Preparer(ctx context.Context, userID string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/events"))
                if len(userID) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(userID))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe3Sender sends the Subscribe3 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe3Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe3Responder handles the response to the Subscribe3 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe3Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SubscribeByRequestID register a client to receive discovery progress events
    // through SignalR for a particular request.
        // Parameters:
            // requestID - the request to monitor
            // userID - the user id that will receive discovery
            // events.
    func (client BaseClient) SubscribeByRequestID(ctx context.Context, requestID string, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubscribeByRequestID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubscribeByRequestIDPreparer(ctx, requestID, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByRequestID", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubscribeByRequestIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByRequestID", resp, "Failure sending request")
                return
                }

                result, err = client.SubscribeByRequestIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByRequestID", resp, "Failure responding to request")
                }

        return
        }

        // SubscribeByRequestIDPreparer prepares the SubscribeByRequestID request.
        func (client BaseClient) SubscribeByRequestIDPreparer(ctx context.Context, requestID string, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/requests/{requestId}/events",pathParameters))
                if len(userID) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(userID))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubscribeByRequestIDSender sends the SubscribeByRequestID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubscribeByRequestIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SubscribeByRequestIDResponder handles the response to the SubscribeByRequestID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubscribeByRequestIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SubscribeBySupervisorID register a client to receive discovery progress
    // events
    // through SignalR from a particular supervisor.
        // Parameters:
            // supervisorID - the supervisor to subscribe to
            // userID - the user id that will receive discovery
            // events.
    func (client BaseClient) SubscribeBySupervisorID(ctx context.Context, supervisorID string, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubscribeBySupervisorID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubscribeBySupervisorIDPreparer(ctx, supervisorID, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeBySupervisorID", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubscribeBySupervisorIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeBySupervisorID", resp, "Failure sending request")
                return
                }

                result, err = client.SubscribeBySupervisorIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeBySupervisorID", resp, "Failure responding to request")
                }

        return
        }

        // SubscribeBySupervisorIDPreparer prepares the SubscribeBySupervisorID request.
        func (client BaseClient) SubscribeBySupervisorIDPreparer(ctx context.Context, supervisorID string, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{supervisorId}/events",pathParameters))
                if len(userID) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(userID))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubscribeBySupervisorIDSender sends the SubscribeBySupervisorID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubscribeBySupervisorIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SubscribeBySupervisorIDResponder handles the response to the SubscribeBySupervisorID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubscribeBySupervisorIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe unregister a user and stop it from receiving events.
        // Parameters:
            // userID - the user id that will not receive
            // any more events
    func (client BaseClient) Unsubscribe(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UnsubscribePreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe", nil , "Failure preparing request")
        return
        }

                resp, err := client.UnsubscribeSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe", resp, "Failure sending request")
                return
                }

                result, err = client.UnsubscribeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe", resp, "Failure responding to request")
                }

        return
        }

        // UnsubscribePreparer prepares the Unsubscribe request.
        func (client BaseClient) UnsubscribePreparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UnsubscribeSender sends the Unsubscribe request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UnsubscribeSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UnsubscribeResponder handles the response to the Unsubscribe request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UnsubscribeResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe1 unregister a user and stop it from receiving endpoint events.
        // Parameters:
            // userID - the user id that will not receive
            // any more endpoint events
    func (client BaseClient) Unsubscribe1(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe1")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe1Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe1", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe1Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe1", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe1", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe1Preparer prepares the Unsubscribe1 request.
        func (client BaseClient) Unsubscribe1Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe1Sender sends the Unsubscribe1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe1Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe1Responder handles the response to the Unsubscribe1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe1Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe2 unregister a user and stop it from receiving publisher events.
        // Parameters:
            // userID - the user id that will not receive
            // any more publisher events
    func (client BaseClient) Unsubscribe2(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe2")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe2Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe2", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe2Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe2", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe2", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe2Preparer prepares the Unsubscribe2 request.
        func (client BaseClient) Unsubscribe2Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/publishers/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe2Sender sends the Unsubscribe2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe2Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe2Responder handles the response to the Unsubscribe2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe2Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe3 unregister a user and stop it from receiving supervisor events.
        // Parameters:
            // userID - the user id that will not receive
            // any more supervisor events
    func (client BaseClient) Unsubscribe3(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe3")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe3Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe3", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe3Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe3", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe3Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe3", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe3Preparer prepares the Unsubscribe3 request.
        func (client BaseClient) Unsubscribe3Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe3Sender sends the Unsubscribe3 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe3Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe3Responder handles the response to the Unsubscribe3 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe3Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UnsubscribeByRequestID unregister a client and stop it from receiving
    // discovery
    // events for a particular request.
        // Parameters:
            // requestID - the request to unsubscribe from
            // userID - the user id that will not receive
            // any more discovery progress
    func (client BaseClient) UnsubscribeByRequestID(ctx context.Context, requestID string, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UnsubscribeByRequestID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UnsubscribeByRequestIDPreparer(ctx, requestID, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByRequestID", nil , "Failure preparing request")
        return
        }

                resp, err := client.UnsubscribeByRequestIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByRequestID", resp, "Failure sending request")
                return
                }

                result, err = client.UnsubscribeByRequestIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByRequestID", resp, "Failure responding to request")
                }

        return
        }

        // UnsubscribeByRequestIDPreparer prepares the UnsubscribeByRequestID request.
        func (client BaseClient) UnsubscribeByRequestIDPreparer(ctx context.Context, requestID string, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/requests/{requestId}/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UnsubscribeByRequestIDSender sends the UnsubscribeByRequestID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UnsubscribeByRequestIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UnsubscribeByRequestIDResponder handles the response to the UnsubscribeByRequestID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UnsubscribeByRequestIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UnsubscribeBySupervisorID unregister a client and stop it from receiving
    // discovery events.
        // Parameters:
            // supervisorID - the supervisor to unsubscribe from
            // userID - the user id that will not receive
            // any more discovery progress
    func (client BaseClient) UnsubscribeBySupervisorID(ctx context.Context, supervisorID string, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UnsubscribeBySupervisorID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UnsubscribeBySupervisorIDPreparer(ctx, supervisorID, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeBySupervisorID", nil , "Failure preparing request")
        return
        }

                resp, err := client.UnsubscribeBySupervisorIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeBySupervisorID", resp, "Failure sending request")
                return
                }

                result, err = client.UnsubscribeBySupervisorIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeBySupervisorID", resp, "Failure responding to request")
                }

        return
        }

        // UnsubscribeBySupervisorIDPreparer prepares the UnsubscribeBySupervisorID request.
        func (client BaseClient) UnsubscribeBySupervisorIDPreparer(ctx context.Context, supervisorID string, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{supervisorId}/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UnsubscribeBySupervisorIDSender sends the UnsubscribeBySupervisorID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UnsubscribeBySupervisorIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UnsubscribeBySupervisorIDResponder handles the response to the UnsubscribeBySupervisorID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UnsubscribeBySupervisorIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateApplicationRegistration the application information is updated with
    // new properties.  Note that
    // this information might be overridden if the application is re-discovered
    // during a discovery run (recurring or one-time).
        // Parameters:
            // applicationID - the identifier of the application
            // request - application update request
    func (client BaseClient) UpdateApplicationRegistration(ctx context.Context, applicationID string, request ApplicationRegistrationUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateApplicationRegistration")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateApplicationRegistrationPreparer(ctx, applicationID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateApplicationRegistrationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateApplicationRegistrationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", resp, "Failure responding to request")
                }

        return
        }

        // UpdateApplicationRegistrationPreparer prepares the UpdateApplicationRegistration request.
        func (client BaseClient) UpdateApplicationRegistrationPreparer(ctx context.Context, applicationID string, request ApplicationRegistrationUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateApplicationRegistrationSender sends the UpdateApplicationRegistration request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateApplicationRegistrationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateApplicationRegistrationResponder handles the response to the UpdateApplicationRegistration request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateApplicationRegistrationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdatePublisher allows a caller to configure operations on the publisher
    // module
    // identified by the publisher id.
        // Parameters:
            // publisherID - publisher identifier
            // request - patch request
    func (client BaseClient) UpdatePublisher(ctx context.Context, publisherID string, request PublisherUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdatePublisher")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdatePublisherPreparer(ctx, publisherID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdatePublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdatePublisherSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdatePublisher", resp, "Failure sending request")
                return
                }

                result, err = client.UpdatePublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdatePublisher", resp, "Failure responding to request")
                }

        return
        }

        // UpdatePublisherPreparer prepares the UpdatePublisher request.
        func (client BaseClient) UpdatePublisherPreparer(ctx context.Context, publisherID string, request PublisherUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "publisherId": autorest.Encode("path",publisherID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/publishers/{publisherId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdatePublisherSender sends the UpdatePublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdatePublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdatePublisherResponder handles the response to the UpdatePublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdatePublisherResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateSupervisor allows a caller to configure recurring discovery runs on
    // the twin module
    // identified by the supervisor id or update site information.
        // Parameters:
            // supervisorID - supervisor identifier
            // request - patch request
    func (client BaseClient) UpdateSupervisor(ctx context.Context, supervisorID string, request SupervisorUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateSupervisor")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateSupervisorPreparer(ctx, supervisorID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateSupervisorSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // UpdateSupervisorPreparer prepares the UpdateSupervisor request.
        func (client BaseClient) UpdateSupervisorPreparer(ctx context.Context, supervisorID string, request SupervisorUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateSupervisorSender sends the UpdateSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateSupervisorResponder handles the response to the UpdateSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateSupervisorResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

