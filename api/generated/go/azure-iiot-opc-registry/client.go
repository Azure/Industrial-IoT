// Package azureiiotopcregistry implements the Azure ARM Azureiiotopcregistry
// service API version v2.
//
// Azure Industrial IoT OPC UA Registry Service
package azureiiotopcregistry

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Azureiiotopcregistry
DefaultBaseURI = "http://localhost:9080")

// BaseClient is the base client for Azureiiotopcregistry.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client using a custom
// endpoint.  Use this when interacting with an Azure cloud that uses a
// non-standard base URI (sovereign clouds, Azure stack).
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // ActivateEndpoint activates an endpoint for subsequent use in twin service.
    // All endpoints must be activated using this API or through a activation
    // filter during application registration or discovery.
        // Parameters:
            // endpointID - endpoint identifier
    func (client BaseClient) ActivateEndpoint(ctx context.Context, endpointID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ActivateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ActivateEndpointPreparer(ctx, endpointID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.ActivateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.ActivateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ActivateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // ActivateEndpointPreparer prepares the ActivateEndpoint request.
        func (client BaseClient) ActivateEndpointPreparer(ctx context.Context, endpointID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}/activate",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ActivateEndpointSender sends the ActivateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ActivateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ActivateEndpointResponder handles the response to the ActivateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ActivateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Cancel cancels a discovery request using the request identifier.
        // Parameters:
            // requestID - discovery request
    func (client BaseClient) Cancel(ctx context.Context, requestID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Cancel")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CancelPreparer(ctx, requestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Cancel", nil , "Failure preparing request")
        return
        }

                resp, err := client.CancelSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Cancel", resp, "Failure sending request")
                return
                }

                result, err = client.CancelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Cancel", resp, "Failure responding to request")
                }

        return
        }

        // CancelPreparer prepares the Cancel request.
        func (client BaseClient) CancelPreparer(ctx context.Context, requestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/discover/{requestId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CancelSender sends the Cancel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CancelSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CancelResponder handles the response to the Cancel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CancelResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // CreateApplication the application is registered using the provided
    // information, but it is not associated with a supervisor. This is useful for
    // when you need to register clients or you want to register a server that is
    // located in a network not reachable through a Twin module.
        // Parameters:
            // body - application registration request
    func (client BaseClient) CreateApplication(ctx context.Context, body ApplicationRegistrationRequestAPIModel) (result ApplicationRegistrationResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateApplication")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.ApplicationURI", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "body.Capabilities", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Capabilities", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.DiscoveryUrls", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.DiscoveryUrls", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError("azureiiotopcregistry.BaseClient", "CreateApplication", err.Error())
                }

                    req, err := client.CreateApplicationPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateApplicationSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", resp, "Failure sending request")
                return
                }

                result, err = client.CreateApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "CreateApplication", resp, "Failure responding to request")
                }

        return
        }

        // CreateApplicationPreparer prepares the CreateApplication request.
        func (client BaseClient) CreateApplicationPreparer(ctx context.Context, body ApplicationRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateApplicationSender sends the CreateApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CreateApplicationResponder handles the response to the CreateApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateApplicationResponder(resp *http.Response) (result ApplicationRegistrationResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeactivateEndpoint deactivates the endpoint and disable access through twin
    // service.
        // Parameters:
            // endpointID - endpoint identifier
    func (client BaseClient) DeactivateEndpoint(ctx context.Context, endpointID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeactivateEndpoint")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeactivateEndpointPreparer(ctx, endpointID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeactivateEndpointSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.DeactivateEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeactivateEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // DeactivateEndpointPreparer prepares the DeactivateEndpoint request.
        func (client BaseClient) DeactivateEndpointPreparer(ctx context.Context, endpointID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}/deactivate",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeactivateEndpointSender sends the DeactivateEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeactivateEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeactivateEndpointResponder handles the response to the DeactivateEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeactivateEndpointResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteAllDisabledApplications purges all applications that have not been
    // seen for a specified amount of time.
        // Parameters:
            // notSeenFor - a duration in milliseconds
    func (client BaseClient) DeleteAllDisabledApplications(ctx context.Context, notSeenFor string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteAllDisabledApplications")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteAllDisabledApplicationsPreparer(ctx, notSeenFor)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteAllDisabledApplicationsSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteAllDisabledApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteAllDisabledApplications", resp, "Failure responding to request")
                }

        return
        }

        // DeleteAllDisabledApplicationsPreparer prepares the DeleteAllDisabledApplications request.
        func (client BaseClient) DeleteAllDisabledApplicationsPreparer(ctx context.Context, notSeenFor string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(notSeenFor) > 0 {
                queryParameters["notSeenFor"] = autorest.Encode("query",notSeenFor)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteAllDisabledApplicationsSender sends the DeleteAllDisabledApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteAllDisabledApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteAllDisabledApplicationsResponder handles the response to the DeleteAllDisabledApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteAllDisabledApplicationsResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DeleteApplication unregisters and deletes application and all its associated
    // endpoints.
        // Parameters:
            // applicationID - the identifier of the application
    func (client BaseClient) DeleteApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DeleteApplication", resp, "Failure responding to request")
                }

        return
        }

        // DeleteApplicationPreparer prepares the DeleteApplication request.
        func (client BaseClient) DeleteApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteApplicationSender sends the DeleteApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DeleteApplicationResponder handles the response to the DeleteApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DisableApplication a manager can disable an application.
        // Parameters:
            // applicationID - the application id
    func (client BaseClient) DisableApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DisableApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DisableApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.DisableApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", resp, "Failure sending request")
                return
                }

                result, err = client.DisableApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DisableApplication", resp, "Failure responding to request")
                }

        return
        }

        // DisableApplicationPreparer prepares the DisableApplication request.
        func (client BaseClient) DisableApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}/disable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DisableApplicationSender sends the DisableApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DisableApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DisableApplicationResponder handles the response to the DisableApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DisableApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // DiscoverServer registers servers by running a discovery scan in a
    // supervisor's network. Requires that the onboarding agent service is running.
        // Parameters:
            // body - discovery request
    func (client BaseClient) DiscoverServer(ctx context.Context, body DiscoveryRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DiscoverServer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DiscoverServerPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.DiscoverServerSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", resp, "Failure sending request")
                return
                }

                result, err = client.DiscoverServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "DiscoverServer", resp, "Failure responding to request")
                }

        return
        }

        // DiscoverServerPreparer prepares the DiscoverServer request.
        func (client BaseClient) DiscoverServerPreparer(ctx context.Context, body DiscoveryRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/discover"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DiscoverServerSender sends the DiscoverServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DiscoverServerSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // DiscoverServerResponder handles the response to the DiscoverServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DiscoverServerResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // EnableApplication a manager can enable an application.
        // Parameters:
            // applicationID - the application id
    func (client BaseClient) EnableApplication(ctx context.Context, applicationID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.EnableApplication")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.EnableApplicationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", nil , "Failure preparing request")
        return
        }

                resp, err := client.EnableApplicationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", resp, "Failure sending request")
                return
                }

                result, err = client.EnableApplicationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "EnableApplication", resp, "Failure responding to request")
                }

        return
        }

        // EnableApplicationPreparer prepares the EnableApplication request.
        func (client BaseClient) EnableApplicationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}/enable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // EnableApplicationSender sends the EnableApplication request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) EnableApplicationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // EnableApplicationResponder handles the response to the EnableApplication request. The method always
    // closes the http.Response Body.
    func (client BaseClient) EnableApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetApplicationRegistration sends the get application registration request.
        // Parameters:
            // applicationID - application id for the server
    func (client BaseClient) GetApplicationRegistration(ctx context.Context, applicationID string) (result ApplicationRegistrationAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetApplicationRegistration")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetApplicationRegistrationPreparer(ctx, applicationID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetApplicationRegistrationSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", resp, "Failure sending request")
                return
                }

                result, err = client.GetApplicationRegistrationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetApplicationRegistration", resp, "Failure responding to request")
                }

        return
        }

        // GetApplicationRegistrationPreparer prepares the GetApplicationRegistration request.
        func (client BaseClient) GetApplicationRegistrationPreparer(ctx context.Context, applicationID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetApplicationRegistrationSender sends the GetApplicationRegistration request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetApplicationRegistrationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetApplicationRegistrationResponder handles the response to the GetApplicationRegistration request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetApplicationRegistrationResponder(resp *http.Response) (result ApplicationRegistrationAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetDiscoverer returns a discoverer's registration and connectivity
    // information. A discoverer id corresponds to the twin modules module
    // identity.
        // Parameters:
            // discovererID - discoverer identifier
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
    func (client BaseClient) GetDiscoverer(ctx context.Context, discovererID string, onlyServerState *bool) (result DiscovererAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetDiscoverer")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetDiscovererPreparer(ctx, discovererID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetDiscoverer", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetDiscovererSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetDiscoverer", resp, "Failure sending request")
                return
                }

                result, err = client.GetDiscovererResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetDiscoverer", resp, "Failure responding to request")
                }

        return
        }

        // GetDiscovererPreparer prepares the GetDiscoverer request.
        func (client BaseClient) GetDiscovererPreparer(ctx context.Context, discovererID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "discovererId": autorest.Encode("path",discovererID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{discovererId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetDiscovererSender sends the GetDiscoverer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetDiscovererSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetDiscovererResponder handles the response to the GetDiscoverer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetDiscovererResponder(resp *http.Response) (result DiscovererAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetEndpoint gets information about an endpoint.
        // Parameters:
            // endpointID - endpoint identifier
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
    func (client BaseClient) GetEndpoint(ctx context.Context, endpointID string, onlyServerState *bool) (result EndpointInfoAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetEndpoint")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetEndpointPreparer(ctx, endpointID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetEndpointSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", resp, "Failure sending request")
                return
                }

                result, err = client.GetEndpointResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetEndpoint", resp, "Failure responding to request")
                }

        return
        }

        // GetEndpointPreparer prepares the GetEndpoint request.
        func (client BaseClient) GetEndpointPreparer(ctx context.Context, endpointID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/{endpointId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetEndpointSender sends the GetEndpoint request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetEndpointSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetEndpointResponder handles the response to the GetEndpoint request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetEndpointResponder(resp *http.Response) (result EndpointInfoAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfApplications get a list of applications filtered using the
    // specified query parameters. The returned model can contain a continuation
    // token if more results are available. Call the GetListOfApplications
    // operation using the token to retrieve more results.
        // Parameters:
            // body - applications Query model
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfApplications(ctx context.Context, body ApplicationRegistrationQueryAPIModel, pageSize *int32) (result ApplicationInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfApplications")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfApplicationsPreparer(ctx, body, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfApplications", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfApplicationsPreparer prepares the GetFilteredListOfApplications request.
        func (client BaseClient) GetFilteredListOfApplicationsPreparer(ctx context.Context, body ApplicationRegistrationQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfApplicationsSender sends the GetFilteredListOfApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfApplicationsResponder handles the response to the GetFilteredListOfApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfDiscoverers get a list of discoverers filtered using the
    // specified query parameters. The returned model can contain a continuation
    // token if more results are available. Call the GetListOfDiscoverers operation
    // using the token to retrieve more results.
        // Parameters:
            // siteID - site of the discoverer
            // discovery - discovery mode of discoverer
            // connected - included connected or disconnected
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfDiscoverers(ctx context.Context, siteID string, discovery DiscoveryMode, connected *bool, onlyServerState *bool, pageSize *int32) (result DiscovererListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfDiscoverers")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfDiscoverersPreparer(ctx, siteID, discovery, connected, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfDiscoverers", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfDiscoverersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfDiscoverers", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfDiscoverersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfDiscoverers", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfDiscoverersPreparer prepares the GetFilteredListOfDiscoverers request.
        func (client BaseClient) GetFilteredListOfDiscoverersPreparer(ctx context.Context, siteID string, discovery DiscoveryMode, connected *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["siteId"] = autorest.Encode("query",siteID)
                }
                if len(string(discovery)) > 0 {
                queryParameters["discovery"] = autorest.Encode("query",discovery)
                }
                if connected != nil {
                queryParameters["connected"] = autorest.Encode("query",*connected)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/discovery/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfDiscoverersSender sends the GetFilteredListOfDiscoverers request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfDiscoverersSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfDiscoverersResponder handles the response to the GetFilteredListOfDiscoverers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfDiscoverersResponder(resp *http.Response) (result DiscovererListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfEndpoints get a list of endpoints filtered using the
    // specified query parameters. The returned model can contain a continuation
    // token if more results are available. Call the GetListOfEndpoints operation
    // using the token to retrieve more results.
        // Parameters:
            // URLParameter - endoint url for direct server access
            // certificate - certificate of the endpoint
            // securityMode - security Mode
            // securityPolicy - security policy uri
            // activated - whether the endpoint was activated
            // connected - whether the endpoint is connected on supervisor.
            // endpointState - the last state of the the activated endpoint
            // includeNotSeenSince - whether to include endpoints that were soft
            // deleted
            // discovererID - discoverer id to filter with
            // applicationID - application id to filter
            // supervisorID - supervisor id to filter with
            // siteOrGatewayID - site or gateway id to filter with
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - optional number of results to return
    func (client BaseClient) GetFilteredListOfEndpoints(ctx context.Context, URLParameter string, certificate []byte, securityMode SecurityMode, securityPolicy string, activated *bool, connected *bool, endpointState EndpointConnectivityState, includeNotSeenSince *bool, discovererID string, applicationID string, supervisorID string, siteOrGatewayID string, onlyServerState *bool, pageSize *int32) (result EndpointInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfEndpoints")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfEndpointsPreparer(ctx, URLParameter, certificate, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, discovererID, applicationID, supervisorID, siteOrGatewayID, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfEndpointsPreparer prepares the GetFilteredListOfEndpoints request.
        func (client BaseClient) GetFilteredListOfEndpointsPreparer(ctx context.Context, URLParameter string, certificate []byte, securityMode SecurityMode, securityPolicy string, activated *bool, connected *bool, endpointState EndpointConnectivityState, includeNotSeenSince *bool, discovererID string, applicationID string, supervisorID string, siteOrGatewayID string, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(URLParameter) > 0 {
                queryParameters["url"] = autorest.Encode("query",URLParameter)
                }
                if certificate != nil && len(certificate) > 0 {
                queryParameters["certificate"] = autorest.Encode("query",certificate)
                }
                if len(string(securityMode)) > 0 {
                queryParameters["securityMode"] = autorest.Encode("query",securityMode)
                }
                if len(securityPolicy) > 0 {
                queryParameters["securityPolicy"] = autorest.Encode("query",securityPolicy)
                }
                if activated != nil {
                queryParameters["activated"] = autorest.Encode("query",*activated)
                }
                if connected != nil {
                queryParameters["connected"] = autorest.Encode("query",*connected)
                }
                if len(string(endpointState)) > 0 {
                queryParameters["endpointState"] = autorest.Encode("query",endpointState)
                }
                if includeNotSeenSince != nil {
                queryParameters["includeNotSeenSince"] = autorest.Encode("query",*includeNotSeenSince)
                }
                if len(discovererID) > 0 {
                queryParameters["discovererId"] = autorest.Encode("query",discovererID)
                }
                if len(applicationID) > 0 {
                queryParameters["applicationId"] = autorest.Encode("query",applicationID)
                }
                if len(supervisorID) > 0 {
                queryParameters["supervisorId"] = autorest.Encode("query",supervisorID)
                }
                if len(siteOrGatewayID) > 0 {
                queryParameters["siteOrGatewayId"] = autorest.Encode("query",siteOrGatewayID)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfEndpointsSender sends the GetFilteredListOfEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfEndpointsResponder handles the response to the GetFilteredListOfEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfGateway get a list of Gateways filtered using the specified
    // query parameters. The returned model can contain a continuation token if
    // more results are available. Call the GetListOfGateway operation using the
    // token to retrieve more results.
        // Parameters:
            // siteID - site of the Gateway
            // connected - included connected or disconnected
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfGateway(ctx context.Context, siteID string, connected *bool, pageSize *int32) (result GatewayListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfGateway")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfGatewayPreparer(ctx, siteID, connected, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfGateway", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfGatewaySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfGateway", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfGatewayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfGateway", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfGatewayPreparer prepares the GetFilteredListOfGateway request.
        func (client BaseClient) GetFilteredListOfGatewayPreparer(ctx context.Context, siteID string, connected *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["siteId"] = autorest.Encode("query",siteID)
                }
                if connected != nil {
                queryParameters["connected"] = autorest.Encode("query",*connected)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/gateways/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfGatewaySender sends the GetFilteredListOfGateway request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfGatewaySender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfGatewayResponder handles the response to the GetFilteredListOfGateway request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfGatewayResponder(resp *http.Response) (result GatewayListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfPublisher get a list of publishers filtered using the
    // specified query parameters. The returned model can contain a continuation
    // token if more results are available. Call the GetListOfPublisher operation
    // using the token to retrieve more results.
        // Parameters:
            // siteID - site for the publishers
            // connected - included connected or disconnected
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfPublisher(ctx context.Context, siteID string, connected *bool, onlyServerState *bool, pageSize *int32) (result PublisherListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfPublisher")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfPublisherPreparer(ctx, siteID, connected, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfPublisher", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfPublisher", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfPublisherPreparer prepares the GetFilteredListOfPublisher request.
        func (client BaseClient) GetFilteredListOfPublisherPreparer(ctx context.Context, siteID string, connected *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["siteId"] = autorest.Encode("query",siteID)
                }
                if connected != nil {
                queryParameters["connected"] = autorest.Encode("query",*connected)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfPublisherSender sends the GetFilteredListOfPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfPublisherResponder handles the response to the GetFilteredListOfPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfPublisherResponder(resp *http.Response) (result PublisherListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFilteredListOfSupervisors get a list of supervisors filtered using the
    // specified query parameters. The returned model can contain a continuation
    // token if more results are available. Call the GetListOfSupervisors operation
    // using the token to retrieve more results.
        // Parameters:
            // siteID - site for the supervisors
            // connected - included connected or disconnected
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - number of results to return
    func (client BaseClient) GetFilteredListOfSupervisors(ctx context.Context, siteID string, connected *bool, onlyServerState *bool, pageSize *int32) (result SupervisorListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFilteredListOfSupervisors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFilteredListOfSupervisorsPreparer(ctx, siteID, connected, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFilteredListOfSupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", resp, "Failure sending request")
                return
                }

                result, err = client.GetFilteredListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetFilteredListOfSupervisors", resp, "Failure responding to request")
                }

        return
        }

        // GetFilteredListOfSupervisorsPreparer prepares the GetFilteredListOfSupervisors request.
        func (client BaseClient) GetFilteredListOfSupervisorsPreparer(ctx context.Context, siteID string, connected *bool, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(siteID) > 0 {
                queryParameters["siteId"] = autorest.Encode("query",siteID)
                }
                if connected != nil {
                queryParameters["connected"] = autorest.Encode("query",*connected)
                }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/query"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFilteredListOfSupervisorsSender sends the GetFilteredListOfSupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFilteredListOfSupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetFilteredListOfSupervisorsResponder handles the response to the GetFilteredListOfSupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFilteredListOfSupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetGateway returns a Gateway's registration and connectivity information. A
    // Gateway id corresponds to the twin modules module identity.
        // Parameters:
            // gatewayID - gateway identifier
    func (client BaseClient) GetGateway(ctx context.Context, gatewayID string) (result GatewayInfoAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetGateway")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetGatewayPreparer(ctx, gatewayID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetGateway", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetGatewaySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetGateway", resp, "Failure sending request")
                return
                }

                result, err = client.GetGatewayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetGateway", resp, "Failure responding to request")
                }

        return
        }

        // GetGatewayPreparer prepares the GetGateway request.
        func (client BaseClient) GetGatewayPreparer(ctx context.Context, gatewayID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "GatewayId": autorest.Encode("path",gatewayID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/gateways/{GatewayId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetGatewaySender sends the GetGateway request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetGatewaySender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetGatewayResponder handles the response to the GetGateway request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetGatewayResponder(resp *http.Response) (result GatewayInfoAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetListOfApplications get all registered applications in paged form. The
    // returned model can contain a continuation token if more results are
    // available. Call this operation again using the token to retrieve more
    // results.
        // Parameters:
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfApplications(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationInfoListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfApplications")
            defer func() {
                sc := -1
                if result.ailam.Response.Response != nil {
                    sc = result.ailam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfApplicationsNextResults
        req, err := client.GetListOfApplicationsPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfApplicationsSender(req)
                if err != nil {
                result.ailam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", resp, "Failure sending request")
                return
                }

                result.ailam, err = client.GetListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfApplications", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfApplicationsPreparer prepares the GetListOfApplications request.
        func (client BaseClient) GetListOfApplicationsPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfApplicationsSender sends the GetListOfApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfApplicationsResponder handles the response to the GetListOfApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfApplicationsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfApplicationsNextResults(ctx context.Context, lastResults ApplicationInfoListAPIModel) (result ApplicationInfoListAPIModel, err error) {
                req, err := lastResults.applicationInfoListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfApplicationsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfApplicationsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfApplicationsComplete(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationInfoListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfApplications")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfApplications(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfDiscoverers get all registered discoverers and therefore twin
    // modules in paged form. The returned model can contain a continuation token
    // if more results are available. Call this operation again using the token to
    // retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfDiscoverers(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result DiscovererListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfDiscoverers")
            defer func() {
                sc := -1
                if result.dlam.Response.Response != nil {
                    sc = result.dlam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfDiscoverersNextResults
        req, err := client.GetListOfDiscoverersPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfDiscoverers", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfDiscoverersSender(req)
                if err != nil {
                result.dlam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfDiscoverers", resp, "Failure sending request")
                return
                }

                result.dlam, err = client.GetListOfDiscoverersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfDiscoverers", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfDiscoverersPreparer prepares the GetListOfDiscoverers request.
        func (client BaseClient) GetListOfDiscoverersPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/discovery"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfDiscoverersSender sends the GetListOfDiscoverers request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfDiscoverersSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfDiscoverersResponder handles the response to the GetListOfDiscoverers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfDiscoverersResponder(resp *http.Response) (result DiscovererListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfDiscoverersNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfDiscoverersNextResults(ctx context.Context, lastResults DiscovererListAPIModel) (result DiscovererListAPIModel, err error) {
                req, err := lastResults.discovererListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfDiscoverersNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfDiscoverersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfDiscoverersNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfDiscoverersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfDiscoverersNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfDiscoverersComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfDiscoverersComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result DiscovererListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfDiscoverers")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfDiscoverers(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetListOfEndpoints get all registered endpoints in paged form. The returned
    // model can contain a continuation token if more results are available. Call
    // this operation again using the token to retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfEndpoints(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result EndpointInfoListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfEndpoints")
            defer func() {
                sc := -1
                if result.eilam.Response.Response != nil {
                    sc = result.eilam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfEndpointsNextResults
        req, err := client.GetListOfEndpointsPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfEndpointsSender(req)
                if err != nil {
                result.eilam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", resp, "Failure sending request")
                return
                }

                result.eilam, err = client.GetListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfEndpointsPreparer prepares the GetListOfEndpoints request.
        func (client BaseClient) GetListOfEndpointsPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfEndpointsSender sends the GetListOfEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfEndpointsResponder handles the response to the GetListOfEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfEndpointsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfEndpointsNextResults(ctx context.Context, lastResults EndpointInfoListAPIModel) (result EndpointInfoListAPIModel, err error) {
                req, err := lastResults.endpointInfoListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfEndpointsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfEndpointsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfEndpointsComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result EndpointInfoListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfEndpoints")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfEndpoints(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetListOfGateway get all registered Gateways and therefore twin modules in
    // paged form. The returned model can contain a continuation token if more
    // results are available. Call this operation again using the token to retrieve
    // more results.
        // Parameters:
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfGateway(ctx context.Context, continuationToken string, pageSize *int32) (result GatewayListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfGateway")
            defer func() {
                sc := -1
                if result.glam.Response.Response != nil {
                    sc = result.glam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfGatewayNextResults
        req, err := client.GetListOfGatewayPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfGateway", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfGatewaySender(req)
                if err != nil {
                result.glam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfGateway", resp, "Failure sending request")
                return
                }

                result.glam, err = client.GetListOfGatewayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfGateway", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfGatewayPreparer prepares the GetListOfGateway request.
        func (client BaseClient) GetListOfGatewayPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/gateways"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfGatewaySender sends the GetListOfGateway request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfGatewaySender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfGatewayResponder handles the response to the GetListOfGateway request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfGatewayResponder(resp *http.Response) (result GatewayListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfGatewayNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfGatewayNextResults(ctx context.Context, lastResults GatewayListAPIModel) (result GatewayListAPIModel, err error) {
                req, err := lastResults.gatewayListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfGatewayNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfGatewaySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfGatewayNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfGatewayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfGatewayNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfGatewayComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfGatewayComplete(ctx context.Context, continuationToken string, pageSize *int32) (result GatewayListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfGateway")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfGateway(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfPublisher get all registered publishers and therefore twin modules
    // in paged form. The returned model can contain a continuation token if more
    // results are available. Call this operation again using the token to retrieve
    // more results.
        // Parameters:
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfPublisher(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result PublisherListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfPublisher")
            defer func() {
                sc := -1
                if result.plam.Response.Response != nil {
                    sc = result.plam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfPublisherNextResults
        req, err := client.GetListOfPublisherPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfPublisherSender(req)
                if err != nil {
                result.plam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfPublisher", resp, "Failure sending request")
                return
                }

                result.plam, err = client.GetListOfPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfPublisher", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfPublisherPreparer prepares the GetListOfPublisher request.
        func (client BaseClient) GetListOfPublisherPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfPublisherSender sends the GetListOfPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfPublisherResponder handles the response to the GetListOfPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfPublisherResponder(resp *http.Response) (result PublisherListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfPublisherNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfPublisherNextResults(ctx context.Context, lastResults PublisherListAPIModel) (result PublisherListAPIModel, err error) {
                req, err := lastResults.publisherListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfPublisherNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfPublisherNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfPublisherNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfPublisherComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfPublisherComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result PublisherListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfPublisher")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfPublisher(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetListOfSites list all sites applications are registered in.
        // Parameters:
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfSites(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationSiteListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSites")
            defer func() {
                sc := -1
                if result.aslam.Response.Response != nil {
                    sc = result.aslam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfSitesNextResults
        req, err := client.GetListOfSitesPreparer(ctx, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfSitesSender(req)
                if err != nil {
                result.aslam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", resp, "Failure sending request")
                return
                }

                result.aslam, err = client.GetListOfSitesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSites", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfSitesPreparer prepares the GetListOfSites request.
        func (client BaseClient) GetListOfSitesPreparer(ctx context.Context, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/sites"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfSitesSender sends the GetListOfSites request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfSitesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfSitesResponder handles the response to the GetListOfSites request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfSitesResponder(resp *http.Response) (result ApplicationSiteListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfSitesNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfSitesNextResults(ctx context.Context, lastResults ApplicationSiteListAPIModel) (result ApplicationSiteListAPIModel, err error) {
                req, err := lastResults.applicationSiteListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfSitesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfSitesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSitesNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfSitesComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfSitesComplete(ctx context.Context, continuationToken string, pageSize *int32) (result ApplicationSiteListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSites")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfSites(ctx, continuationToken, pageSize)
                    return
            }

    // GetListOfSupervisors get all registered supervisors and therefore twin
    // modules in paged form. The returned model can contain a continuation token
    // if more results are available. Call this operation again using the token to
    // retrieve more results.
        // Parameters:
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // continuationToken - optional Continuation token
            // pageSize - optional number of results to return
    func (client BaseClient) GetListOfSupervisors(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result SupervisorListAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSupervisors")
            defer func() {
                sc := -1
                if result.slam.Response.Response != nil {
                    sc = result.slam.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getListOfSupervisorsNextResults
        req, err := client.GetListOfSupervisorsPreparer(ctx, onlyServerState, continuationToken, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListOfSupervisorsSender(req)
                if err != nil {
                result.slam.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", resp, "Failure sending request")
                return
                }

                result.slam, err = client.GetListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetListOfSupervisors", resp, "Failure responding to request")
                }

        return
        }

        // GetListOfSupervisorsPreparer prepares the GetListOfSupervisors request.
        func (client BaseClient) GetListOfSupervisorsPreparer(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if len(continuationToken) > 0 {
                queryParameters["continuationToken"] = autorest.Encode("query",continuationToken)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListOfSupervisorsSender sends the GetListOfSupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListOfSupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetListOfSupervisorsResponder handles the response to the GetListOfSupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListOfSupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getListOfSupervisorsNextResults retrieves the next set of results, if any.
                func (client BaseClient) getListOfSupervisorsNextResults(ctx context.Context, lastResults SupervisorListAPIModel) (result SupervisorListAPIModel, err error) {
                req, err := lastResults.supervisorListAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetListOfSupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetListOfSupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "getListOfSupervisorsNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetListOfSupervisorsComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetListOfSupervisorsComplete(ctx context.Context, onlyServerState *bool, continuationToken string, pageSize *int32) (result SupervisorListAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListOfSupervisors")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetListOfSupervisors(ctx, onlyServerState, continuationToken, pageSize)
                    return
            }

    // GetPublisher returns a publisher's registration and connectivity
    // information. A publisher id corresponds to the twin modules module identity.
        // Parameters:
            // publisherID - publisher identifier
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
    func (client BaseClient) GetPublisher(ctx context.Context, publisherID string, onlyServerState *bool) (result PublisherAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPublisher")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPublisherPreparer(ctx, publisherID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetPublisher", resp, "Failure sending request")
                return
                }

                result, err = client.GetPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetPublisher", resp, "Failure responding to request")
                }

        return
        }

        // GetPublisherPreparer prepares the GetPublisher request.
        func (client BaseClient) GetPublisherPreparer(ctx context.Context, publisherID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "publisherId": autorest.Encode("path",publisherID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/publishers/{publisherId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPublisherSender sends the GetPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetPublisherResponder handles the response to the GetPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPublisherResponder(resp *http.Response) (result PublisherAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSupervisor returns a supervisor's registration and connectivity
    // information. A supervisor id corresponds to the twin modules module
    // identity.
        // Parameters:
            // supervisorID - supervisor identifier
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
    func (client BaseClient) GetSupervisor(ctx context.Context, supervisorID string, onlyServerState *bool) (result SupervisorAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSupervisor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSupervisorPreparer(ctx, supervisorID, onlyServerState)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSupervisorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.GetSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // GetSupervisorPreparer prepares the GetSupervisor request.
        func (client BaseClient) GetSupervisorPreparer(ctx context.Context, supervisorID string, onlyServerState *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

                        queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSupervisorSender sends the GetSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSupervisorResponder handles the response to the GetSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSupervisorResponder(resp *http.Response) (result SupervisorAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSupervisorStatus allows a caller to get runtime status for a supervisor.
        // Parameters:
            // supervisorID - supervisor identifier
    func (client BaseClient) GetSupervisorStatus(ctx context.Context, supervisorID string) (result SupervisorStatusAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSupervisorStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSupervisorStatusPreparer(ctx, supervisorID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSupervisorStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetSupervisorStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "GetSupervisorStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetSupervisorStatusPreparer prepares the GetSupervisorStatus request.
        func (client BaseClient) GetSupervisorStatusPreparer(ctx context.Context, supervisorID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}/status",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSupervisorStatusSender sends the GetSupervisorStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSupervisorStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSupervisorStatusResponder handles the response to the GetSupervisorStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSupervisorStatusResponder(resp *http.Response) (result SupervisorStatusAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryApplications list applications that match a query model. The returned
    // model can contain a continuation token if more results are available. Call
    // the GetListOfApplications operation using the token to retrieve more
    // results.
        // Parameters:
            // body - application query
            // pageSize - optional number of results to return
    func (client BaseClient) QueryApplications(ctx context.Context, body ApplicationRegistrationQueryAPIModel, pageSize *int32) (result ApplicationInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryApplications")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryApplicationsPreparer(ctx, body, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryApplicationsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", resp, "Failure sending request")
                return
                }

                result, err = client.QueryApplicationsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryApplications", resp, "Failure responding to request")
                }

        return
        }

        // QueryApplicationsPreparer prepares the QueryApplications request.
        func (client BaseClient) QueryApplicationsPreparer(ctx context.Context, body ApplicationRegistrationQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryApplicationsSender sends the QueryApplications request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryApplicationsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryApplicationsResponder handles the response to the QueryApplications request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryApplicationsResponder(resp *http.Response) (result ApplicationInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryDiscoverers get all discoverers that match a specified query. The
    // returned model can contain a continuation token if more results are
    // available. Call the GetListOfDiscoverers operation using the token to
    // retrieve more results.
        // Parameters:
            // body - discoverers query model
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - number of results to return
    func (client BaseClient) QueryDiscoverers(ctx context.Context, body DiscovererQueryAPIModel, onlyServerState *bool, pageSize *int32) (result DiscovererListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryDiscoverers")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryDiscoverersPreparer(ctx, body, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryDiscoverers", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryDiscoverersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryDiscoverers", resp, "Failure sending request")
                return
                }

                result, err = client.QueryDiscoverersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryDiscoverers", resp, "Failure responding to request")
                }

        return
        }

        // QueryDiscoverersPreparer prepares the QueryDiscoverers request.
        func (client BaseClient) QueryDiscoverersPreparer(ctx context.Context, body DiscovererQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/discovery/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryDiscoverersSender sends the QueryDiscoverers request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryDiscoverersSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryDiscoverersResponder handles the response to the QueryDiscoverers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryDiscoverersResponder(resp *http.Response) (result DiscovererListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryEndpoints return endpoints that match the specified query. The returned
    // model can contain a continuation token if more results are available. Call
    // the GetListOfEndpoints operation using the token to retrieve more results.
        // Parameters:
            // body - query to match
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - optional number of results to return
    func (client BaseClient) QueryEndpoints(ctx context.Context, body EndpointRegistrationQueryAPIModel, onlyServerState *bool, pageSize *int32) (result EndpointInfoListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryEndpoints")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryEndpointsPreparer(ctx, body, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryEndpointsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", resp, "Failure sending request")
                return
                }

                result, err = client.QueryEndpointsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryEndpoints", resp, "Failure responding to request")
                }

        return
        }

        // QueryEndpointsPreparer prepares the QueryEndpoints request.
        func (client BaseClient) QueryEndpointsPreparer(ctx context.Context, body EndpointRegistrationQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryEndpointsSender sends the QueryEndpoints request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryEndpointsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryEndpointsResponder handles the response to the QueryEndpoints request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryEndpointsResponder(resp *http.Response) (result EndpointInfoListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryGateway get all Gateways that match a specified query. The returned
    // model can contain a continuation token if more results are available. Call
    // the GetListOfGateway operation using the token to retrieve more results.
        // Parameters:
            // body - gateway query model
            // pageSize - number of results to return
    func (client BaseClient) QueryGateway(ctx context.Context, body GatewayQueryAPIModel, pageSize *int32) (result GatewayListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryGateway")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryGatewayPreparer(ctx, body, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryGateway", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryGatewaySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryGateway", resp, "Failure sending request")
                return
                }

                result, err = client.QueryGatewayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryGateway", resp, "Failure responding to request")
                }

        return
        }

        // QueryGatewayPreparer prepares the QueryGateway request.
        func (client BaseClient) QueryGatewayPreparer(ctx context.Context, body GatewayQueryAPIModel, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/gateways/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryGatewaySender sends the QueryGateway request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryGatewaySender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryGatewayResponder handles the response to the QueryGateway request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryGatewayResponder(resp *http.Response) (result GatewayListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryPublisher get all publishers that match a specified query. The returned
    // model can contain a continuation token if more results are available. Call
    // the GetListOfPublisher operation using the token to retrieve more results.
        // Parameters:
            // body - publisher query model
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - number of results to return
    func (client BaseClient) QueryPublisher(ctx context.Context, body PublisherQueryAPIModel, onlyServerState *bool, pageSize *int32) (result PublisherListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryPublisher")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryPublisherPreparer(ctx, body, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryPublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryPublisherSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryPublisher", resp, "Failure sending request")
                return
                }

                result, err = client.QueryPublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QueryPublisher", resp, "Failure responding to request")
                }

        return
        }

        // QueryPublisherPreparer prepares the QueryPublisher request.
        func (client BaseClient) QueryPublisherPreparer(ctx context.Context, body PublisherQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryPublisherSender sends the QueryPublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryPublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QueryPublisherResponder handles the response to the QueryPublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryPublisherResponder(resp *http.Response) (result PublisherListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QuerySupervisors get all supervisors that match a specified query. The
    // returned model can contain a continuation token if more results are
    // available. Call the GetListOfSupervisors operation using the token to
    // retrieve more results.
        // Parameters:
            // body - supervisors query model
            // onlyServerState - whether to include only server state, or display
            // current client state of the endpoint if available
            // pageSize - number of results to return
    func (client BaseClient) QuerySupervisors(ctx context.Context, body SupervisorQueryAPIModel, onlyServerState *bool, pageSize *int32) (result SupervisorListAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QuerySupervisors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QuerySupervisorsPreparer(ctx, body, onlyServerState, pageSize)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", nil , "Failure preparing request")
        return
        }

                resp, err := client.QuerySupervisorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", resp, "Failure sending request")
                return
                }

                result, err = client.QuerySupervisorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "QuerySupervisors", resp, "Failure responding to request")
                }

        return
        }

        // QuerySupervisorsPreparer prepares the QuerySupervisors request.
        func (client BaseClient) QuerySupervisorsPreparer(ctx context.Context, body SupervisorQueryAPIModel, onlyServerState *bool, pageSize *int32) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if onlyServerState != nil {
                queryParameters["onlyServerState"] = autorest.Encode("query",*onlyServerState)
                }
                if pageSize != nil {
                queryParameters["pageSize"] = autorest.Encode("query",*pageSize)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/query"),
        autorest.WithJSON(body),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QuerySupervisorsSender sends the QuerySupervisors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QuerySupervisorsSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // QuerySupervisorsResponder handles the response to the QuerySupervisors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QuerySupervisorsResponder(resp *http.Response) (result SupervisorListAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RegisterServer registers a server solely using a discovery url. Requires
    // that the onboarding agent service is running and the server can be located
    // by a supervisor in its network using the discovery url.
        // Parameters:
            // body - server registration request
    func (client BaseClient) RegisterServer(ctx context.Context, body ServerRegistrationRequestAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RegisterServer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.DiscoveryURL", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopcregistry.BaseClient", "RegisterServer", err.Error())
                }

                    req, err := client.RegisterServerPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.RegisterServerSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", resp, "Failure sending request")
                return
                }

                result, err = client.RegisterServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "RegisterServer", resp, "Failure responding to request")
                }

        return
        }

        // RegisterServerPreparer prepares the RegisterServer request.
        func (client BaseClient) RegisterServerPreparer(ctx context.Context, body ServerRegistrationRequestAPIModel) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RegisterServerSender sends the RegisterServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RegisterServerSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // RegisterServerResponder handles the response to the RegisterServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RegisterServerResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ResetSupervisor allows a caller to reset the twin module using its
    // supervisor identity identifier.
        // Parameters:
            // supervisorID - supervisor identifier
    func (client BaseClient) ResetSupervisor(ctx context.Context, supervisorID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ResetSupervisor")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ResetSupervisorPreparer(ctx, supervisorID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.ResetSupervisorSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.ResetSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "ResetSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // ResetSupervisorPreparer prepares the ResetSupervisor request.
        func (client BaseClient) ResetSupervisorPreparer(ctx context.Context, supervisorID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}/reset",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ResetSupervisorSender sends the ResetSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ResetSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ResetSupervisorResponder handles the response to the ResetSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ResetSupervisorResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SetDiscoveryMode allows a caller to configure recurring discovery runs on
    // the discovery module identified by the module id.
        // Parameters:
            // discovererID - discoverer identifier
            // mode - discovery mode
            // body - discovery configuration
    func (client BaseClient) SetDiscoveryMode(ctx context.Context, discovererID string, mode DiscoveryMode, body *DiscoveryConfigAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SetDiscoveryMode")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SetDiscoveryModePreparer(ctx, discovererID, mode, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SetDiscoveryMode", nil , "Failure preparing request")
        return
        }

                resp, err := client.SetDiscoveryModeSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SetDiscoveryMode", resp, "Failure sending request")
                return
                }

                result, err = client.SetDiscoveryModeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SetDiscoveryMode", resp, "Failure responding to request")
                }

        return
        }

        // SetDiscoveryModePreparer prepares the SetDiscoveryMode request.
        func (client BaseClient) SetDiscoveryModePreparer(ctx context.Context, discovererID string, mode DiscoveryMode, body *DiscoveryConfigAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "discovererId": autorest.Encode("path",discovererID),
                }

                        queryParameters := map[string]interface{} {
            "mode": autorest.Encode("query",mode),
            }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{discovererId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
                if body != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SetDiscoveryModeSender sends the SetDiscoveryMode request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SetDiscoveryModeSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SetDiscoveryModeResponder handles the response to the SetDiscoveryMode request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SetDiscoveryModeResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe register a client to receive application events through SignalR.
        // Parameters:
            // body - the user that will receive application events.
    func (client BaseClient) Subscribe(ctx context.Context, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubscribePreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubscribeSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe", resp, "Failure sending request")
                return
                }

                result, err = client.SubscribeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe", resp, "Failure responding to request")
                }

        return
        }

        // SubscribePreparer prepares the Subscribe request.
        func (client BaseClient) SubscribePreparer(ctx context.Context, body string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/applications/events"))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubscribeSender sends the Subscribe request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubscribeSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SubscribeResponder handles the response to the Subscribe request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubscribeResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe1 register a user to receive discoverer events through SignalR.
        // Parameters:
            // body - the user id that will receive discoverer events.
    func (client BaseClient) Subscribe1(ctx context.Context, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe1")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe1Preparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe1", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe1Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe1", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe1", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe1Preparer prepares the Subscribe1 request.
        func (client BaseClient) Subscribe1Preparer(ctx context.Context, body string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/discovery/events"))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe1Sender sends the Subscribe1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe1Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe1Responder handles the response to the Subscribe1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe1Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe2 register a user to receive endpoint events through SignalR.
        // Parameters:
            // body - the user id that will receive endpoint events.
    func (client BaseClient) Subscribe2(ctx context.Context, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe2")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe2Preparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe2", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe2Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe2", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe2", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe2Preparer prepares the Subscribe2 request.
        func (client BaseClient) Subscribe2Preparer(ctx context.Context, body string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/endpoints/events"))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe2Sender sends the Subscribe2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe2Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe2Responder handles the response to the Subscribe2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe2Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe3 register a user to receive Gateway events through SignalR.
        // Parameters:
            // body - the user id that will receive Gateway events.
    func (client BaseClient) Subscribe3(ctx context.Context, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe3")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe3Preparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe3", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe3Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe3", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe3Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe3", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe3Preparer prepares the Subscribe3 request.
        func (client BaseClient) Subscribe3Preparer(ctx context.Context, body string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/gateways/events"))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe3Sender sends the Subscribe3 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe3Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe3Responder handles the response to the Subscribe3 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe3Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe4 register a user to receive publisher events through SignalR.
        // Parameters:
            // body - the user id that will receive publisher events.
    func (client BaseClient) Subscribe4(ctx context.Context, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe4")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe4Preparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe4", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe4Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe4", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe4Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe4", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe4Preparer prepares the Subscribe4 request.
        func (client BaseClient) Subscribe4Preparer(ctx context.Context, body string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/publishers/events"))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe4Sender sends the Subscribe4 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe4Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe4Responder handles the response to the Subscribe4 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe4Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Subscribe5 register a user to receive supervisor events through SignalR.
        // Parameters:
            // body - the user id that will receive supervisor events.
    func (client BaseClient) Subscribe5(ctx context.Context, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Subscribe5")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Subscribe5Preparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe5", nil , "Failure preparing request")
        return
        }

                resp, err := client.Subscribe5Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe5", resp, "Failure sending request")
                return
                }

                result, err = client.Subscribe5Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Subscribe5", resp, "Failure responding to request")
                }

        return
        }

        // Subscribe5Preparer prepares the Subscribe5 request.
        func (client BaseClient) Subscribe5Preparer(ctx context.Context, body string) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/supervisors/events"))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Subscribe5Sender sends the Subscribe5 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Subscribe5Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Subscribe5Responder handles the response to the Subscribe5 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Subscribe5Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SubscribeByDiscovererID register a client to receive discovery progress
    // events through SignalR from a particular discoverer.
        // Parameters:
            // discovererID - the discoverer to subscribe to
            // body - the user id that will receive discovery events.
    func (client BaseClient) SubscribeByDiscovererID(ctx context.Context, discovererID string, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubscribeByDiscovererID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubscribeByDiscovererIDPreparer(ctx, discovererID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByDiscovererID", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubscribeByDiscovererIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByDiscovererID", resp, "Failure sending request")
                return
                }

                result, err = client.SubscribeByDiscovererIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByDiscovererID", resp, "Failure responding to request")
                }

        return
        }

        // SubscribeByDiscovererIDPreparer prepares the SubscribeByDiscovererID request.
        func (client BaseClient) SubscribeByDiscovererIDPreparer(ctx context.Context, discovererID string, body string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "discovererId": autorest.Encode("path",discovererID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{discovererId}/events",pathParameters))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubscribeByDiscovererIDSender sends the SubscribeByDiscovererID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubscribeByDiscovererIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SubscribeByDiscovererIDResponder handles the response to the SubscribeByDiscovererID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubscribeByDiscovererIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SubscribeByRequestID register a client to receive discovery progress events
    // through SignalR for a particular request.
        // Parameters:
            // requestID - the request to monitor
            // body - the user id that will receive discovery events.
    func (client BaseClient) SubscribeByRequestID(ctx context.Context, requestID string, body string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubscribeByRequestID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubscribeByRequestIDPreparer(ctx, requestID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByRequestID", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubscribeByRequestIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByRequestID", resp, "Failure sending request")
                return
                }

                result, err = client.SubscribeByRequestIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "SubscribeByRequestID", resp, "Failure responding to request")
                }

        return
        }

        // SubscribeByRequestIDPreparer prepares the SubscribeByRequestID request.
        func (client BaseClient) SubscribeByRequestIDPreparer(ctx context.Context, requestID string, body string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/requests/{requestId}/events",pathParameters))
                if len(body) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(body))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubscribeByRequestIDSender sends the SubscribeByRequestID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubscribeByRequestIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // SubscribeByRequestIDResponder handles the response to the SubscribeByRequestID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubscribeByRequestIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe unregister a user and stop it from receiving events.
        // Parameters:
            // userID - the user id that will not receive any more events
    func (client BaseClient) Unsubscribe(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UnsubscribePreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe", nil , "Failure preparing request")
        return
        }

                resp, err := client.UnsubscribeSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe", resp, "Failure sending request")
                return
                }

                result, err = client.UnsubscribeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe", resp, "Failure responding to request")
                }

        return
        }

        // UnsubscribePreparer prepares the Unsubscribe request.
        func (client BaseClient) UnsubscribePreparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UnsubscribeSender sends the Unsubscribe request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UnsubscribeSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UnsubscribeResponder handles the response to the Unsubscribe request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UnsubscribeResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe1 unregister a user and stop it from receiving discoverer events.
        // Parameters:
            // userID - the user id that will not receive any more discoverer
            // events
    func (client BaseClient) Unsubscribe1(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe1")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe1Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe1", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe1Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe1", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe1", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe1Preparer prepares the Unsubscribe1 request.
        func (client BaseClient) Unsubscribe1Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe1Sender sends the Unsubscribe1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe1Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe1Responder handles the response to the Unsubscribe1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe1Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe2 unregister a user and stop it from receiving endpoint events.
        // Parameters:
            // userID - the user id that will not receive any more endpoint events
    func (client BaseClient) Unsubscribe2(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe2")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe2Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe2", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe2Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe2", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe2", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe2Preparer prepares the Unsubscribe2 request.
        func (client BaseClient) Unsubscribe2Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/endpoints/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe2Sender sends the Unsubscribe2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe2Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe2Responder handles the response to the Unsubscribe2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe2Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe3 unregister a user and stop it from receiving Gateway events.
        // Parameters:
            // userID - the user id that will not receive any more Gateway events
    func (client BaseClient) Unsubscribe3(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe3")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe3Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe3", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe3Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe3", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe3Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe3", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe3Preparer prepares the Unsubscribe3 request.
        func (client BaseClient) Unsubscribe3Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/gateways/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe3Sender sends the Unsubscribe3 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe3Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe3Responder handles the response to the Unsubscribe3 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe3Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe4 unregister a user and stop it from receiving publisher events.
        // Parameters:
            // userID - the user id that will not receive any more publisher events
    func (client BaseClient) Unsubscribe4(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe4")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe4Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe4", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe4Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe4", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe4Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe4", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe4Preparer prepares the Unsubscribe4 request.
        func (client BaseClient) Unsubscribe4Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/publishers/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe4Sender sends the Unsubscribe4 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe4Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe4Responder handles the response to the Unsubscribe4 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe4Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // Unsubscribe5 unregister a user and stop it from receiving supervisor events.
        // Parameters:
            // userID - the user id that will not receive any more supervisor
            // events
    func (client BaseClient) Unsubscribe5(ctx context.Context, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Unsubscribe5")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.Unsubscribe5Preparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe5", nil , "Failure preparing request")
        return
        }

                resp, err := client.Unsubscribe5Sender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe5", resp, "Failure sending request")
                return
                }

                result, err = client.Unsubscribe5Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "Unsubscribe5", resp, "Failure responding to request")
                }

        return
        }

        // Unsubscribe5Preparer prepares the Unsubscribe5 request.
        func (client BaseClient) Unsubscribe5Preparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // Unsubscribe5Sender sends the Unsubscribe5 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) Unsubscribe5Sender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // Unsubscribe5Responder handles the response to the Unsubscribe5 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) Unsubscribe5Responder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UnsubscribeByDiscovererID unregister a client and stop it from receiving
    // discovery events.
        // Parameters:
            // discovererID - the discoverer to unsubscribe from
            // userID - the user id that will not receive any more discovery
            // progress
    func (client BaseClient) UnsubscribeByDiscovererID(ctx context.Context, discovererID string, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UnsubscribeByDiscovererID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UnsubscribeByDiscovererIDPreparer(ctx, discovererID, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByDiscovererID", nil , "Failure preparing request")
        return
        }

                resp, err := client.UnsubscribeByDiscovererIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByDiscovererID", resp, "Failure sending request")
                return
                }

                result, err = client.UnsubscribeByDiscovererIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByDiscovererID", resp, "Failure responding to request")
                }

        return
        }

        // UnsubscribeByDiscovererIDPreparer prepares the UnsubscribeByDiscovererID request.
        func (client BaseClient) UnsubscribeByDiscovererIDPreparer(ctx context.Context, discovererID string, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "discovererId": autorest.Encode("path",discovererID),
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{discovererId}/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UnsubscribeByDiscovererIDSender sends the UnsubscribeByDiscovererID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UnsubscribeByDiscovererIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UnsubscribeByDiscovererIDResponder handles the response to the UnsubscribeByDiscovererID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UnsubscribeByDiscovererIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UnsubscribeByRequestID unregister a client and stop it from receiving
    // discovery events for a particular request.
        // Parameters:
            // requestID - the request to unsubscribe from
            // userID - the user id that will not receive any more discovery
            // progress
    func (client BaseClient) UnsubscribeByRequestID(ctx context.Context, requestID string, userID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UnsubscribeByRequestID")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UnsubscribeByRequestIDPreparer(ctx, requestID, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByRequestID", nil , "Failure preparing request")
        return
        }

                resp, err := client.UnsubscribeByRequestIDSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByRequestID", resp, "Failure sending request")
                return
                }

                result, err = client.UnsubscribeByRequestIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UnsubscribeByRequestID", resp, "Failure responding to request")
                }

        return
        }

        // UnsubscribeByRequestIDPreparer prepares the UnsubscribeByRequestID request.
        func (client BaseClient) UnsubscribeByRequestIDPreparer(ctx context.Context, requestID string, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "requestId": autorest.Encode("path",requestID),
                "userId": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/requests/{requestId}/events/{userId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UnsubscribeByRequestIDSender sends the UnsubscribeByRequestID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UnsubscribeByRequestIDSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UnsubscribeByRequestIDResponder handles the response to the UnsubscribeByRequestID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UnsubscribeByRequestIDResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateApplicationRegistration the application information is updated with
    // new properties. Note that this information might be overridden if the
    // application is re-discovered during a discovery run (recurring or one-time).
        // Parameters:
            // applicationID - the identifier of the application
            // body - application update request
    func (client BaseClient) UpdateApplicationRegistration(ctx context.Context, applicationID string, body ApplicationRegistrationUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateApplicationRegistration")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateApplicationRegistrationPreparer(ctx, applicationID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateApplicationRegistrationSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateApplicationRegistrationResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateApplicationRegistration", resp, "Failure responding to request")
                }

        return
        }

        // UpdateApplicationRegistrationPreparer prepares the UpdateApplicationRegistration request.
        func (client BaseClient) UpdateApplicationRegistrationPreparer(ctx context.Context, applicationID string, body ApplicationRegistrationUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "applicationId": autorest.Encode("path",applicationID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/applications/{applicationId}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateApplicationRegistrationSender sends the UpdateApplicationRegistration request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateApplicationRegistrationSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateApplicationRegistrationResponder handles the response to the UpdateApplicationRegistration request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateApplicationRegistrationResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateDiscoverer allows a caller to configure recurring discovery runs on
    // the twin module identified by the discoverer id or update site information.
        // Parameters:
            // discovererID - discoverer identifier
            // body - patch request
    func (client BaseClient) UpdateDiscoverer(ctx context.Context, discovererID string, body DiscovererUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateDiscoverer")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateDiscovererPreparer(ctx, discovererID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateDiscoverer", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateDiscovererSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateDiscoverer", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateDiscovererResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateDiscoverer", resp, "Failure responding to request")
                }

        return
        }

        // UpdateDiscovererPreparer prepares the UpdateDiscoverer request.
        func (client BaseClient) UpdateDiscovererPreparer(ctx context.Context, discovererID string, body DiscovererUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "discovererId": autorest.Encode("path",discovererID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/discovery/{discovererId}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateDiscovererSender sends the UpdateDiscoverer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateDiscovererSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateDiscovererResponder handles the response to the UpdateDiscoverer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateDiscovererResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateGateway allows a caller to configure operations on the Gateway module
    // identified by the Gateway id.
        // Parameters:
            // gatewayID - gateway identifier
            // body - patch request
    func (client BaseClient) UpdateGateway(ctx context.Context, gatewayID string, body GatewayUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateGateway")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateGatewayPreparer(ctx, gatewayID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateGateway", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateGatewaySender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateGateway", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateGatewayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateGateway", resp, "Failure responding to request")
                }

        return
        }

        // UpdateGatewayPreparer prepares the UpdateGateway request.
        func (client BaseClient) UpdateGatewayPreparer(ctx context.Context, gatewayID string, body GatewayUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "GatewayId": autorest.Encode("path",gatewayID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/gateways/{GatewayId}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateGatewaySender sends the UpdateGateway request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateGatewaySender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateGatewayResponder handles the response to the UpdateGateway request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateGatewayResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdatePublisher allows a caller to configure operations on the publisher
    // module identified by the publisher id.
        // Parameters:
            // publisherID - publisher identifier
            // body - patch request
    func (client BaseClient) UpdatePublisher(ctx context.Context, publisherID string, body PublisherUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdatePublisher")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdatePublisherPreparer(ctx, publisherID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdatePublisher", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdatePublisherSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdatePublisher", resp, "Failure sending request")
                return
                }

                result, err = client.UpdatePublisherResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdatePublisher", resp, "Failure responding to request")
                }

        return
        }

        // UpdatePublisherPreparer prepares the UpdatePublisher request.
        func (client BaseClient) UpdatePublisherPreparer(ctx context.Context, publisherID string, body PublisherUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "publisherId": autorest.Encode("path",publisherID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/publishers/{publisherId}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdatePublisherSender sends the UpdatePublisher request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdatePublisherSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdatePublisherResponder handles the response to the UpdatePublisher request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdatePublisherResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // UpdateSupervisor allows a caller to configure recurring discovery runs on
    // the twin module identified by the supervisor id or update site information.
        // Parameters:
            // supervisorID - supervisor identifier
            // body - patch request
    func (client BaseClient) UpdateSupervisor(ctx context.Context, supervisorID string, body SupervisorUpdateAPIModel) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateSupervisor")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateSupervisorPreparer(ctx, supervisorID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateSupervisorSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateSupervisorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopcregistry.BaseClient", "UpdateSupervisor", resp, "Failure responding to request")
                }

        return
        }

        // UpdateSupervisorPreparer prepares the UpdateSupervisor request.
        func (client BaseClient) UpdateSupervisorPreparer(ctx context.Context, supervisorID string, body SupervisorUpdateAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "supervisorId": autorest.Encode("path",supervisorID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPatch(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/supervisors/{supervisorId}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateSupervisorSender sends the UpdateSupervisor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateSupervisorSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // UpdateSupervisorResponder handles the response to the UpdateSupervisor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateSupervisorResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

