// Package azureiiotopctwin implements the Azure ARM Azureiiotopctwin service
// API version v2.
//
// Azure Industrial IoT OPC UA Twin Service
package azureiiotopctwin

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Azureiiotopctwin
DefaultBaseURI = "/twin")

// BaseClient is the base client for Azureiiotopctwin.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // Browse browse a node on the specified endpoint.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the browse request
    func (client BaseClient) Browse(ctx context.Context, endpointID string, request BrowseRequestAPIModel) (result BrowseResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.Browse")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.View", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "request.View.ViewID", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError("azureiiotopctwin.BaseClient", "Browse", err.Error())
                }

                    req, err := client.BrowsePreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "Browse", nil , "Failure preparing request")
        return
        }

                resp, err := client.BrowseSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "Browse", resp, "Failure sending request")
                return
                }

                result, err = client.BrowseResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "Browse", resp, "Failure responding to request")
                }

        return
        }

        // BrowsePreparer prepares the Browse request.
        func (client BaseClient) BrowsePreparer(ctx context.Context, endpointID string, request BrowseRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/browse/{endpointId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // BrowseSender sends the Browse request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) BrowseSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // BrowseResponder handles the response to the Browse request. The method always
    // closes the http.Response Body.
    func (client BaseClient) BrowseResponder(resp *http.Response) (result BrowseResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // BrowseNext browse next set of references on the endpoint.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the request body with continuation token.
    func (client BaseClient) BrowseNext(ctx context.Context, endpointID string, request BrowseNextRequestAPIModel) (result BrowseNextResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.BrowseNext")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.ContinuationToken", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopctwin.BaseClient", "BrowseNext", err.Error())
                }

                    req, err := client.BrowseNextPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "BrowseNext", nil , "Failure preparing request")
        return
        }

                resp, err := client.BrowseNextSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "BrowseNext", resp, "Failure sending request")
                return
                }

                result, err = client.BrowseNextResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "BrowseNext", resp, "Failure responding to request")
                }

        return
        }

        // BrowseNextPreparer prepares the BrowseNext request.
        func (client BaseClient) BrowseNextPreparer(ctx context.Context, endpointID string, request BrowseNextRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/browse/{endpointId}/next",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // BrowseNextSender sends the BrowseNext request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) BrowseNextSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // BrowseNextResponder handles the response to the BrowseNext request. The method always
    // closes the http.Response Body.
    func (client BaseClient) BrowseNextResponder(resp *http.Response) (result BrowseNextResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // BrowseUsingPath browse using a path from the specified node id.
    // This call uses TranslateBrowsePathsToNodeIds service under the hood.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the browse path request
    func (client BaseClient) BrowseUsingPath(ctx context.Context, endpointID string, request BrowsePathRequestAPIModel) (result BrowsePathResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.BrowseUsingPath")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.BrowsePaths", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopctwin.BaseClient", "BrowseUsingPath", err.Error())
                }

                    req, err := client.BrowseUsingPathPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "BrowseUsingPath", nil , "Failure preparing request")
        return
        }

                resp, err := client.BrowseUsingPathSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "BrowseUsingPath", resp, "Failure sending request")
                return
                }

                result, err = client.BrowseUsingPathResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "BrowseUsingPath", resp, "Failure responding to request")
                }

        return
        }

        // BrowseUsingPathPreparer prepares the BrowseUsingPath request.
        func (client BaseClient) BrowseUsingPathPreparer(ctx context.Context, endpointID string, request BrowsePathRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/browse/{endpointId}/path",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // BrowseUsingPathSender sends the BrowseUsingPath request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) BrowseUsingPathSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // BrowseUsingPathResponder handles the response to the BrowseUsingPath request. The method always
    // closes the http.Response Body.
    func (client BaseClient) BrowseUsingPathResponder(resp *http.Response) (result BrowsePathResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CallMethod invoke method node with specified input arguments.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the method call request
    func (client BaseClient) CallMethod(ctx context.Context, endpointID string, request MethodCallRequestAPIModel) (result MethodCallResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CallMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CallMethodPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "CallMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.CallMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "CallMethod", resp, "Failure sending request")
                return
                }

                result, err = client.CallMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "CallMethod", resp, "Failure responding to request")
                }

        return
        }

        // CallMethodPreparer prepares the CallMethod request.
        func (client BaseClient) CallMethodPreparer(ctx context.Context, endpointID string, request MethodCallRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/call/{endpointId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CallMethodSender sends the CallMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CallMethodSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // CallMethodResponder handles the response to the CallMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CallMethodResponder(resp *http.Response) (result MethodCallResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetCallMetadata return method meta data to support a user interface
    // displaying forms to
    // input and output arguments.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the method metadata request
    func (client BaseClient) GetCallMetadata(ctx context.Context, endpointID string, request MethodMetadataRequestAPIModel) (result MethodMetadataResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetCallMetadata")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetCallMetadataPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetCallMetadata", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetCallMetadataSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetCallMetadata", resp, "Failure sending request")
                return
                }

                result, err = client.GetCallMetadataResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetCallMetadata", resp, "Failure responding to request")
                }

        return
        }

        // GetCallMetadataPreparer prepares the GetCallMetadata request.
        func (client BaseClient) GetCallMetadataPreparer(ctx context.Context, endpointID string, request MethodMetadataRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/call/{endpointId}/metadata",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetCallMetadataSender sends the GetCallMetadata request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetCallMetadataSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetCallMetadataResponder handles the response to the GetCallMetadata request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetCallMetadataResponder(resp *http.Response) (result MethodMetadataResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetNextSetOfUniqueNodes browse the next set of unique hierarchically
    // referenced target nodes on the
    // endpoint.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
    // Note that this is the same as the POST method with the model containing
    // the continuation token and the targetNodesOnly flag set to true.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // continuationToken - continuation token from GetSetOfUniqueNodes
            // operation
    func (client BaseClient) GetNextSetOfUniqueNodes(ctx context.Context, endpointID string, continuationToken string) (result BrowseNextResponseAPIModelPage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetNextSetOfUniqueNodes")
            defer func() {
                sc := -1
                if result.bnram.Response.Response != nil {
                    sc = result.bnram.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                    result.fn = client.getNextSetOfUniqueNodesNextResults
        req, err := client.GetNextSetOfUniqueNodesPreparer(ctx, endpointID, continuationToken)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetNextSetOfUniqueNodes", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetNextSetOfUniqueNodesSender(req)
                if err != nil {
                result.bnram.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetNextSetOfUniqueNodes", resp, "Failure sending request")
                return
                }

                result.bnram, err = client.GetNextSetOfUniqueNodesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetNextSetOfUniqueNodes", resp, "Failure responding to request")
                }

        return
        }

        // GetNextSetOfUniqueNodesPreparer prepares the GetNextSetOfUniqueNodes request.
        func (client BaseClient) GetNextSetOfUniqueNodesPreparer(ctx context.Context, endpointID string, continuationToken string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

                        queryParameters := map[string]interface{} {
            "continuationToken": autorest.Encode("query",continuationToken),
            }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/browse/{endpointId}/next",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetNextSetOfUniqueNodesSender sends the GetNextSetOfUniqueNodes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetNextSetOfUniqueNodesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetNextSetOfUniqueNodesResponder handles the response to the GetNextSetOfUniqueNodes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetNextSetOfUniqueNodesResponder(resp *http.Response) (result BrowseNextResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

                // getNextSetOfUniqueNodesNextResults retrieves the next set of results, if any.
                func (client BaseClient) getNextSetOfUniqueNodesNextResults(ctx context.Context, lastResults BrowseNextResponseAPIModel) (result BrowseNextResponseAPIModel, err error) {
                req, err := lastResults.browseNextResponseAPIModelPreparer(ctx)
                if err != nil {
                return result, autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "getNextSetOfUniqueNodesNextResults", nil , "Failure preparing next results request")
                }
                if req == nil {
                return
                }
                resp, err := client.GetNextSetOfUniqueNodesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                return result, autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "getNextSetOfUniqueNodesNextResults", resp, "Failure sending next results request")
                }
                result, err = client.GetNextSetOfUniqueNodesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "getNextSetOfUniqueNodesNextResults", resp, "Failure responding to next results request")
                }
                return
                        }

        // GetNextSetOfUniqueNodesComplete enumerates all values, automatically crossing page boundaries as required.
        func (client BaseClient) GetNextSetOfUniqueNodesComplete(ctx context.Context, endpointID string, continuationToken string) (result BrowseNextResponseAPIModelIterator, err error) {
            if tracing.IsEnabled() {
                ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetNextSetOfUniqueNodes")
                defer func() {
                    sc := -1
                    if result.Response().Response.Response != nil {
                        sc = result.page.Response().Response.Response.StatusCode
                    }
                    tracing.EndSpan(ctx, sc, err)
                }()
         }
            result.page, err = client.GetNextSetOfUniqueNodes(ctx, endpointID, continuationToken)
                    return
            }

    // GetSetOfUniqueNodes browse the set of unique hierarchically referenced
    // target nodes on the endpoint.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
    // The root node id to browse from can be provided as part of the query
    // parameters.
    // If it is not provided, the RootFolder node is browsed. Note that this
    // is the same as the POST method with the model containing the node id
    // and the targetNodesOnly flag set to true.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // nodeID - the node to browse or omit to browse the root node (i=84)
    func (client BaseClient) GetSetOfUniqueNodes(ctx context.Context, endpointID string, nodeID string) (result BrowseResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSetOfUniqueNodes")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSetOfUniqueNodesPreparer(ctx, endpointID, nodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetSetOfUniqueNodes", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSetOfUniqueNodesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetSetOfUniqueNodes", resp, "Failure sending request")
                return
                }

                result, err = client.GetSetOfUniqueNodesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetSetOfUniqueNodes", resp, "Failure responding to request")
                }

        return
        }

        // GetSetOfUniqueNodesPreparer prepares the GetSetOfUniqueNodes request.
        func (client BaseClient) GetSetOfUniqueNodesPreparer(ctx context.Context, endpointID string, nodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(nodeID) > 0 {
                queryParameters["nodeId"] = autorest.Encode("query",nodeID)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/browse/{endpointId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSetOfUniqueNodesSender sends the GetSetOfUniqueNodes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSetOfUniqueNodesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetSetOfUniqueNodesResponder handles the response to the GetSetOfUniqueNodes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSetOfUniqueNodesResponder(resp *http.Response) (result BrowseResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetStatus sends the get status request.
    func (client BaseClient) GetStatus(ctx context.Context) (result StatusResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetStatusPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetStatusPreparer prepares the GetStatus request.
        func (client BaseClient) GetStatusPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/v2/status"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetStatusSender sends the GetStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetStatusSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetStatusResponder handles the response to the GetStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetStatusResponder(resp *http.Response) (result StatusResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetValue get a variable node's value using its node id.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // nodeID - the node to read
    func (client BaseClient) GetValue(ctx context.Context, endpointID string, nodeID string) (result ValueReadResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetValue")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetValuePreparer(ctx, endpointID, nodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetValue", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetValueSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetValue", resp, "Failure sending request")
                return
                }

                result, err = client.GetValueResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "GetValue", resp, "Failure responding to request")
                }

        return
        }

        // GetValuePreparer prepares the GetValue request.
        func (client BaseClient) GetValuePreparer(ctx context.Context, endpointID string, nodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

                        queryParameters := map[string]interface{} {
            "nodeId": autorest.Encode("query",nodeID),
            }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/read/{endpointId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetValueSender sends the GetValue request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetValueSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // GetValueResponder handles the response to the GetValue request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetValueResponder(resp *http.Response) (result ValueReadResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ReadAttributes read attributes of a node.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the read request
    func (client BaseClient) ReadAttributes(ctx context.Context, endpointID string, request ReadRequestAPIModel) (result ReadResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ReadAttributes")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.Attributes", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopctwin.BaseClient", "ReadAttributes", err.Error())
                }

                    req, err := client.ReadAttributesPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "ReadAttributes", nil , "Failure preparing request")
        return
        }

                resp, err := client.ReadAttributesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "ReadAttributes", resp, "Failure sending request")
                return
                }

                result, err = client.ReadAttributesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "ReadAttributes", resp, "Failure responding to request")
                }

        return
        }

        // ReadAttributesPreparer prepares the ReadAttributes request.
        func (client BaseClient) ReadAttributesPreparer(ctx context.Context, endpointID string, request ReadRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/read/{endpointId}/attributes",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ReadAttributesSender sends the ReadAttributes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ReadAttributesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ReadAttributesResponder handles the response to the ReadAttributes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ReadAttributesResponder(resp *http.Response) (result ReadResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ReadValue read a variable node's value.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the read value request
    func (client BaseClient) ReadValue(ctx context.Context, endpointID string, request ValueReadRequestAPIModel) (result ValueReadResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ReadValue")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ReadValuePreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "ReadValue", nil , "Failure preparing request")
        return
        }

                resp, err := client.ReadValueSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "ReadValue", resp, "Failure sending request")
                return
                }

                result, err = client.ReadValueResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "ReadValue", resp, "Failure responding to request")
                }

        return
        }

        // ReadValuePreparer prepares the ReadValue request.
        func (client BaseClient) ReadValuePreparer(ctx context.Context, endpointID string, request ValueReadRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/read/{endpointId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ReadValueSender sends the ReadValue request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ReadValueSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // ReadValueResponder handles the response to the ReadValue request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ReadValueResponder(resp *http.Response) (result ValueReadResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // WriteAttributes write any attribute of a node.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the batch write request
    func (client BaseClient) WriteAttributes(ctx context.Context, endpointID string, request WriteRequestAPIModel) (result WriteResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.WriteAttributes")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.Attributes", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopctwin.BaseClient", "WriteAttributes", err.Error())
                }

                    req, err := client.WriteAttributesPreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "WriteAttributes", nil , "Failure preparing request")
        return
        }

                resp, err := client.WriteAttributesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "WriteAttributes", resp, "Failure sending request")
                return
                }

                result, err = client.WriteAttributesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "WriteAttributes", resp, "Failure responding to request")
                }

        return
        }

        // WriteAttributesPreparer prepares the WriteAttributes request.
        func (client BaseClient) WriteAttributesPreparer(ctx context.Context, endpointID string, request WriteRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/write/{endpointId}/attributes",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // WriteAttributesSender sends the WriteAttributes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) WriteAttributesSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // WriteAttributesResponder handles the response to the WriteAttributes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) WriteAttributesResponder(resp *http.Response) (result WriteResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // WriteValue write variable node's value.
    // The endpoint must be activated and connected and the module client
    // and server must trust each other.
        // Parameters:
            // endpointID - the identifier of the activated endpoint.
            // request - the write value request
    func (client BaseClient) WriteValue(ctx context.Context, endpointID string, request ValueWriteRequestAPIModel) (result ValueWriteResponseAPIModel, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.WriteValue")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: request,
                 Constraints: []validation.Constraint{	{Target: "request.Value", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("azureiiotopctwin.BaseClient", "WriteValue", err.Error())
                }

                    req, err := client.WriteValuePreparer(ctx, endpointID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "WriteValue", nil , "Failure preparing request")
        return
        }

                resp, err := client.WriteValueSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "WriteValue", resp, "Failure sending request")
                return
                }

                result, err = client.WriteValueResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "azureiiotopctwin.BaseClient", "WriteValue", resp, "Failure responding to request")
                }

        return
        }

        // WriteValuePreparer prepares the WriteValue request.
        func (client BaseClient) WriteValuePreparer(ctx context.Context, endpointID string, request ValueWriteRequestAPIModel) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "endpointId": autorest.Encode("path",endpointID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json-patch+json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/v2/write/{endpointId}",pathParameters),
        autorest.WithJSON(request))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // WriteValueSender sends the WriteValue request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) WriteValueSender(req *http.Request) (*http.Response, error) {
            sd := autorest.GetSendDecorators(req.Context(), autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                return autorest.SendWithSender(client, req, sd...)
                }

    // WriteValueResponder handles the response to the WriteValue request. The method always
    // closes the http.Response Body.
    func (client BaseClient) WriteValueResponder(resp *http.Response) (result ValueWriteResponseAPIModel, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

