# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator 2.3.33.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class AzureOpcRegistryClientConfiguration(Configuration):
    """Configuration for AzureOpcRegistryClient
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        if credentials is None:
            raise ValueError("Parameter 'credentials' must not be None.")
        if not base_url:
            base_url = 'http://localhost'

        super(AzureOpcRegistryClientConfiguration, self).__init__(base_url)

        self.add_user_agent('azureopcregistryclient/{}'.format(VERSION))

        self.credentials = credentials


class AzureOpcRegistryClient(object):
    """Azure Industrial IoT OPC UA Registry Service

    :ivar config: Configuration for client.
    :vartype config: AzureOpcRegistryClientConfiguration

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        self.config = AzureOpcRegistryClientConfiguration(credentials, base_url)
        self._client = ServiceClient(self.config.credentials, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = 'v2'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def get_list_of_applications(
            self, continuation_token=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get list of applications.

        Get all registered applications in paged form.
        The returned model can contain a continuation token if more results are
        available.
        Call this operation again using the token to retrieve more results.

        :param continuation_token: Optional Continuation
         token
        :type continuation_token: str
        :param page_size: Optional number of results to
         return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationInfoListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.ApplicationInfoListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_of_applications.metadata['url']

        # Construct parameters
        query_parameters = {}
        if continuation_token is not None:
            query_parameters['continuationToken'] = self._serialize.query("continuation_token", continuation_token, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationInfoListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_list_of_applications.metadata = {'url': '/v2/applications'}

    def create_application(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Create new application.

        The application is registered using the provided information, but it
        is not associated with a supervisor.  This is useful for when you need
        to register clients or you want to register a server that is located
        in a network not reachable through a Twin module.

        :param request: Application registration request
        :type request:
         ~azure-iiot-opc-registry.models.ApplicationRegistrationRequestApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationRegistrationResponseApiModel or ClientRawResponse
         if raw=true
        :rtype:
         ~azure-iiot-opc-registry.models.ApplicationRegistrationResponseApiModel
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_application.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'ApplicationRegistrationRequestApiModel')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationRegistrationResponseApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_application.metadata = {'url': '/v2/applications'}

    def register_server(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Register new server.

        Registers a server solely using a discovery url. Requires that
        the onboarding agent service is running and the server can be
        located by a supervisor in its network using the discovery url.

        :param request: Server registration request
        :type request:
         ~azure-iiot-opc-registry.models.ServerRegistrationRequestApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.register_server.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'ServerRegistrationRequestApiModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    register_server.metadata = {'url': '/v2/applications'}

    def delete_all_disabled_applications(
            self, not_seen_for=None, custom_headers=None, raw=False, **operation_config):
        """Purge applications.

        Purges all applications that have not been seen for a specified amount
        of time.

        :param not_seen_for: A duration in milliseconds
        :type not_seen_for: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_all_disabled_applications.metadata['url']

        # Construct parameters
        query_parameters = {}
        if not_seen_for is not None:
            query_parameters['notSeenFor'] = self._serialize.query("not_seen_for", not_seen_for, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_all_disabled_applications.metadata = {'url': '/v2/applications'}

    def approve_application(
            self, application_id, force=None, custom_headers=None, raw=False, **operation_config):
        """Approve a new application.

        A manager can approve a new application or force an application
        from any state.
        After approval the application is in the 'Approved' state.
        Requires Manager role.

        :param application_id: The application id
        :type application_id: str
        :param force: optional, force application in new state
        :type force: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.approve_application.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if force is not None:
            query_parameters['force'] = self._serialize.query("force", force, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    approve_application.metadata = {'url': '/v2/applications/{applicationId}/approve'}

    def reject_application(
            self, application_id, force=None, custom_headers=None, raw=False, **operation_config):
        """Reject a new application.

        A manager can approve a new application or force an application
        from any state.
        After approval the application is in the 'Rejected' state.
        Requires Manager role.

        :param application_id: The application id
        :type application_id: str
        :param force: optional, force application in new state
        :type force: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reject_application.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if force is not None:
            query_parameters['force'] = self._serialize.query("force", force, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    reject_application.metadata = {'url': '/v2/applications/{applicationId}/reject'}

    def disable_application(
            self, application_id, custom_headers=None, raw=False, **operation_config):
        """Disable an enabled application.

        A manager can disable an application.

        :param application_id: The application id
        :type application_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.disable_application.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    disable_application.metadata = {'url': '/v2/applications/{applicationId}/disable'}

    def enable_application(
            self, application_id, custom_headers=None, raw=False, **operation_config):
        """Re-enable a disabled application.

        A manager can enable an application.

        :param application_id: The application id
        :type application_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.enable_application.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    enable_application.metadata = {'url': '/v2/applications/{applicationId}/enable'}

    def discover_server(
            self, request, custom_headers=None, raw=False, **operation_config):
        """Discover servers.

        Registers servers by running a discovery scan in a supervisor's
        network. Requires that the onboarding agent service is running.

        :param request: Discovery request
        :type request:
         ~azure-iiot-opc-registry.models.DiscoveryRequestApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.discover_server.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'DiscoveryRequestApiModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    discover_server.metadata = {'url': '/v2/applications/discover'}

    def get_application_registration(
            self, application_id, custom_headers=None, raw=False, **operation_config):
        """Get application registration.

        :param application_id: Application id for the server
        :type application_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationRegistrationApiModel or ClientRawResponse if
         raw=true
        :rtype:
         ~azure-iiot-opc-registry.models.ApplicationRegistrationApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_application_registration.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationRegistrationApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_application_registration.metadata = {'url': '/v2/applications/{applicationId}'}

    def delete_application(
            self, application_id, custom_headers=None, raw=False, **operation_config):
        """Unregister application.

        Unregisters and deletes application and all its associated endpoints.

        :param application_id: The identifier of the application
        :type application_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_application.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_application.metadata = {'url': '/v2/applications/{applicationId}'}

    def update_application_registration(
            self, application_id, request, custom_headers=None, raw=False, **operation_config):
        """Update application registration.

        The application information is updated with new properties.  Note that
        this information might be overridden if the application is
        re-discovered
        during a discovery run (recurring or one-time).

        :param application_id: The identifier of the application
        :type application_id: str
        :param request: Application update request
        :type request:
         ~azure-iiot-opc-registry.models.ApplicationRegistrationUpdateApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_application_registration.metadata['url']
        path_format_arguments = {
            'applicationId': self._serialize.url("application_id", application_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'ApplicationRegistrationUpdateApiModel')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_application_registration.metadata = {'url': '/v2/applications/{applicationId}'}

    def get_list_of_sites(
            self, continuation_token=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get list of sites.

        List all sites applications are registered in.

        :param continuation_token: Optional Continuation
         token
        :type continuation_token: str
        :param page_size: Optional number of results to
         return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationSiteListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.ApplicationSiteListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_of_sites.metadata['url']

        # Construct parameters
        query_parameters = {}
        if continuation_token is not None:
            query_parameters['continuationToken'] = self._serialize.query("continuation_token", continuation_token, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationSiteListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_list_of_sites.metadata = {'url': '/v2/applications/sites'}

    def get_filtered_list_of_applications(
            self, query, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get filtered list of applications.

        Get a list of applications filtered using the specified query
        parameters.
        The returned model can contain a continuation token if more results are
        available.
        Call the GetListOfApplications operation using the token to retrieve
        more results.

        :param query: Applications Query model
        :type query:
         ~azure-iiot-opc-registry.models.ApplicationRegistrationQueryApiModel
        :param page_size: Number of results to return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationInfoListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.ApplicationInfoListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_filtered_list_of_applications.metadata['url']

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(query, 'ApplicationRegistrationQueryApiModel')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationInfoListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_filtered_list_of_applications.metadata = {'url': '/v2/applications/query'}

    def query_applications(
            self, query, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Query applications.

        List applications that match a query model.
        The returned model can contain a continuation token if more results are
        available.
        Call the GetListOfApplications operation using the token to retrieve
        more results.

        :param query: Application query
        :type query:
         ~azure-iiot-opc-registry.models.ApplicationRegistrationQueryApiModel
        :param page_size: Optional number of results to
         return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationInfoListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.ApplicationInfoListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.query_applications.metadata['url']

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(query, 'ApplicationRegistrationQueryApiModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationInfoListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    query_applications.metadata = {'url': '/v2/applications/query'}

    def query_applications_by_id(
            self, query=None, custom_headers=None, raw=False, **operation_config):
        """Query applications by id.

        A query model which supports the OPC UA Global Discovery Server query.

        :param query:
        :type query:
         ~azure-iiot-opc-registry.models.ApplicationRecordQueryApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ApplicationRecordListApiModel or ClientRawResponse if
         raw=true
        :rtype: ~azure-iiot-opc-registry.models.ApplicationRecordListApiModel
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.query_applications_by_id.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if query is not None:
            body_content = self._serialize.body(query, 'ApplicationRecordQueryApiModel')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ApplicationRecordListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    query_applications_by_id.metadata = {'url': '/v2/applications/querybyid'}

    def activate_endpoint(
            self, endpoint_id, custom_headers=None, raw=False, **operation_config):
        """Activate endpoint.

        Activates an endpoint for subsequent use in twin service.
        All endpoints must be activated using this API or through a
        activation filter during application registration or discovery.

        :param endpoint_id: endpoint identifier
        :type endpoint_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.activate_endpoint.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    activate_endpoint.metadata = {'url': '/v2/endpoints/{endpointId}/activate'}

    def get_endpoint(
            self, endpoint_id, only_server_state=None, custom_headers=None, raw=False, **operation_config):
        """Get endpoint information.

        Gets information about an endpoint.

        :param endpoint_id: endpoint identifier
        :type endpoint_id: str
        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if
         available
        :type only_server_state: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EndpointInfoApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.EndpointInfoApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_endpoint.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndpointInfoApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_endpoint.metadata = {'url': '/v2/endpoints/{endpointId}'}

    def update_endpoint(
            self, endpoint_id, request, custom_headers=None, raw=False, **operation_config):
        """Update endpoint information.

        :param endpoint_id: endpoint identifier
        :type endpoint_id: str
        :param request: Endpoint update request
        :type request:
         ~azure-iiot-opc-registry.models.EndpointRegistrationUpdateApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_endpoint.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'EndpointRegistrationUpdateApiModel')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_endpoint.metadata = {'url': '/v2/endpoints/{endpointId}'}

    def get_list_of_endpoints(
            self, only_server_state=None, continuation_token=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get list of endpoints.

        Get all registered endpoints in paged form.
        The returned model can contain a continuation token if more results are
        available.
        Call this operation again using the token to retrieve more results.

        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if available
        :type only_server_state: bool
        :param continuation_token: Optional Continuation token
        :type continuation_token: str
        :param page_size: Optional number of results to return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EndpointInfoListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.EndpointInfoListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_of_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')
        if continuation_token is not None:
            query_parameters['continuationToken'] = self._serialize.query("continuation_token", continuation_token, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndpointInfoListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_list_of_endpoints.metadata = {'url': '/v2/endpoints'}

    def get_filtered_list_of_endpoints(
            self, url=None, user_authentication=None, certificate=None, security_mode=None, security_policy=None, activated=None, connected=None, endpoint_state=None, include_not_seen_since=None, only_server_state=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get filtered list of endpoints.

        Get a list of endpoints filtered using the specified query parameters.
        The returned model can contain a continuation token if more results are
        available.
        Call the GetListOfEndpoints operation using the token to retrieve
        more results.

        :param url: Endoint url for direct server access
        :type url: str
        :param user_authentication: Type of credential selected for
         authentication. Possible values include: 'None', 'UserName',
         'X509Certificate', 'JwtToken'
        :type user_authentication: str
        :param certificate: Certificate of the endpoint
        :type certificate: bytearray
        :param security_mode: Security Mode. Possible values include: 'Best',
         'Sign', 'SignAndEncrypt', 'None'
        :type security_mode: str
        :param security_policy: Security policy uri
        :type security_policy: str
        :param activated: Whether the endpoint was activated
        :type activated: bool
        :param connected: Whether the endpoint is connected on supervisor.
        :type connected: bool
        :param endpoint_state: The last state of the the activated endpoint.
         Possible values include: 'Connecting', 'NotReachable', 'Busy',
         'NoTrust', 'CertificateInvalid', 'Ready', 'Error'
        :type endpoint_state: str
        :param include_not_seen_since: Whether to include endpoints that were
         soft deleted
        :type include_not_seen_since: bool
        :param only_server_state: Whether to include only server state, or
         display
         current client state of the endpoint if available
        :type only_server_state: bool
        :param page_size: Optional number of results to
         return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EndpointInfoListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.EndpointInfoListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_filtered_list_of_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}
        if url is not None:
            query_parameters['Url'] = self._serialize.query("url", url, 'str')
        if user_authentication is not None:
            query_parameters['UserAuthentication'] = self._serialize.query("user_authentication", user_authentication, 'str')
        if certificate is not None:
            query_parameters['Certificate'] = self._serialize.query("certificate", certificate, 'bytearray')
        if security_mode is not None:
            query_parameters['SecurityMode'] = self._serialize.query("security_mode", security_mode, 'str')
        if security_policy is not None:
            query_parameters['SecurityPolicy'] = self._serialize.query("security_policy", security_policy, 'str')
        if activated is not None:
            query_parameters['Activated'] = self._serialize.query("activated", activated, 'bool')
        if connected is not None:
            query_parameters['Connected'] = self._serialize.query("connected", connected, 'bool')
        if endpoint_state is not None:
            query_parameters['EndpointState'] = self._serialize.query("endpoint_state", endpoint_state, 'str')
        if include_not_seen_since is not None:
            query_parameters['IncludeNotSeenSince'] = self._serialize.query("include_not_seen_since", include_not_seen_since, 'bool')
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndpointInfoListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_filtered_list_of_endpoints.metadata = {'url': '/v2/endpoints/query'}

    def query_endpoints(
            self, query, only_server_state=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Query endpoints.

        Return endpoints that match the specified query.
        The returned model can contain a continuation token if more results are
        available.
        Call the GetListOfEndpoints operation using the token to retrieve
        more results.

        :param query: Query to match
        :type query:
         ~azure-iiot-opc-registry.models.EndpointRegistrationQueryApiModel
        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if available
        :type only_server_state: bool
        :param page_size: Optional number of results to return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: EndpointInfoListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.EndpointInfoListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.query_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(query, 'EndpointRegistrationQueryApiModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('EndpointInfoListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    query_endpoints.metadata = {'url': '/v2/endpoints/query'}

    def deactivate_endpoint(
            self, endpoint_id, custom_headers=None, raw=False, **operation_config):
        """Deactivate endpoint.

        Deactivates the endpoint and disable access through twin service.

        :param endpoint_id: endpoint identifier
        :type endpoint_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.deactivate_endpoint.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    deactivate_endpoint.metadata = {'url': '/v2/endpoints/{endpointId}/deactivate'}

    def get_status(
            self, custom_headers=None, raw=False, **operation_config):
        """Return the service status in the form of the service status
        api model.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: StatusResponseApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.StatusResponseApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_status.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('StatusResponseApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_status.metadata = {'url': '/v2/status'}

    def get_supervisor(
            self, supervisor_id, only_server_state=None, custom_headers=None, raw=False, **operation_config):
        """Get supervisor registration information.

        Returns a supervisor's registration and connectivity information.
        A supervisor id corresponds to the twin modules module identity.

        :param supervisor_id: Supervisor identifier
        :type supervisor_id: str
        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if
         available
        :type only_server_state: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SupervisorApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.SupervisorApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supervisor.metadata['url']
        path_format_arguments = {
            'supervisorId': self._serialize.url("supervisor_id", supervisor_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SupervisorApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_supervisor.metadata = {'url': '/v2/supervisors/{supervisorId}'}

    def update_supervisor(
            self, supervisor_id, request, custom_headers=None, raw=False, **operation_config):
        """Update supervisor information.

        Allows a caller to configure recurring discovery runs on the twin
        module
        identified by the supervisor id or update site information.

        :param supervisor_id: supervisor identifier
        :type supervisor_id: str
        :param request: Patch request
        :type request:
         ~azure-iiot-opc-registry.models.SupervisorUpdateApiModel
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_supervisor.metadata['url']
        path_format_arguments = {
            'supervisorId': self._serialize.url("supervisor_id", supervisor_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(request, 'SupervisorUpdateApiModel')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_supervisor.metadata = {'url': '/v2/supervisors/{supervisorId}'}

    def get_supervisor_status(
            self, supervisor_id, custom_headers=None, raw=False, **operation_config):
        """Get runtime status of supervisor.

        Allows a caller to get runtime status for a supervisor.

        :param supervisor_id: supervisor identifier
        :type supervisor_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SupervisorStatusApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.SupervisorStatusApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supervisor_status.metadata['url']
        path_format_arguments = {
            'supervisorId': self._serialize.url("supervisor_id", supervisor_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SupervisorStatusApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_supervisor_status.metadata = {'url': '/v2/supervisors/{supervisorId}/status'}

    def reset_supervisor(
            self, supervisor_id, custom_headers=None, raw=False, **operation_config):
        """Reset supervisor.

        Allows a caller to reset the twin module using its supervisor
        identity identifier.

        :param supervisor_id: supervisor identifier
        :type supervisor_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reset_supervisor.metadata['url']
        path_format_arguments = {
            'supervisorId': self._serialize.url("supervisor_id", supervisor_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    reset_supervisor.metadata = {'url': '/v2/supervisors/{supervisorId}/reset'}

    def get_list_of_supervisors(
            self, only_server_state=None, continuation_token=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get list of supervisors.

        Get all registered supervisors and therefore twin modules in paged
        form.
        The returned model can contain a continuation token if more results are
        available.
        Call this operation again using the token to retrieve more results.

        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if available
        :type only_server_state: bool
        :param continuation_token: Optional Continuation token
        :type continuation_token: str
        :param page_size: Optional number of results to return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SupervisorListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.SupervisorListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_list_of_supervisors.metadata['url']

        # Construct parameters
        query_parameters = {}
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')
        if continuation_token is not None:
            query_parameters['continuationToken'] = self._serialize.query("continuation_token", continuation_token, 'str')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SupervisorListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_list_of_supervisors.metadata = {'url': '/v2/supervisors'}

    def get_filtered_list_of_supervisors(
            self, site_id=None, discovery=None, connected=None, only_server_state=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Get filtered list of supervisors.

        Get a list of supervisors filtered using the specified query
        parameters.
        The returned model can contain a continuation token if more results are
        available.
        Call the GetListOfSupervisors operation using the token to retrieve
        more results.

        :param site_id: Site of the supervisor
        :type site_id: str
        :param discovery: Discovery mode of supervisor. Possible values
         include: 'Off', 'Local', 'Network', 'Fast', 'Scan'
        :type discovery: str
        :param connected: Included connected or disconnected
        :type connected: bool
        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if
         available
        :type only_server_state: bool
        :param page_size: Number of results to return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SupervisorListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.SupervisorListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_filtered_list_of_supervisors.metadata['url']

        # Construct parameters
        query_parameters = {}
        if site_id is not None:
            query_parameters['SiteId'] = self._serialize.query("site_id", site_id, 'str')
        if discovery is not None:
            query_parameters['Discovery'] = self._serialize.query("discovery", discovery, 'str')
        if connected is not None:
            query_parameters['Connected'] = self._serialize.query("connected", connected, 'bool')
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SupervisorListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_filtered_list_of_supervisors.metadata = {'url': '/v2/supervisors/query'}

    def query_supervisors(
            self, query, only_server_state=None, page_size=None, custom_headers=None, raw=False, **operation_config):
        """Query supervisors.

        Get all supervisors that match a specified query.
        The returned model can contain a continuation token if more results are
        available.
        Call the GetListOfSupervisors operation using the token to retrieve
        more results.

        :param query: Supervisors query model
        :type query: ~azure-iiot-opc-registry.models.SupervisorQueryApiModel
        :param only_server_state: Whether to include only server
         state, or display current client state of the endpoint if
         available
        :type only_server_state: bool
        :param page_size: Number of results to return
        :type page_size: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: SupervisorListApiModel or ClientRawResponse if raw=true
        :rtype: ~azure-iiot-opc-registry.models.SupervisorListApiModel or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.query_supervisors.metadata['url']

        # Construct parameters
        query_parameters = {}
        if only_server_state is not None:
            query_parameters['onlyServerState'] = self._serialize.query("only_server_state", only_server_state, 'bool')
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(query, 'SupervisorQueryApiModel')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SupervisorListApiModel', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    query_supervisors.metadata = {'url': '/v2/supervisors/query'}
