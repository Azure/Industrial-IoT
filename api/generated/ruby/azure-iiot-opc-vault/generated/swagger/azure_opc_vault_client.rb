# encoding: utf-8
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module azure.iiot.opc.vault
  #
  # A service client - single point of access to the REST API.
  #
  class AzureOpcVaultClient < MsRest::ServiceClient
    include MsRest::Serialization

    # @return [String] the base URI of the service.
    attr_accessor :base_url

    # @return Subscription credentials which uniquely identify client
    # subscription.
    attr_accessor :credentials

    #
    # Creates initializes a new instance of the AzureOpcVaultClient class.
    # @param credentials [MsRest::ServiceClientCredentials] credentials to authorize HTTP requests made by the service client.
    # @param base_url [String] the base URI of the service.
    # @param options [Array] filters to be applied to the HTTP requests.
    #
    def initialize(credentials = nil, base_url = nil, options = nil)
      super(credentials, options)
      @base_url = base_url || 'http://localhost'

      fail ArgumentError, 'invalid type of credentials input parameter' unless credentials.is_a?(MsRest::ServiceClientCredentials) unless credentials.nil?
      @credentials = credentials

      add_telemetry
    end

    #
    # Makes a request and returns the body of the response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Hash{String=>String}] containing the body of the response.
    # Example:
    #
    #  request_content = "{'location':'westus','tags':{'tag1':'val1','tag2':'val2'}}"
    #  path = "/path"
    #  options = {
    #    body: request_content,
    #    query_params: {'api-version' => '2016-02-01'}
    #  }
    #  result = @client.make_request(:put, path, options)
    #
    def make_request(method, path, options = {})
      result = make_request_with_http_info(method, path, options)
      result.body unless result.nil?
    end

    #
    # Makes a request and returns the operation response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [MsRest::HttpOperationResponse] Operation response containing the request, response and status.
    #
    def make_request_with_http_info(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.body = result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
      result
    end

    #
    # Makes a request asynchronously.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def make_request_async(method, path, options = {})
      fail ArgumentError, 'method is nil' if method.nil?
      fail ArgumentError, 'path is nil' if path.nil?

      request_url = options[:base_url] || @base_url
      if(!options[:headers].nil? && !options[:headers]['Content-Type'].nil?)
        @request_headers['Content-Type'] = options[:headers]['Content-Type']
      end

      request_headers = @request_headers
      options.merge!({headers: request_headers.merge(options[:headers] || {})})
      options.merge!({credentials: @credentials}) unless @credentials.nil?

      super(request_url, method, path, options)
    end

    #
    # Get Issuer CA Certificate chain.
    #
    # @param serial_number [String] the serial number of the
    # Issuer CA Certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [X509CertificateChainApiModel] operation results.
    #
    def get_issuer_certificate_chain(serial_number, custom_headers:nil)
      response = get_issuer_certificate_chain_async(serial_number, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get Issuer CA Certificate chain.
    #
    # @param serial_number [String] the serial number of the
    # Issuer CA Certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_issuer_certificate_chain_with_http_info(serial_number, custom_headers:nil)
      get_issuer_certificate_chain_async(serial_number, custom_headers:custom_headers).value!
    end

    #
    # Get Issuer CA Certificate chain.
    #
    # @param serial_number [String] the serial number of the
    # Issuer CA Certificate
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_issuer_certificate_chain_async(serial_number, custom_headers:nil)
      fail ArgumentError, 'serial_number is nil' if serial_number.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/certificates/{serialNumber}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'serialNumber' => serial_number},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::X509CertificateChainApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get Issuer CA CRL chain.
    #
    # @param serial_number [String] the serial number of the Issuer
    # CA Certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [X509CrlChainApiModel] operation results.
    #
    def get_issuer_crl_chain(serial_number, custom_headers:nil)
      response = get_issuer_crl_chain_async(serial_number, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get Issuer CA CRL chain.
    #
    # @param serial_number [String] the serial number of the Issuer
    # CA Certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_issuer_crl_chain_with_http_info(serial_number, custom_headers:nil)
      get_issuer_crl_chain_async(serial_number, custom_headers:custom_headers).value!
    end

    #
    # Get Issuer CA CRL chain.
    #
    # @param serial_number [String] the serial number of the Issuer
    # CA Certificate
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_issuer_crl_chain_async(serial_number, custom_headers:nil)
      fail ArgumentError, 'serial_number is nil' if serial_number.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/certificates/{serialNumber}/crl'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'serialNumber' => serial_number},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::X509CrlChainApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get Issuer Certificate for Authority Information
    # Access endpoint.
    #
    # @param serial_number [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_issuer_certificate_chain1(serial_number, custom_headers:nil)
      response = get_issuer_certificate_chain1_async(serial_number, custom_headers:custom_headers).value!
      nil
    end

    #
    # Get Issuer Certificate for Authority Information
    # Access endpoint.
    #
    # @param serial_number [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_issuer_certificate_chain1_with_http_info(serial_number, custom_headers:nil)
      get_issuer_certificate_chain1_async(serial_number, custom_headers:custom_headers).value!
    end

    #
    # Get Issuer Certificate for Authority Information
    # Access endpoint.
    #
    # @param serial_number [String]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_issuer_certificate_chain1_async(serial_number, custom_headers:nil)
      fail ArgumentError, 'serial_number is nil' if serial_number.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/issuer/{serialNumber}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'serialNumber' => serial_number},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get Issuer CRL in CRL Distribution Endpoint.
    #
    # @param serial_number [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_issuer_crl_chain1(serial_number, custom_headers:nil)
      response = get_issuer_crl_chain1_async(serial_number, custom_headers:custom_headers).value!
      nil
    end

    #
    # Get Issuer CRL in CRL Distribution Endpoint.
    #
    # @param serial_number [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_issuer_crl_chain1_with_http_info(serial_number, custom_headers:nil)
      get_issuer_crl_chain1_async(serial_number, custom_headers:custom_headers).value!
    end

    #
    # Get Issuer CRL in CRL Distribution Endpoint.
    #
    # @param serial_number [String]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_issuer_crl_chain1_async(serial_number, custom_headers:nil)
      fail ArgumentError, 'serial_number is nil' if serial_number.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/crl/{serialNumber}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'serialNumber' => serial_number},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Create a certificate request with a certificate signing request (CSR).
    #
    # The request is in the 'New' state after this call.
    # Requires Writer or Manager role.
    #
    # @param signing_request [StartSigningRequestApiModel] The signing request
    # parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StartSigningRequestResponseApiModel] operation results.
    #
    def start_signing_request(signing_request, custom_headers:nil)
      response = start_signing_request_async(signing_request, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create a certificate request with a certificate signing request (CSR).
    #
    # The request is in the 'New' state after this call.
    # Requires Writer or Manager role.
    #
    # @param signing_request [StartSigningRequestApiModel] The signing request
    # parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def start_signing_request_with_http_info(signing_request, custom_headers:nil)
      start_signing_request_async(signing_request, custom_headers:custom_headers).value!
    end

    #
    # Create a certificate request with a certificate signing request (CSR).
    #
    # The request is in the 'New' state after this call.
    # Requires Writer or Manager role.
    #
    # @param signing_request [StartSigningRequestApiModel] The signing request
    # parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def start_signing_request_async(signing_request, custom_headers:nil)
      fail ArgumentError, 'signing_request is nil' if signing_request.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json-patch+json; charset=utf-8'

      # Serialize Request
      request_mapper = azure.iiot.opc.vault::Models::StartSigningRequestApiModel.mapper()
      request_content = self.serialize(request_mapper,  signing_request)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v2/requests/sign'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::StartSigningRequestResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Fetch signing request results.
    #
    # Can be called in any state.
    # After a successful fetch in 'Completed' state, the request is
    # moved into 'Accepted' state.
    # Requires Writer role.
    #
    # @param request_id [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FinishSigningRequestResponseApiModel] operation results.
    #
    def finish_signing_request(request_id, custom_headers:nil)
      response = finish_signing_request_async(request_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Fetch signing request results.
    #
    # Can be called in any state.
    # After a successful fetch in 'Completed' state, the request is
    # moved into 'Accepted' state.
    # Requires Writer role.
    #
    # @param request_id [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def finish_signing_request_with_http_info(request_id, custom_headers:nil)
      finish_signing_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Fetch signing request results.
    #
    # Can be called in any state.
    # After a successful fetch in 'Completed' state, the request is
    # moved into 'Accepted' state.
    # Requires Writer role.
    #
    # @param request_id [String]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def finish_signing_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/sign/{requestId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::FinishSigningRequestResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create a certificate request with a new key pair.
    #
    # The request is in the 'New' state after this call.
    # Requires Writer or Manager role.
    #
    # @param new_key_pair_request [StartNewKeyPairRequestApiModel] The new key pair
    # request parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StartNewKeyPairRequestResponseApiModel] operation results.
    #
    def start_new_key_pair_request(new_key_pair_request, custom_headers:nil)
      response = start_new_key_pair_request_async(new_key_pair_request, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create a certificate request with a new key pair.
    #
    # The request is in the 'New' state after this call.
    # Requires Writer or Manager role.
    #
    # @param new_key_pair_request [StartNewKeyPairRequestApiModel] The new key pair
    # request parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def start_new_key_pair_request_with_http_info(new_key_pair_request, custom_headers:nil)
      start_new_key_pair_request_async(new_key_pair_request, custom_headers:custom_headers).value!
    end

    #
    # Create a certificate request with a new key pair.
    #
    # The request is in the 'New' state after this call.
    # Requires Writer or Manager role.
    #
    # @param new_key_pair_request [StartNewKeyPairRequestApiModel] The new key pair
    # request parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def start_new_key_pair_request_async(new_key_pair_request, custom_headers:nil)
      fail ArgumentError, 'new_key_pair_request is nil' if new_key_pair_request.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json-patch+json; charset=utf-8'

      # Serialize Request
      request_mapper = azure.iiot.opc.vault::Models::StartNewKeyPairRequestApiModel.mapper()
      request_content = self.serialize(request_mapper,  new_key_pair_request)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v2/requests/keypair'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::StartNewKeyPairRequestResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Fetch certificate request result.
    #
    # Can be called in any state.
    # Fetches private key in 'Completed' state.
    # After a successful fetch in 'Completed' state, the request is
    # moved into 'Accepted' state.
    # Requires Writer role.
    #
    # @param request_id [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FinishNewKeyPairRequestResponseApiModel] operation results.
    #
    def finish_new_key_pair_request(request_id, custom_headers:nil)
      response = finish_new_key_pair_request_async(request_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Fetch certificate request result.
    #
    # Can be called in any state.
    # Fetches private key in 'Completed' state.
    # After a successful fetch in 'Completed' state, the request is
    # moved into 'Accepted' state.
    # Requires Writer role.
    #
    # @param request_id [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def finish_new_key_pair_request_with_http_info(request_id, custom_headers:nil)
      finish_new_key_pair_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Fetch certificate request result.
    #
    # Can be called in any state.
    # Fetches private key in 'Completed' state.
    # After a successful fetch in 'Completed' state, the request is
    # moved into 'Accepted' state.
    # Requires Writer role.
    #
    # @param request_id [String]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def finish_new_key_pair_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/keypair/{requestId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::FinishNewKeyPairRequestResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Approve the certificate request.
    #
    # Validates the request with the application database.
    # - If Approved:
    # - New Key Pair request: Creates the new key pair
    # in the requested format, signs the certificate and stores the
    # private key for later securely in KeyVault.
    # - Cert Signing Request: Creates and signs the certificate.
    # Deletes the CSR from the database.
    # Stores the signed certificate for later use in the Database.
    # The request is in the 'Approved' or 'Rejected' state after this call.
    # Requires Approver role.
    # Approver needs signing rights in KeyVault.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def approve_request(request_id, custom_headers:nil)
      response = approve_request_async(request_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Approve the certificate request.
    #
    # Validates the request with the application database.
    # - If Approved:
    # - New Key Pair request: Creates the new key pair
    # in the requested format, signs the certificate and stores the
    # private key for later securely in KeyVault.
    # - Cert Signing Request: Creates and signs the certificate.
    # Deletes the CSR from the database.
    # Stores the signed certificate for later use in the Database.
    # The request is in the 'Approved' or 'Rejected' state after this call.
    # Requires Approver role.
    # Approver needs signing rights in KeyVault.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def approve_request_with_http_info(request_id, custom_headers:nil)
      approve_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Approve the certificate request.
    #
    # Validates the request with the application database.
    # - If Approved:
    # - New Key Pair request: Creates the new key pair
    # in the requested format, signs the certificate and stores the
    # private key for later securely in KeyVault.
    # - Cert Signing Request: Creates and signs the certificate.
    # Deletes the CSR from the database.
    # Stores the signed certificate for later use in the Database.
    # The request is in the 'Approved' or 'Rejected' state after this call.
    # Requires Approver role.
    # Approver needs signing rights in KeyVault.
    #
    # @param request_id [String] The certificate request id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def approve_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/{requestId}/approve'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Reject the certificate request.
    #
    # The request is in the 'Rejected' state after this call.
    # Requires Approver role.
    # Approver needs signing rights in KeyVault.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def reject_request(request_id, custom_headers:nil)
      response = reject_request_async(request_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Reject the certificate request.
    #
    # The request is in the 'Rejected' state after this call.
    # Requires Approver role.
    # Approver needs signing rights in KeyVault.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def reject_request_with_http_info(request_id, custom_headers:nil)
      reject_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Reject the certificate request.
    #
    # The request is in the 'Rejected' state after this call.
    # Requires Approver role.
    # Approver needs signing rights in KeyVault.
    #
    # @param request_id [String] The certificate request id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def reject_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/{requestId}/reject'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Cancel request
    #
    # The request is in the 'Accepted' state after this call.
    # Requires Writer role.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def accept_request(request_id, custom_headers:nil)
      response = accept_request_async(request_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Cancel request
    #
    # The request is in the 'Accepted' state after this call.
    # Requires Writer role.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def accept_request_with_http_info(request_id, custom_headers:nil)
      accept_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Cancel request
    #
    # The request is in the 'Accepted' state after this call.
    # Requires Writer role.
    #
    # @param request_id [String] The certificate request id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def accept_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/{requestId}/accept'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get a specific certificate request.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateRequestRecordApiModel] operation results.
    #
    def get_request(request_id, custom_headers:nil)
      response = get_request_async(request_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get a specific certificate request.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_request_with_http_info(request_id, custom_headers:nil)
      get_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Get a specific certificate request.
    #
    # @param request_id [String] The certificate request id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/{requestId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::CertificateRequestRecordApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete request. Physically delete the request.
    #
    # By purging the request it is actually physically deleted from the
    # database, including the public key and other information.
    # Requires Manager role.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_request(request_id, custom_headers:nil)
      response = delete_request_async(request_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete request. Physically delete the request.
    #
    # By purging the request it is actually physically deleted from the
    # database, including the public key and other information.
    # Requires Manager role.
    #
    # @param request_id [String] The certificate request id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_request_with_http_info(request_id, custom_headers:nil)
      delete_request_async(request_id, custom_headers:custom_headers).value!
    end

    #
    # Delete request. Physically delete the request.
    #
    # By purging the request it is actually physically deleted from the
    # database, including the public key and other information.
    # Requires Manager role.
    #
    # @param request_id [String] The certificate request id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_request_async(request_id, custom_headers:nil)
      fail ArgumentError, 'request_id is nil' if request_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests/{requestId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'requestId' => request_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Query for certificate requests.
    #
    # Get all certificate requests in paged form.
    # The returned model can contain a link to the next page if more results are
    # available.  Use ListRequests to continue.
    #
    # @param query [CertificateRequestQueryRequestApiModel] optional, query filter
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateRequestQueryResponseApiModel] operation results.
    #
    def query_requests(query:nil, page_size:nil, custom_headers:nil)
      response = query_requests_async(query:query, page_size:page_size, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Query for certificate requests.
    #
    # Get all certificate requests in paged form.
    # The returned model can contain a link to the next page if more results are
    # available.  Use ListRequests to continue.
    #
    # @param query [CertificateRequestQueryRequestApiModel] optional, query filter
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def query_requests_with_http_info(query:nil, page_size:nil, custom_headers:nil)
      query_requests_async(query:query, page_size:page_size, custom_headers:custom_headers).value!
    end

    #
    # Query for certificate requests.
    #
    # Get all certificate requests in paged form.
    # The returned model can contain a link to the next page if more results are
    # available.  Use ListRequests to continue.
    #
    # @param query [CertificateRequestQueryRequestApiModel] optional, query filter
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def query_requests_async(query:nil, page_size:nil, custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json-patch+json; charset=utf-8'

      # Serialize Request
      request_mapper = azure.iiot.opc.vault::Models::CertificateRequestQueryRequestApiModel.mapper()
      request_content = self.serialize(request_mapper,  query)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v2/requests/query'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'pageSize' => page_size},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::CertificateRequestQueryResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists certificate requests.
    #
    # Get all certificate requests in paged form or continue a current listing or
    # query.
    # The returned model can contain a link to the next page if more results are
    # available.
    #
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateRequestQueryResponseApiModel] operation results.
    #
    def list_requests(next_page_link:nil, page_size:nil, custom_headers:nil)
      response = list_requests_async(next_page_link:next_page_link, page_size:page_size, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists certificate requests.
    #
    # Get all certificate requests in paged form or continue a current listing or
    # query.
    # The returned model can contain a link to the next page if more results are
    # available.
    #
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_requests_with_http_info(next_page_link:nil, page_size:nil, custom_headers:nil)
      list_requests_async(next_page_link:next_page_link, page_size:page_size, custom_headers:custom_headers).value!
    end

    #
    # Lists certificate requests.
    #
    # Get all certificate requests in paged form or continue a current listing or
    # query.
    # The returned model can contain a link to the next page if more results are
    # available.
    #
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_requests_async(next_page_link:nil, page_size:nil, custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/requests'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'nextPageLink' => next_page_link,'pageSize' => page_size},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::CertificateRequestQueryResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get the status.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StatusResponseApiModel] operation results.
    #
    def get_status(custom_headers:nil)
      response = get_status_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get the status.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_status_with_http_info(custom_headers:nil)
      get_status_async(custom_headers:custom_headers).value!
    end

    #
    # Get the status.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_status_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/status'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::StatusResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get information about all groups.
    #
    # A trust group has a root certificate which issues certificates
    # to entities.  Entities can be part of a trust group and thus
    # trust the root certificate and all entities that the root has
    # issued certificates for.
    #
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TrustGroupRegistrationListApiModel] operation results.
    #
    def list_groups(next_page_link:nil, page_size:nil, custom_headers:nil)
      response = list_groups_async(next_page_link:next_page_link, page_size:page_size, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get information about all groups.
    #
    # A trust group has a root certificate which issues certificates
    # to entities.  Entities can be part of a trust group and thus
    # trust the root certificate and all entities that the root has
    # issued certificates for.
    #
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_groups_with_http_info(next_page_link:nil, page_size:nil, custom_headers:nil)
      list_groups_async(next_page_link:next_page_link, page_size:page_size, custom_headers:custom_headers).value!
    end

    #
    # Get information about all groups.
    #
    # A trust group has a root certificate which issues certificates
    # to entities.  Entities can be part of a trust group and thus
    # trust the root certificate and all entities that the root has
    # issued certificates for.
    #
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_groups_async(next_page_link:nil, page_size:nil, custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'nextPageLink' => next_page_link,'pageSize' => page_size},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::TrustGroupRegistrationListApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create new sub-group of an existing group.
    #
    # Requires manager role.
    #
    # @param request [TrustGroupRegistrationRequestApiModel] The create request
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TrustGroupRegistrationResponseApiModel] operation results.
    #
    def create_group(request, custom_headers:nil)
      response = create_group_async(request, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create new sub-group of an existing group.
    #
    # Requires manager role.
    #
    # @param request [TrustGroupRegistrationRequestApiModel] The create request
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_group_with_http_info(request, custom_headers:nil)
      create_group_async(request, custom_headers:custom_headers).value!
    end

    #
    # Create new sub-group of an existing group.
    #
    # Requires manager role.
    #
    # @param request [TrustGroupRegistrationRequestApiModel] The create request
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_group_async(request, custom_headers:nil)
      fail ArgumentError, 'request is nil' if request.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json-patch+json; charset=utf-8'

      # Serialize Request
      request_mapper = azure.iiot.opc.vault::Models::TrustGroupRegistrationRequestApiModel.mapper()
      request_content = self.serialize(request_mapper,  request)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v2/groups'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::TrustGroupRegistrationResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get group information.
    #
    # A trust group has a root certificate which issues certificates
    # to entities.  Entities can be part of a trust group and thus
    # trust the root certificate and all entities that the root has
    # issued certificates for.
    #
    # @param group_id [String] The group id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TrustGroupRegistrationApiModel] operation results.
    #
    def get_group(group_id, custom_headers:nil)
      response = get_group_async(group_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get group information.
    #
    # A trust group has a root certificate which issues certificates
    # to entities.  Entities can be part of a trust group and thus
    # trust the root certificate and all entities that the root has
    # issued certificates for.
    #
    # @param group_id [String] The group id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_group_with_http_info(group_id, custom_headers:nil)
      get_group_async(group_id, custom_headers:custom_headers).value!
    end

    #
    # Get group information.
    #
    # A trust group has a root certificate which issues certificates
    # to entities.  Entities can be part of a trust group and thus
    # trust the root certificate and all entities that the root has
    # issued certificates for.
    #
    # @param group_id [String] The group id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_group_async(group_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/groups/{groupId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupId' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::TrustGroupRegistrationApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Update group registration.
    #
    # Use this function with care and only if you are aware of
    # the security implications.
    # Requires manager role.
    #
    # @param group_id [String] The group id
    # @param request [TrustGroupUpdateRequestApiModel] The group configuration
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def update_group(group_id, request, custom_headers:nil)
      response = update_group_async(group_id, request, custom_headers:custom_headers).value!
      nil
    end

    #
    # Update group registration.
    #
    # Use this function with care and only if you are aware of
    # the security implications.
    # Requires manager role.
    #
    # @param group_id [String] The group id
    # @param request [TrustGroupUpdateRequestApiModel] The group configuration
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_group_with_http_info(group_id, request, custom_headers:nil)
      update_group_async(group_id, request, custom_headers:custom_headers).value!
    end

    #
    # Update group registration.
    #
    # Use this function with care and only if you are aware of
    # the security implications.
    # Requires manager role.
    #
    # @param group_id [String] The group id
    # @param request [TrustGroupUpdateRequestApiModel] The group configuration
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_group_async(group_id, request, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?
      fail ArgumentError, 'request is nil' if request.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json-patch+json; charset=utf-8'

      # Serialize Request
      request_mapper = azure.iiot.opc.vault::Models::TrustGroupUpdateRequestApiModel.mapper()
      request_content = self.serialize(request_mapper,  request)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v2/groups/{groupId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupId' => group_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Delete a group.
    #
    # After this operation the Issuer CA, CRLs and keys become inaccessible.
    # Use this function with extreme caution.
    # Requires manager role.
    #
    # @param group_id [String] The group id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_group(group_id, custom_headers:nil)
      response = delete_group_async(group_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete a group.
    #
    # After this operation the Issuer CA, CRLs and keys become inaccessible.
    # Use this function with extreme caution.
    # Requires manager role.
    #
    # @param group_id [String] The group id
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_group_with_http_info(group_id, custom_headers:nil)
      delete_group_async(group_id, custom_headers:custom_headers).value!
    end

    #
    # Delete a group.
    #
    # After this operation the Issuer CA, CRLs and keys become inaccessible.
    # Use this function with extreme caution.
    # Requires manager role.
    #
    # @param group_id [String] The group id
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_group_async(group_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/groups/{groupId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupId' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Create new root group.
    #
    # Requires manager role.
    #
    # @param request [TrustGroupRootCreateRequestApiModel] The create request
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TrustGroupRegistrationResponseApiModel] operation results.
    #
    def create_root(request, custom_headers:nil)
      response = create_root_async(request, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create new root group.
    #
    # Requires manager role.
    #
    # @param request [TrustGroupRootCreateRequestApiModel] The create request
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_root_with_http_info(request, custom_headers:nil)
      create_root_async(request, custom_headers:custom_headers).value!
    end

    #
    # Create new root group.
    #
    # Requires manager role.
    #
    # @param request [TrustGroupRootCreateRequestApiModel] The create request
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_root_async(request, custom_headers:nil)
      fail ArgumentError, 'request is nil' if request.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json-patch+json; charset=utf-8'

      # Serialize Request
      request_mapper = azure.iiot.opc.vault::Models::TrustGroupRootCreateRequestApiModel.mapper()
      request_content = self.serialize(request_mapper,  request)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'v2/groups/root'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::TrustGroupRegistrationResponseApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Renew a group CA Certificate.
    #
    # @param group_id [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def renew_issuer_certificate(group_id, custom_headers:nil)
      response = renew_issuer_certificate_async(group_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Renew a group CA Certificate.
    #
    # @param group_id [String]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def renew_issuer_certificate_with_http_info(group_id, custom_headers:nil)
      renew_issuer_certificate_async(group_id, custom_headers:custom_headers).value!
    end

    #
    # Renew a group CA Certificate.
    #
    # @param group_id [String]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def renew_issuer_certificate_async(group_id, custom_headers:nil)
      fail ArgumentError, 'group_id is nil' if group_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/groups/{groupId}/renew'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'groupId' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Add trust relationship
    #
    # Define trust between two entities.  The entities are identifiers
    # of application, groups, or endpoints.
    #
    # @param entity_id [String] The entity identifier, e.g. group, etc.
    # @param trusted_entity_id [String] The trusted entity identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def add_trust_relationship(entity_id, trusted_entity_id, custom_headers:nil)
      response = add_trust_relationship_async(entity_id, trusted_entity_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Add trust relationship
    #
    # Define trust between two entities.  The entities are identifiers
    # of application, groups, or endpoints.
    #
    # @param entity_id [String] The entity identifier, e.g. group, etc.
    # @param trusted_entity_id [String] The trusted entity identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def add_trust_relationship_with_http_info(entity_id, trusted_entity_id, custom_headers:nil)
      add_trust_relationship_async(entity_id, trusted_entity_id, custom_headers:custom_headers).value!
    end

    #
    # Add trust relationship
    #
    # Define trust between two entities.  The entities are identifiers
    # of application, groups, or endpoints.
    #
    # @param entity_id [String] The entity identifier, e.g. group, etc.
    # @param trusted_entity_id [String] The trusted entity identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def add_trust_relationship_async(entity_id, trusted_entity_id, custom_headers:nil)
      fail ArgumentError, 'entity_id is nil' if entity_id.nil?
      fail ArgumentError, 'trusted_entity_id is nil' if trusted_entity_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/trustlists/{entityId}/{trustedEntityId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'entityId' => entity_id,'trustedEntityId' => trusted_entity_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # List trusted certificates
    #
    # Returns all certificates the entity should trust based on the
    # applied trust configuration.
    #
    # @param entity_id [String]
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [X509CertificateListApiModel] operation results.
    #
    def list_trusted_certificates(entity_id, next_page_link:nil, page_size:nil, custom_headers:nil)
      response = list_trusted_certificates_async(entity_id, next_page_link:next_page_link, page_size:page_size, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List trusted certificates
    #
    # Returns all certificates the entity should trust based on the
    # applied trust configuration.
    #
    # @param entity_id [String]
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_trusted_certificates_with_http_info(entity_id, next_page_link:nil, page_size:nil, custom_headers:nil)
      list_trusted_certificates_async(entity_id, next_page_link:next_page_link, page_size:page_size, custom_headers:custom_headers).value!
    end

    #
    # List trusted certificates
    #
    # Returns all certificates the entity should trust based on the
    # applied trust configuration.
    #
    # @param entity_id [String]
    # @param next_page_link [String] optional, link to next page
    # @param page_size [Integer] optional, the maximum number of result per page
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_trusted_certificates_async(entity_id, next_page_link:nil, page_size:nil, custom_headers:nil)
      fail ArgumentError, 'entity_id is nil' if entity_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/trustlists/{entityId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'entityId' => entity_id},
          query_params: {'nextPageLink' => next_page_link,'pageSize' => page_size},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = azure.iiot.opc.vault::Models::X509CertificateListApiModel.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Remove a trust relationship
    #
    # Removes trust between two entities.  The entities are identifiers
    # of application, groups, or endpoints.
    #
    # @param entity_id [String] The entity identifier, e.g. group, etc.
    # @param untrusted_entity_id [String] The trusted entity identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def remove_trust_relationship(entity_id, untrusted_entity_id, custom_headers:nil)
      response = remove_trust_relationship_async(entity_id, untrusted_entity_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Remove a trust relationship
    #
    # Removes trust between two entities.  The entities are identifiers
    # of application, groups, or endpoints.
    #
    # @param entity_id [String] The entity identifier, e.g. group, etc.
    # @param untrusted_entity_id [String] The trusted entity identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def remove_trust_relationship_with_http_info(entity_id, untrusted_entity_id, custom_headers:nil)
      remove_trust_relationship_async(entity_id, untrusted_entity_id, custom_headers:custom_headers).value!
    end

    #
    # Remove a trust relationship
    #
    # Removes trust between two entities.  The entities are identifiers
    # of application, groups, or endpoints.
    #
    # @param entity_id [String] The entity identifier, e.g. group, etc.
    # @param untrusted_entity_id [String] The trusted entity identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def remove_trust_relationship_async(entity_id, untrusted_entity_id, custom_headers:nil)
      fail ArgumentError, 'entity_id is nil' if entity_id.nil?
      fail ArgumentError, 'untrusted_entity_id is nil' if untrusted_entity_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'v2/trustlists/{entityId}/{untrustedEntityId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'entityId' => entity_id,'untrustedEntityId' => untrusted_entity_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end


    private
    #
    # Adds telemetry information.
    #
    def add_telemetry
        sdk_information = 'swagger'
        add_user_agent_information(sdk_information)
    end
  end
end
