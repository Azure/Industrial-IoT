/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.iiot.opc.vault.implementation;

import com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.iiot.opc.vault.models.CertificateRequestQueryRequestApiModel;
import com.microsoft.azure.iiot.opc.vault.models.CertificateRequestQueryResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.CertificateRequestRecordApiModel;
import com.microsoft.azure.iiot.opc.vault.models.FinishNewKeyPairRequestResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.FinishSigningRequestResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.StartNewKeyPairRequestApiModel;
import com.microsoft.azure.iiot.opc.vault.models.StartNewKeyPairRequestResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.StartSigningRequestApiModel;
import com.microsoft.azure.iiot.opc.vault.models.StartSigningRequestResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.StatusResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.TrustGroupRegistrationApiModel;
import com.microsoft.azure.iiot.opc.vault.models.TrustGroupRegistrationListApiModel;
import com.microsoft.azure.iiot.opc.vault.models.TrustGroupRegistrationRequestApiModel;
import com.microsoft.azure.iiot.opc.vault.models.TrustGroupRegistrationResponseApiModel;
import com.microsoft.azure.iiot.opc.vault.models.TrustGroupRootCreateRequestApiModel;
import com.microsoft.azure.iiot.opc.vault.models.TrustGroupUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.vault.models.X509CertificateChainApiModel;
import com.microsoft.azure.iiot.opc.vault.models.X509CertificateListApiModel;
import com.microsoft.azure.iiot.opc.vault.models.X509CrlChainApiModel;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AzureOpcVaultClient class.
 */
public class AzureOpcVaultClientImpl extends ServiceClient implements AzureOpcVaultClient {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AzureOpcVaultClientService service;

    /**
     * Initializes an instance of AzureOpcVaultClient client.
     */
    public AzureOpcVaultClientImpl() {
        this("http://localhost");
    }

    /**
     * Initializes an instance of AzureOpcVaultClient client.
     *
     * @param baseUrl the base URL of the host
     */
    public AzureOpcVaultClientImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcVaultClient client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcVaultClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://localhost", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcVaultClient client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcVaultClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcVaultClient client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AzureOpcVaultClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AzureOpcVaultClientService.class);
    }

    /**
     * The interface defining all the services for AzureOpcVaultClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AzureOpcVaultClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getIssuerCertificateChain" })
        @GET("v2/certificates/{serialNumber}")
        Observable<Response<ResponseBody>> getIssuerCertificateChain(@Path("serialNumber") String serialNumber);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getIssuerCrlChain" })
        @GET("v2/certificates/{serialNumber}/crl")
        Observable<Response<ResponseBody>> getIssuerCrlChain(@Path("serialNumber") String serialNumber);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getIssuerCertificateChain1" })
        @GET("v2/issuer/{serialNumber}")
        Observable<Response<ResponseBody>> getIssuerCertificateChain1(@Path("serialNumber") String serialNumber);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getIssuerCrlChain1" })
        @GET("v2/crl/{serialNumber}")
        Observable<Response<ResponseBody>> getIssuerCrlChain1(@Path("serialNumber") String serialNumber);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient startSigningRequest" })
        @PUT("v2/requests/sign")
        Observable<Response<ResponseBody>> startSigningRequest(@Body StartSigningRequestApiModel signingRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient finishSigningRequest" })
        @GET("v2/requests/sign/{requestId}")
        Observable<Response<ResponseBody>> finishSigningRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient startNewKeyPairRequest" })
        @PUT("v2/requests/keypair")
        Observable<Response<ResponseBody>> startNewKeyPairRequest(@Body StartNewKeyPairRequestApiModel newKeyPairRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient finishNewKeyPairRequest" })
        @GET("v2/requests/keypair/{requestId}")
        Observable<Response<ResponseBody>> finishNewKeyPairRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient approveRequest" })
        @POST("v2/requests/{requestId}/approve")
        Observable<Response<ResponseBody>> approveRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient rejectRequest" })
        @POST("v2/requests/{requestId}/reject")
        Observable<Response<ResponseBody>> rejectRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient acceptRequest" })
        @POST("v2/requests/{requestId}/accept")
        Observable<Response<ResponseBody>> acceptRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getRequest" })
        @GET("v2/requests/{requestId}")
        Observable<Response<ResponseBody>> getRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient deleteRequest" })
        @HTTP(path = "v2/requests/{requestId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRequest(@Path("requestId") String requestId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient queryRequests" })
        @POST("v2/requests/query")
        Observable<Response<ResponseBody>> queryRequests(@Body CertificateRequestQueryRequestApiModel query, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient listRequests" })
        @GET("v2/requests")
        Observable<Response<ResponseBody>> listRequests(@Query("nextPageLink") String nextPageLink, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getStatus" })
        @GET("v2/status")
        Observable<Response<ResponseBody>> getStatus();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient listGroups" })
        @GET("v2/groups")
        Observable<Response<ResponseBody>> listGroups(@Query("nextPageLink") String nextPageLink, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient createGroup" })
        @PUT("v2/groups")
        Observable<Response<ResponseBody>> createGroup(@Body TrustGroupRegistrationRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient getGroup" })
        @GET("v2/groups/{groupId}")
        Observable<Response<ResponseBody>> getGroup(@Path("groupId") String groupId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient updateGroup" })
        @POST("v2/groups/{groupId}")
        Observable<Response<ResponseBody>> updateGroup(@Path("groupId") String groupId, @Body TrustGroupUpdateRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient deleteGroup" })
        @HTTP(path = "v2/groups/{groupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGroup(@Path("groupId") String groupId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient createRoot" })
        @PUT("v2/groups/root")
        Observable<Response<ResponseBody>> createRoot(@Body TrustGroupRootCreateRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient renewIssuerCertificate" })
        @POST("v2/groups/{groupId}/renew")
        Observable<Response<ResponseBody>> renewIssuerCertificate(@Path("groupId") String groupId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient addTrustRelationship" })
        @PUT("v2/trustlists/{entityId}/{trustedEntityId}")
        Observable<Response<ResponseBody>> addTrustRelationship(@Path("entityId") String entityId, @Path("trustedEntityId") String trustedEntityId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient listTrustedCertificates" })
        @GET("v2/trustlists/{entityId}")
        Observable<Response<ResponseBody>> listTrustedCertificates(@Path("entityId") String entityId, @Query("nextPageLink") String nextPageLink, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.vault.AzureOpcVaultClient removeTrustRelationship" })
        @HTTP(path = "v2/trustlists/{entityId}/{untrustedEntityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> removeTrustRelationship(@Path("entityId") String entityId, @Path("untrustedEntityId") String untrustedEntityId);

    }

    /**
     * Get Issuer CA Certificate chain.
     *
     * @param serialNumber the serial number of the
                 Issuer CA Certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the X509CertificateChainApiModel object if successful.
     */
    public X509CertificateChainApiModel getIssuerCertificateChain(String serialNumber) {
        return getIssuerCertificateChainWithServiceResponseAsync(serialNumber).toBlocking().single().body();
    }

    /**
     * Get Issuer CA Certificate chain.
     *
     * @param serialNumber the serial number of the
                 Issuer CA Certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<X509CertificateChainApiModel> getIssuerCertificateChainAsync(String serialNumber, final ServiceCallback<X509CertificateChainApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getIssuerCertificateChainWithServiceResponseAsync(serialNumber), serviceCallback);
    }

    /**
     * Get Issuer CA Certificate chain.
     *
     * @param serialNumber the serial number of the
                 Issuer CA Certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CertificateChainApiModel object
     */
    public Observable<X509CertificateChainApiModel> getIssuerCertificateChainAsync(String serialNumber) {
        return getIssuerCertificateChainWithServiceResponseAsync(serialNumber).map(new Func1<ServiceResponse<X509CertificateChainApiModel>, X509CertificateChainApiModel>() {
            @Override
            public X509CertificateChainApiModel call(ServiceResponse<X509CertificateChainApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Issuer CA Certificate chain.
     *
     * @param serialNumber the serial number of the
                 Issuer CA Certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CertificateChainApiModel object
     */
    public Observable<ServiceResponse<X509CertificateChainApiModel>> getIssuerCertificateChainWithServiceResponseAsync(String serialNumber) {
        if (serialNumber == null) {
            throw new IllegalArgumentException("Parameter serialNumber is required and cannot be null.");
        }
        return service.getIssuerCertificateChain(serialNumber)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<X509CertificateChainApiModel>>>() {
                @Override
                public Observable<ServiceResponse<X509CertificateChainApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<X509CertificateChainApiModel> clientResponse = getIssuerCertificateChainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<X509CertificateChainApiModel> getIssuerCertificateChainDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<X509CertificateChainApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<X509CertificateChainApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get Issuer CA CRL chain.
     *
     * @param serialNumber the serial number of the Issuer
                 CA Certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the X509CrlChainApiModel object if successful.
     */
    public X509CrlChainApiModel getIssuerCrlChain(String serialNumber) {
        return getIssuerCrlChainWithServiceResponseAsync(serialNumber).toBlocking().single().body();
    }

    /**
     * Get Issuer CA CRL chain.
     *
     * @param serialNumber the serial number of the Issuer
                 CA Certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<X509CrlChainApiModel> getIssuerCrlChainAsync(String serialNumber, final ServiceCallback<X509CrlChainApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getIssuerCrlChainWithServiceResponseAsync(serialNumber), serviceCallback);
    }

    /**
     * Get Issuer CA CRL chain.
     *
     * @param serialNumber the serial number of the Issuer
                 CA Certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CrlChainApiModel object
     */
    public Observable<X509CrlChainApiModel> getIssuerCrlChainAsync(String serialNumber) {
        return getIssuerCrlChainWithServiceResponseAsync(serialNumber).map(new Func1<ServiceResponse<X509CrlChainApiModel>, X509CrlChainApiModel>() {
            @Override
            public X509CrlChainApiModel call(ServiceResponse<X509CrlChainApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Issuer CA CRL chain.
     *
     * @param serialNumber the serial number of the Issuer
                 CA Certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CrlChainApiModel object
     */
    public Observable<ServiceResponse<X509CrlChainApiModel>> getIssuerCrlChainWithServiceResponseAsync(String serialNumber) {
        if (serialNumber == null) {
            throw new IllegalArgumentException("Parameter serialNumber is required and cannot be null.");
        }
        return service.getIssuerCrlChain(serialNumber)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<X509CrlChainApiModel>>>() {
                @Override
                public Observable<ServiceResponse<X509CrlChainApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<X509CrlChainApiModel> clientResponse = getIssuerCrlChainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<X509CrlChainApiModel> getIssuerCrlChainDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<X509CrlChainApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<X509CrlChainApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get Issuer Certificate for Authority Information
     Access endpoint.
     *
     * @param serialNumber the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getIssuerCertificateChain1(String serialNumber) {
        getIssuerCertificateChain1WithServiceResponseAsync(serialNumber).toBlocking().single().body();
    }

    /**
     * Get Issuer Certificate for Authority Information
     Access endpoint.
     *
     * @param serialNumber the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getIssuerCertificateChain1Async(String serialNumber, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(getIssuerCertificateChain1WithServiceResponseAsync(serialNumber), serviceCallback);
    }

    /**
     * Get Issuer Certificate for Authority Information
     Access endpoint.
     *
     * @param serialNumber the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIssuerCertificateChain1Async(String serialNumber) {
        return getIssuerCertificateChain1WithServiceResponseAsync(serialNumber).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Issuer Certificate for Authority Information
     Access endpoint.
     *
     * @param serialNumber the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIssuerCertificateChain1WithServiceResponseAsync(String serialNumber) {
        if (serialNumber == null) {
            throw new IllegalArgumentException("Parameter serialNumber is required and cannot be null.");
        }
        return service.getIssuerCertificateChain1(serialNumber)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIssuerCertificateChain1Delegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIssuerCertificateChain1Delegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get Issuer CRL in CRL Distribution Endpoint.
     *
     * @param serialNumber the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getIssuerCrlChain1(String serialNumber) {
        getIssuerCrlChain1WithServiceResponseAsync(serialNumber).toBlocking().single().body();
    }

    /**
     * Get Issuer CRL in CRL Distribution Endpoint.
     *
     * @param serialNumber the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getIssuerCrlChain1Async(String serialNumber, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(getIssuerCrlChain1WithServiceResponseAsync(serialNumber), serviceCallback);
    }

    /**
     * Get Issuer CRL in CRL Distribution Endpoint.
     *
     * @param serialNumber the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIssuerCrlChain1Async(String serialNumber) {
        return getIssuerCrlChain1WithServiceResponseAsync(serialNumber).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Get Issuer CRL in CRL Distribution Endpoint.
     *
     * @param serialNumber the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIssuerCrlChain1WithServiceResponseAsync(String serialNumber) {
        if (serialNumber == null) {
            throw new IllegalArgumentException("Parameter serialNumber is required and cannot be null.");
        }
        return service.getIssuerCrlChain1(serialNumber)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIssuerCrlChain1Delegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIssuerCrlChain1Delegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Create a certificate request with a certificate signing request (CSR).
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param signingRequest The signing request parameters
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StartSigningRequestResponseApiModel object if successful.
     */
    public StartSigningRequestResponseApiModel startSigningRequest(StartSigningRequestApiModel signingRequest) {
        return startSigningRequestWithServiceResponseAsync(signingRequest).toBlocking().single().body();
    }

    /**
     * Create a certificate request with a certificate signing request (CSR).
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param signingRequest The signing request parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StartSigningRequestResponseApiModel> startSigningRequestAsync(StartSigningRequestApiModel signingRequest, final ServiceCallback<StartSigningRequestResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(startSigningRequestWithServiceResponseAsync(signingRequest), serviceCallback);
    }

    /**
     * Create a certificate request with a certificate signing request (CSR).
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param signingRequest The signing request parameters
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StartSigningRequestResponseApiModel object
     */
    public Observable<StartSigningRequestResponseApiModel> startSigningRequestAsync(StartSigningRequestApiModel signingRequest) {
        return startSigningRequestWithServiceResponseAsync(signingRequest).map(new Func1<ServiceResponse<StartSigningRequestResponseApiModel>, StartSigningRequestResponseApiModel>() {
            @Override
            public StartSigningRequestResponseApiModel call(ServiceResponse<StartSigningRequestResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a certificate request with a certificate signing request (CSR).
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param signingRequest The signing request parameters
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StartSigningRequestResponseApiModel object
     */
    public Observable<ServiceResponse<StartSigningRequestResponseApiModel>> startSigningRequestWithServiceResponseAsync(StartSigningRequestApiModel signingRequest) {
        if (signingRequest == null) {
            throw new IllegalArgumentException("Parameter signingRequest is required and cannot be null.");
        }
        Validator.validate(signingRequest);
        return service.startSigningRequest(signingRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StartSigningRequestResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<StartSigningRequestResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StartSigningRequestResponseApiModel> clientResponse = startSigningRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StartSigningRequestResponseApiModel> startSigningRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<StartSigningRequestResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StartSigningRequestResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Fetch signing request results.
     * Can be called in any state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FinishSigningRequestResponseApiModel object if successful.
     */
    public FinishSigningRequestResponseApiModel finishSigningRequest(String requestId) {
        return finishSigningRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Fetch signing request results.
     * Can be called in any state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FinishSigningRequestResponseApiModel> finishSigningRequestAsync(String requestId, final ServiceCallback<FinishSigningRequestResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(finishSigningRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Fetch signing request results.
     * Can be called in any state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FinishSigningRequestResponseApiModel object
     */
    public Observable<FinishSigningRequestResponseApiModel> finishSigningRequestAsync(String requestId) {
        return finishSigningRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<FinishSigningRequestResponseApiModel>, FinishSigningRequestResponseApiModel>() {
            @Override
            public FinishSigningRequestResponseApiModel call(ServiceResponse<FinishSigningRequestResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Fetch signing request results.
     * Can be called in any state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FinishSigningRequestResponseApiModel object
     */
    public Observable<ServiceResponse<FinishSigningRequestResponseApiModel>> finishSigningRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.finishSigningRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FinishSigningRequestResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<FinishSigningRequestResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FinishSigningRequestResponseApiModel> clientResponse = finishSigningRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FinishSigningRequestResponseApiModel> finishSigningRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<FinishSigningRequestResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<FinishSigningRequestResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Create a certificate request with a new key pair.
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param newKeyPairRequest The new key pair request parameters
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StartNewKeyPairRequestResponseApiModel object if successful.
     */
    public StartNewKeyPairRequestResponseApiModel startNewKeyPairRequest(StartNewKeyPairRequestApiModel newKeyPairRequest) {
        return startNewKeyPairRequestWithServiceResponseAsync(newKeyPairRequest).toBlocking().single().body();
    }

    /**
     * Create a certificate request with a new key pair.
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param newKeyPairRequest The new key pair request parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StartNewKeyPairRequestResponseApiModel> startNewKeyPairRequestAsync(StartNewKeyPairRequestApiModel newKeyPairRequest, final ServiceCallback<StartNewKeyPairRequestResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(startNewKeyPairRequestWithServiceResponseAsync(newKeyPairRequest), serviceCallback);
    }

    /**
     * Create a certificate request with a new key pair.
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param newKeyPairRequest The new key pair request parameters
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StartNewKeyPairRequestResponseApiModel object
     */
    public Observable<StartNewKeyPairRequestResponseApiModel> startNewKeyPairRequestAsync(StartNewKeyPairRequestApiModel newKeyPairRequest) {
        return startNewKeyPairRequestWithServiceResponseAsync(newKeyPairRequest).map(new Func1<ServiceResponse<StartNewKeyPairRequestResponseApiModel>, StartNewKeyPairRequestResponseApiModel>() {
            @Override
            public StartNewKeyPairRequestResponseApiModel call(ServiceResponse<StartNewKeyPairRequestResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a certificate request with a new key pair.
     * The request is in the 'New' state after this call.
     Requires Writer or Manager role.
     *
     * @param newKeyPairRequest The new key pair request parameters
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StartNewKeyPairRequestResponseApiModel object
     */
    public Observable<ServiceResponse<StartNewKeyPairRequestResponseApiModel>> startNewKeyPairRequestWithServiceResponseAsync(StartNewKeyPairRequestApiModel newKeyPairRequest) {
        if (newKeyPairRequest == null) {
            throw new IllegalArgumentException("Parameter newKeyPairRequest is required and cannot be null.");
        }
        Validator.validate(newKeyPairRequest);
        return service.startNewKeyPairRequest(newKeyPairRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StartNewKeyPairRequestResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<StartNewKeyPairRequestResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StartNewKeyPairRequestResponseApiModel> clientResponse = startNewKeyPairRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StartNewKeyPairRequestResponseApiModel> startNewKeyPairRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<StartNewKeyPairRequestResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StartNewKeyPairRequestResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Fetch certificate request result.
     * Can be called in any state.
     Fetches private key in 'Completed' state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FinishNewKeyPairRequestResponseApiModel object if successful.
     */
    public FinishNewKeyPairRequestResponseApiModel finishNewKeyPairRequest(String requestId) {
        return finishNewKeyPairRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Fetch certificate request result.
     * Can be called in any state.
     Fetches private key in 'Completed' state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FinishNewKeyPairRequestResponseApiModel> finishNewKeyPairRequestAsync(String requestId, final ServiceCallback<FinishNewKeyPairRequestResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(finishNewKeyPairRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Fetch certificate request result.
     * Can be called in any state.
     Fetches private key in 'Completed' state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FinishNewKeyPairRequestResponseApiModel object
     */
    public Observable<FinishNewKeyPairRequestResponseApiModel> finishNewKeyPairRequestAsync(String requestId) {
        return finishNewKeyPairRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<FinishNewKeyPairRequestResponseApiModel>, FinishNewKeyPairRequestResponseApiModel>() {
            @Override
            public FinishNewKeyPairRequestResponseApiModel call(ServiceResponse<FinishNewKeyPairRequestResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Fetch certificate request result.
     * Can be called in any state.
     Fetches private key in 'Completed' state.
     After a successful fetch in 'Completed' state, the request is
     moved into 'Accepted' state.
     Requires Writer role.
     *
     * @param requestId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FinishNewKeyPairRequestResponseApiModel object
     */
    public Observable<ServiceResponse<FinishNewKeyPairRequestResponseApiModel>> finishNewKeyPairRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.finishNewKeyPairRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FinishNewKeyPairRequestResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<FinishNewKeyPairRequestResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FinishNewKeyPairRequestResponseApiModel> clientResponse = finishNewKeyPairRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FinishNewKeyPairRequestResponseApiModel> finishNewKeyPairRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<FinishNewKeyPairRequestResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<FinishNewKeyPairRequestResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Approve the certificate request.
     * Validates the request with the application database.
     - If Approved:
       - New Key Pair request: Creates the new key pair
             in the requested format, signs the certificate and stores the
             private key for later securely in KeyVault.
       - Cert Signing Request: Creates and signs the certificate.
             Deletes the CSR from the database.
      Stores the signed certificate for later use in the Database.
      The request is in the 'Approved' or 'Rejected' state after this call.
      Requires Approver role.
      Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void approveRequest(String requestId) {
        approveRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Approve the certificate request.
     * Validates the request with the application database.
     - If Approved:
       - New Key Pair request: Creates the new key pair
             in the requested format, signs the certificate and stores the
             private key for later securely in KeyVault.
       - Cert Signing Request: Creates and signs the certificate.
             Deletes the CSR from the database.
      Stores the signed certificate for later use in the Database.
      The request is in the 'Approved' or 'Rejected' state after this call.
      Requires Approver role.
      Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> approveRequestAsync(String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(approveRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Approve the certificate request.
     * Validates the request with the application database.
     - If Approved:
       - New Key Pair request: Creates the new key pair
             in the requested format, signs the certificate and stores the
             private key for later securely in KeyVault.
       - Cert Signing Request: Creates and signs the certificate.
             Deletes the CSR from the database.
      Stores the signed certificate for later use in the Database.
      The request is in the 'Approved' or 'Rejected' state after this call.
      Requires Approver role.
      Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> approveRequestAsync(String requestId) {
        return approveRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Approve the certificate request.
     * Validates the request with the application database.
     - If Approved:
       - New Key Pair request: Creates the new key pair
             in the requested format, signs the certificate and stores the
             private key for later securely in KeyVault.
       - Cert Signing Request: Creates and signs the certificate.
             Deletes the CSR from the database.
      Stores the signed certificate for later use in the Database.
      The request is in the 'Approved' or 'Rejected' state after this call.
      Requires Approver role.
      Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> approveRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.approveRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = approveRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> approveRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Reject the certificate request.
     * The request is in the 'Rejected' state after this call.
     Requires Approver role.
     Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void rejectRequest(String requestId) {
        rejectRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Reject the certificate request.
     * The request is in the 'Rejected' state after this call.
     Requires Approver role.
     Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> rejectRequestAsync(String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(rejectRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Reject the certificate request.
     * The request is in the 'Rejected' state after this call.
     Requires Approver role.
     Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> rejectRequestAsync(String requestId) {
        return rejectRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Reject the certificate request.
     * The request is in the 'Rejected' state after this call.
     Requires Approver role.
     Approver needs signing rights in KeyVault.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> rejectRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.rejectRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = rejectRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> rejectRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Cancel request.
     * The request is in the 'Accepted' state after this call.
     Requires Writer role.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void acceptRequest(String requestId) {
        acceptRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Cancel request.
     * The request is in the 'Accepted' state after this call.
     Requires Writer role.
     *
     * @param requestId The certificate request id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> acceptRequestAsync(String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(acceptRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Cancel request.
     * The request is in the 'Accepted' state after this call.
     Requires Writer role.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> acceptRequestAsync(String requestId) {
        return acceptRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel request.
     * The request is in the 'Accepted' state after this call.
     Requires Writer role.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> acceptRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.acceptRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = acceptRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> acceptRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get a specific certificate request.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateRequestRecordApiModel object if successful.
     */
    public CertificateRequestRecordApiModel getRequest(String requestId) {
        return getRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Get a specific certificate request.
     *
     * @param requestId The certificate request id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateRequestRecordApiModel> getRequestAsync(String requestId, final ServiceCallback<CertificateRequestRecordApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Get a specific certificate request.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestRecordApiModel object
     */
    public Observable<CertificateRequestRecordApiModel> getRequestAsync(String requestId) {
        return getRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<CertificateRequestRecordApiModel>, CertificateRequestRecordApiModel>() {
            @Override
            public CertificateRequestRecordApiModel call(ServiceResponse<CertificateRequestRecordApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a specific certificate request.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestRecordApiModel object
     */
    public Observable<ServiceResponse<CertificateRequestRecordApiModel>> getRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.getRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateRequestRecordApiModel>>>() {
                @Override
                public Observable<ServiceResponse<CertificateRequestRecordApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateRequestRecordApiModel> clientResponse = getRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateRequestRecordApiModel> getRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<CertificateRequestRecordApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<CertificateRequestRecordApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete request. Physically delete the request.
     * By purging the request it is actually physically deleted from the
     database, including the public key and other information.
     Requires Manager role.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRequest(String requestId) {
        deleteRequestWithServiceResponseAsync(requestId).toBlocking().single().body();
    }

    /**
     * Delete request. Physically delete the request.
     * By purging the request it is actually physically deleted from the
     database, including the public key and other information.
     Requires Manager role.
     *
     * @param requestId The certificate request id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRequestAsync(String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRequestWithServiceResponseAsync(requestId), serviceCallback);
    }

    /**
     * Delete request. Physically delete the request.
     * By purging the request it is actually physically deleted from the
     database, including the public key and other information.
     Requires Manager role.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRequestAsync(String requestId) {
        return deleteRequestWithServiceResponseAsync(requestId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete request. Physically delete the request.
     * By purging the request it is actually physically deleted from the
     database, including the public key and other information.
     Requires Manager role.
     *
     * @param requestId The certificate request id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRequestWithServiceResponseAsync(String requestId) {
        if (requestId == null) {
            throw new IllegalArgumentException("Parameter requestId is required and cannot be null.");
        }
        return service.deleteRequest(requestId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRequestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRequestDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateRequestQueryResponseApiModel object if successful.
     */
    public CertificateRequestQueryResponseApiModel queryRequests() {
        return queryRequestsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateRequestQueryResponseApiModel> queryRequestsAsync(final ServiceCallback<CertificateRequestQueryResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryRequestsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<CertificateRequestQueryResponseApiModel> queryRequestsAsync() {
        return queryRequestsWithServiceResponseAsync().map(new Func1<ServiceResponse<CertificateRequestQueryResponseApiModel>, CertificateRequestQueryResponseApiModel>() {
            @Override
            public CertificateRequestQueryResponseApiModel call(ServiceResponse<CertificateRequestQueryResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> queryRequestsWithServiceResponseAsync() {
        final CertificateRequestQueryRequestApiModel query = null;
        final Integer pageSize = null;
        return service.queryRequests(query, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateRequestQueryResponseApiModel> clientResponse = queryRequestsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @param query optional, query filter
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateRequestQueryResponseApiModel object if successful.
     */
    public CertificateRequestQueryResponseApiModel queryRequests(CertificateRequestQueryRequestApiModel query, Integer pageSize) {
        return queryRequestsWithServiceResponseAsync(query, pageSize).toBlocking().single().body();
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @param query optional, query filter
     * @param pageSize optional, the maximum number of result per page
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateRequestQueryResponseApiModel> queryRequestsAsync(CertificateRequestQueryRequestApiModel query, Integer pageSize, final ServiceCallback<CertificateRequestQueryResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryRequestsWithServiceResponseAsync(query, pageSize), serviceCallback);
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @param query optional, query filter
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<CertificateRequestQueryResponseApiModel> queryRequestsAsync(CertificateRequestQueryRequestApiModel query, Integer pageSize) {
        return queryRequestsWithServiceResponseAsync(query, pageSize).map(new Func1<ServiceResponse<CertificateRequestQueryResponseApiModel>, CertificateRequestQueryResponseApiModel>() {
            @Override
            public CertificateRequestQueryResponseApiModel call(ServiceResponse<CertificateRequestQueryResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query for certificate requests.
     * Get all certificate requests in paged form.
     The returned model can contain a link to the next page if more results are
     available.  Use ListRequests to continue.
     *
     * @param query optional, query filter
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> queryRequestsWithServiceResponseAsync(CertificateRequestQueryRequestApiModel query, Integer pageSize) {
        Validator.validate(query);
        return service.queryRequests(query, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateRequestQueryResponseApiModel> clientResponse = queryRequestsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateRequestQueryResponseApiModel> queryRequestsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<CertificateRequestQueryResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<CertificateRequestQueryResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateRequestQueryResponseApiModel object if successful.
     */
    public CertificateRequestQueryResponseApiModel listRequests() {
        return listRequestsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateRequestQueryResponseApiModel> listRequestsAsync(final ServiceCallback<CertificateRequestQueryResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(listRequestsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<CertificateRequestQueryResponseApiModel> listRequestsAsync() {
        return listRequestsWithServiceResponseAsync().map(new Func1<ServiceResponse<CertificateRequestQueryResponseApiModel>, CertificateRequestQueryResponseApiModel>() {
            @Override
            public CertificateRequestQueryResponseApiModel call(ServiceResponse<CertificateRequestQueryResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> listRequestsWithServiceResponseAsync() {
        final String nextPageLink = null;
        final Integer pageSize = null;
        return service.listRequests(nextPageLink, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateRequestQueryResponseApiModel> clientResponse = listRequestsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateRequestQueryResponseApiModel object if successful.
     */
    public CertificateRequestQueryResponseApiModel listRequests(String nextPageLink, Integer pageSize) {
        return listRequestsWithServiceResponseAsync(nextPageLink, pageSize).toBlocking().single().body();
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateRequestQueryResponseApiModel> listRequestsAsync(String nextPageLink, Integer pageSize, final ServiceCallback<CertificateRequestQueryResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(listRequestsWithServiceResponseAsync(nextPageLink, pageSize), serviceCallback);
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<CertificateRequestQueryResponseApiModel> listRequestsAsync(String nextPageLink, Integer pageSize) {
        return listRequestsWithServiceResponseAsync(nextPageLink, pageSize).map(new Func1<ServiceResponse<CertificateRequestQueryResponseApiModel>, CertificateRequestQueryResponseApiModel>() {
            @Override
            public CertificateRequestQueryResponseApiModel call(ServiceResponse<CertificateRequestQueryResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists certificate requests.
     * Get all certificate requests in paged form or continue a current listing or
     query.
     The returned model can contain a link to the next page if more results are
     available.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateRequestQueryResponseApiModel object
     */
    public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> listRequestsWithServiceResponseAsync(String nextPageLink, Integer pageSize) {
        return service.listRequests(nextPageLink, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<CertificateRequestQueryResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateRequestQueryResponseApiModel> clientResponse = listRequestsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateRequestQueryResponseApiModel> listRequestsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<CertificateRequestQueryResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<CertificateRequestQueryResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get the status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StatusResponseApiModel object if successful.
     */
    public StatusResponseApiModel getStatus() {
        return getStatusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StatusResponseApiModel> getStatusAsync(final ServiceCallback<StatusResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getStatusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<StatusResponseApiModel> getStatusAsync() {
        return getStatusWithServiceResponseAsync().map(new Func1<ServiceResponse<StatusResponseApiModel>, StatusResponseApiModel>() {
            @Override
            public StatusResponseApiModel call(ServiceResponse<StatusResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<ServiceResponse<StatusResponseApiModel>> getStatusWithServiceResponseAsync() {
        return service.getStatus()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StatusResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<StatusResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StatusResponseApiModel> clientResponse = getStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StatusResponseApiModel> getStatusDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<StatusResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StatusResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrustGroupRegistrationListApiModel object if successful.
     */
    public TrustGroupRegistrationListApiModel listGroups() {
        return listGroupsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrustGroupRegistrationListApiModel> listGroupsAsync(final ServiceCallback<TrustGroupRegistrationListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(listGroupsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationListApiModel object
     */
    public Observable<TrustGroupRegistrationListApiModel> listGroupsAsync() {
        return listGroupsWithServiceResponseAsync().map(new Func1<ServiceResponse<TrustGroupRegistrationListApiModel>, TrustGroupRegistrationListApiModel>() {
            @Override
            public TrustGroupRegistrationListApiModel call(ServiceResponse<TrustGroupRegistrationListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationListApiModel object
     */
    public Observable<ServiceResponse<TrustGroupRegistrationListApiModel>> listGroupsWithServiceResponseAsync() {
        final String nextPageLink = null;
        final Integer pageSize = null;
        return service.listGroups(nextPageLink, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrustGroupRegistrationListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<TrustGroupRegistrationListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrustGroupRegistrationListApiModel> clientResponse = listGroupsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrustGroupRegistrationListApiModel object if successful.
     */
    public TrustGroupRegistrationListApiModel listGroups(String nextPageLink, Integer pageSize) {
        return listGroupsWithServiceResponseAsync(nextPageLink, pageSize).toBlocking().single().body();
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrustGroupRegistrationListApiModel> listGroupsAsync(String nextPageLink, Integer pageSize, final ServiceCallback<TrustGroupRegistrationListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(listGroupsWithServiceResponseAsync(nextPageLink, pageSize), serviceCallback);
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationListApiModel object
     */
    public Observable<TrustGroupRegistrationListApiModel> listGroupsAsync(String nextPageLink, Integer pageSize) {
        return listGroupsWithServiceResponseAsync(nextPageLink, pageSize).map(new Func1<ServiceResponse<TrustGroupRegistrationListApiModel>, TrustGroupRegistrationListApiModel>() {
            @Override
            public TrustGroupRegistrationListApiModel call(ServiceResponse<TrustGroupRegistrationListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get information about all groups.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationListApiModel object
     */
    public Observable<ServiceResponse<TrustGroupRegistrationListApiModel>> listGroupsWithServiceResponseAsync(String nextPageLink, Integer pageSize) {
        return service.listGroups(nextPageLink, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrustGroupRegistrationListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<TrustGroupRegistrationListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrustGroupRegistrationListApiModel> clientResponse = listGroupsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TrustGroupRegistrationListApiModel> listGroupsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<TrustGroupRegistrationListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TrustGroupRegistrationListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Create new sub-group of an existing group.
     * Requires manager role.
     *
     * @param request The create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrustGroupRegistrationResponseApiModel object if successful.
     */
    public TrustGroupRegistrationResponseApiModel createGroup(TrustGroupRegistrationRequestApiModel request) {
        return createGroupWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Create new sub-group of an existing group.
     * Requires manager role.
     *
     * @param request The create request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrustGroupRegistrationResponseApiModel> createGroupAsync(TrustGroupRegistrationRequestApiModel request, final ServiceCallback<TrustGroupRegistrationResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(createGroupWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Create new sub-group of an existing group.
     * Requires manager role.
     *
     * @param request The create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationResponseApiModel object
     */
    public Observable<TrustGroupRegistrationResponseApiModel> createGroupAsync(TrustGroupRegistrationRequestApiModel request) {
        return createGroupWithServiceResponseAsync(request).map(new Func1<ServiceResponse<TrustGroupRegistrationResponseApiModel>, TrustGroupRegistrationResponseApiModel>() {
            @Override
            public TrustGroupRegistrationResponseApiModel call(ServiceResponse<TrustGroupRegistrationResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new sub-group of an existing group.
     * Requires manager role.
     *
     * @param request The create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationResponseApiModel object
     */
    public Observable<ServiceResponse<TrustGroupRegistrationResponseApiModel>> createGroupWithServiceResponseAsync(TrustGroupRegistrationRequestApiModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.createGroup(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrustGroupRegistrationResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<TrustGroupRegistrationResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrustGroupRegistrationResponseApiModel> clientResponse = createGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TrustGroupRegistrationResponseApiModel> createGroupDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TrustGroupRegistrationResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TrustGroupRegistrationResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get group information.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param groupId The group id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrustGroupRegistrationApiModel object if successful.
     */
    public TrustGroupRegistrationApiModel getGroup(String groupId) {
        return getGroupWithServiceResponseAsync(groupId).toBlocking().single().body();
    }

    /**
     * Get group information.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param groupId The group id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrustGroupRegistrationApiModel> getGroupAsync(String groupId, final ServiceCallback<TrustGroupRegistrationApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getGroupWithServiceResponseAsync(groupId), serviceCallback);
    }

    /**
     * Get group information.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param groupId The group id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationApiModel object
     */
    public Observable<TrustGroupRegistrationApiModel> getGroupAsync(String groupId) {
        return getGroupWithServiceResponseAsync(groupId).map(new Func1<ServiceResponse<TrustGroupRegistrationApiModel>, TrustGroupRegistrationApiModel>() {
            @Override
            public TrustGroupRegistrationApiModel call(ServiceResponse<TrustGroupRegistrationApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get group information.
     * A trust group has a root certificate which issues certificates
     to entities.  Entities can be part of a trust group and thus
     trust the root certificate and all entities that the root has
     issued certificates for.
     *
     * @param groupId The group id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationApiModel object
     */
    public Observable<ServiceResponse<TrustGroupRegistrationApiModel>> getGroupWithServiceResponseAsync(String groupId) {
        if (groupId == null) {
            throw new IllegalArgumentException("Parameter groupId is required and cannot be null.");
        }
        return service.getGroup(groupId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrustGroupRegistrationApiModel>>>() {
                @Override
                public Observable<ServiceResponse<TrustGroupRegistrationApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrustGroupRegistrationApiModel> clientResponse = getGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TrustGroupRegistrationApiModel> getGroupDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TrustGroupRegistrationApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TrustGroupRegistrationApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Update group registration.
     * Use this function with care and only if you are aware of
     the security implications.
     Requires manager role.
     *
     * @param groupId The group id
     * @param request The group configuration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateGroup(String groupId, TrustGroupUpdateRequestApiModel request) {
        updateGroupWithServiceResponseAsync(groupId, request).toBlocking().single().body();
    }

    /**
     * Update group registration.
     * Use this function with care and only if you are aware of
     the security implications.
     Requires manager role.
     *
     * @param groupId The group id
     * @param request The group configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateGroupAsync(String groupId, TrustGroupUpdateRequestApiModel request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateGroupWithServiceResponseAsync(groupId, request), serviceCallback);
    }

    /**
     * Update group registration.
     * Use this function with care and only if you are aware of
     the security implications.
     Requires manager role.
     *
     * @param groupId The group id
     * @param request The group configuration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateGroupAsync(String groupId, TrustGroupUpdateRequestApiModel request) {
        return updateGroupWithServiceResponseAsync(groupId, request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update group registration.
     * Use this function with care and only if you are aware of
     the security implications.
     Requires manager role.
     *
     * @param groupId The group id
     * @param request The group configuration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateGroupWithServiceResponseAsync(String groupId, TrustGroupUpdateRequestApiModel request) {
        if (groupId == null) {
            throw new IllegalArgumentException("Parameter groupId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateGroup(groupId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateGroupDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Delete a group.
     * After this operation the Issuer CA, CRLs and keys become inaccessible.
     Use this function with extreme caution.
     Requires manager role.
     *
     * @param groupId The group id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteGroup(String groupId) {
        deleteGroupWithServiceResponseAsync(groupId).toBlocking().single().body();
    }

    /**
     * Delete a group.
     * After this operation the Issuer CA, CRLs and keys become inaccessible.
     Use this function with extreme caution.
     Requires manager role.
     *
     * @param groupId The group id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteGroupAsync(String groupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGroupWithServiceResponseAsync(groupId), serviceCallback);
    }

    /**
     * Delete a group.
     * After this operation the Issuer CA, CRLs and keys become inaccessible.
     Use this function with extreme caution.
     Requires manager role.
     *
     * @param groupId The group id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteGroupAsync(String groupId) {
        return deleteGroupWithServiceResponseAsync(groupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a group.
     * After this operation the Issuer CA, CRLs and keys become inaccessible.
     Use this function with extreme caution.
     Requires manager role.
     *
     * @param groupId The group id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteGroupWithServiceResponseAsync(String groupId) {
        if (groupId == null) {
            throw new IllegalArgumentException("Parameter groupId is required and cannot be null.");
        }
        return service.deleteGroup(groupId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteGroupDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Create new root group.
     * Requires manager role.
     *
     * @param request The create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrustGroupRegistrationResponseApiModel object if successful.
     */
    public TrustGroupRegistrationResponseApiModel createRoot(TrustGroupRootCreateRequestApiModel request) {
        return createRootWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Create new root group.
     * Requires manager role.
     *
     * @param request The create request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrustGroupRegistrationResponseApiModel> createRootAsync(TrustGroupRootCreateRequestApiModel request, final ServiceCallback<TrustGroupRegistrationResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(createRootWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Create new root group.
     * Requires manager role.
     *
     * @param request The create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationResponseApiModel object
     */
    public Observable<TrustGroupRegistrationResponseApiModel> createRootAsync(TrustGroupRootCreateRequestApiModel request) {
        return createRootWithServiceResponseAsync(request).map(new Func1<ServiceResponse<TrustGroupRegistrationResponseApiModel>, TrustGroupRegistrationResponseApiModel>() {
            @Override
            public TrustGroupRegistrationResponseApiModel call(ServiceResponse<TrustGroupRegistrationResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new root group.
     * Requires manager role.
     *
     * @param request The create request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrustGroupRegistrationResponseApiModel object
     */
    public Observable<ServiceResponse<TrustGroupRegistrationResponseApiModel>> createRootWithServiceResponseAsync(TrustGroupRootCreateRequestApiModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.createRoot(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrustGroupRegistrationResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<TrustGroupRegistrationResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrustGroupRegistrationResponseApiModel> clientResponse = createRootDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TrustGroupRegistrationResponseApiModel> createRootDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TrustGroupRegistrationResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TrustGroupRegistrationResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Renew a group CA Certificate.
     *
     * @param groupId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void renewIssuerCertificate(String groupId) {
        renewIssuerCertificateWithServiceResponseAsync(groupId).toBlocking().single().body();
    }

    /**
     * Renew a group CA Certificate.
     *
     * @param groupId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> renewIssuerCertificateAsync(String groupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(renewIssuerCertificateWithServiceResponseAsync(groupId), serviceCallback);
    }

    /**
     * Renew a group CA Certificate.
     *
     * @param groupId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> renewIssuerCertificateAsync(String groupId) {
        return renewIssuerCertificateWithServiceResponseAsync(groupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Renew a group CA Certificate.
     *
     * @param groupId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> renewIssuerCertificateWithServiceResponseAsync(String groupId) {
        if (groupId == null) {
            throw new IllegalArgumentException("Parameter groupId is required and cannot be null.");
        }
        return service.renewIssuerCertificate(groupId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = renewIssuerCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> renewIssuerCertificateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Add trust relationship.
     * Define trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param trustedEntityId The trusted entity identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void addTrustRelationship(String entityId, String trustedEntityId) {
        addTrustRelationshipWithServiceResponseAsync(entityId, trustedEntityId).toBlocking().single().body();
    }

    /**
     * Add trust relationship.
     * Define trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param trustedEntityId The trusted entity identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> addTrustRelationshipAsync(String entityId, String trustedEntityId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(addTrustRelationshipWithServiceResponseAsync(entityId, trustedEntityId), serviceCallback);
    }

    /**
     * Add trust relationship.
     * Define trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param trustedEntityId The trusted entity identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> addTrustRelationshipAsync(String entityId, String trustedEntityId) {
        return addTrustRelationshipWithServiceResponseAsync(entityId, trustedEntityId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Add trust relationship.
     * Define trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param trustedEntityId The trusted entity identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> addTrustRelationshipWithServiceResponseAsync(String entityId, String trustedEntityId) {
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (trustedEntityId == null) {
            throw new IllegalArgumentException("Parameter trustedEntityId is required and cannot be null.");
        }
        return service.addTrustRelationship(entityId, trustedEntityId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = addTrustRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> addTrustRelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the X509CertificateListApiModel object if successful.
     */
    public X509CertificateListApiModel listTrustedCertificates(String entityId) {
        return listTrustedCertificatesWithServiceResponseAsync(entityId).toBlocking().single().body();
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<X509CertificateListApiModel> listTrustedCertificatesAsync(String entityId, final ServiceCallback<X509CertificateListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(listTrustedCertificatesWithServiceResponseAsync(entityId), serviceCallback);
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CertificateListApiModel object
     */
    public Observable<X509CertificateListApiModel> listTrustedCertificatesAsync(String entityId) {
        return listTrustedCertificatesWithServiceResponseAsync(entityId).map(new Func1<ServiceResponse<X509CertificateListApiModel>, X509CertificateListApiModel>() {
            @Override
            public X509CertificateListApiModel call(ServiceResponse<X509CertificateListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CertificateListApiModel object
     */
    public Observable<ServiceResponse<X509CertificateListApiModel>> listTrustedCertificatesWithServiceResponseAsync(String entityId) {
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String nextPageLink = null;
        final Integer pageSize = null;
        return service.listTrustedCertificates(entityId, nextPageLink, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<X509CertificateListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<X509CertificateListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<X509CertificateListApiModel> clientResponse = listTrustedCertificatesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the X509CertificateListApiModel object if successful.
     */
    public X509CertificateListApiModel listTrustedCertificates(String entityId, String nextPageLink, Integer pageSize) {
        return listTrustedCertificatesWithServiceResponseAsync(entityId, nextPageLink, pageSize).toBlocking().single().body();
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<X509CertificateListApiModel> listTrustedCertificatesAsync(String entityId, String nextPageLink, Integer pageSize, final ServiceCallback<X509CertificateListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(listTrustedCertificatesWithServiceResponseAsync(entityId, nextPageLink, pageSize), serviceCallback);
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CertificateListApiModel object
     */
    public Observable<X509CertificateListApiModel> listTrustedCertificatesAsync(String entityId, String nextPageLink, Integer pageSize) {
        return listTrustedCertificatesWithServiceResponseAsync(entityId, nextPageLink, pageSize).map(new Func1<ServiceResponse<X509CertificateListApiModel>, X509CertificateListApiModel>() {
            @Override
            public X509CertificateListApiModel call(ServiceResponse<X509CertificateListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * List trusted certificates.
     * Returns all certificates the entity should trust based on the
     applied trust configuration.
     *
     * @param entityId the String value
     * @param nextPageLink optional, link to next page
     * @param pageSize optional, the maximum number of result per page
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the X509CertificateListApiModel object
     */
    public Observable<ServiceResponse<X509CertificateListApiModel>> listTrustedCertificatesWithServiceResponseAsync(String entityId, String nextPageLink, Integer pageSize) {
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        return service.listTrustedCertificates(entityId, nextPageLink, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<X509CertificateListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<X509CertificateListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<X509CertificateListApiModel> clientResponse = listTrustedCertificatesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<X509CertificateListApiModel> listTrustedCertificatesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<X509CertificateListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<X509CertificateListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Remove a trust relationship.
     * Removes trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param untrustedEntityId The trusted entity identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeTrustRelationship(String entityId, String untrustedEntityId) {
        removeTrustRelationshipWithServiceResponseAsync(entityId, untrustedEntityId).toBlocking().single().body();
    }

    /**
     * Remove a trust relationship.
     * Removes trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param untrustedEntityId The trusted entity identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeTrustRelationshipAsync(String entityId, String untrustedEntityId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeTrustRelationshipWithServiceResponseAsync(entityId, untrustedEntityId), serviceCallback);
    }

    /**
     * Remove a trust relationship.
     * Removes trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param untrustedEntityId The trusted entity identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeTrustRelationshipAsync(String entityId, String untrustedEntityId) {
        return removeTrustRelationshipWithServiceResponseAsync(entityId, untrustedEntityId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Remove a trust relationship.
     * Removes trust between two entities.  The entities are identifiers
     of application, groups, or endpoints.
     *
     * @param entityId The entity identifier, e.g. group, etc.
     * @param untrustedEntityId The trusted entity identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeTrustRelationshipWithServiceResponseAsync(String entityId, String untrustedEntityId) {
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (untrustedEntityId == null) {
            throw new IllegalArgumentException("Parameter untrustedEntityId is required and cannot be null.");
        }
        return service.removeTrustRelationship(entityId, untrustedEntityId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeTrustRelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeTrustRelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
