/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.iiot.opc.history.implementation;

import com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadNextRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadNextResponseApiModelHistoricEventApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadNextResponseApiModelHistoricValueApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadNextResponseApiModelJToken;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadRequestApiModelJToken;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadRequestApiModelReadEventsDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadRequestApiModelReadModifiedValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadRequestApiModelReadProcessedValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadRequestApiModelReadValuesAtTimesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadRequestApiModelReadValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadResponseApiModelHistoricEventApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadResponseApiModelHistoricValueApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadResponseApiModelJToken;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelDeleteEventsDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelDeleteModifiedValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelDeleteValuesAtTimesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelDeleteValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelInsertEventsDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelInsertValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelJToken;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelReplaceEventsDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateRequestApiModelReplaceValuesDetailsApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.StatusResponseApiModel;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AzureOpcHistoryClient class.
 */
public class AzureOpcHistoryClientImpl extends ServiceClient implements AzureOpcHistoryClient {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AzureOpcHistoryClientService service;

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     */
    public AzureOpcHistoryClientImpl() {
        this("https:///history");
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param baseUrl the base URL of the host
     */
    public AzureOpcHistoryClientImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcHistoryClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https:///history", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcHistoryClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AzureOpcHistoryClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AzureOpcHistoryClientService.class);
    }

    /**
     * The interface defining all the services for AzureOpcHistoryClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AzureOpcHistoryClientService {
        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteValuesAtTimes" })
        @POST("v2/delete/{endpointId}/values/pick")
        Observable<Response<ResponseBody>> historyDeleteValuesAtTimes(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelDeleteValuesAtTimesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteValues" })
        @POST("v2/delete/{endpointId}/values")
        Observable<Response<ResponseBody>> historyDeleteValues(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelDeleteValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteModifiedValues" })
        @POST("v2/delete/{endpointId}/values/modified")
        Observable<Response<ResponseBody>> historyDeleteModifiedValues(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelDeleteModifiedValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteEvents" })
        @POST("v2/delete/{endpointId}/events")
        Observable<Response<ResponseBody>> historyDeleteEvents(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelDeleteEventsDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadRaw" })
        @POST("v2/history/read/{endpointId}")
        Observable<Response<ResponseBody>> historyReadRaw(@Path("endpointId") String endpointId, @Body HistoryReadRequestApiModelJToken request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadRawNext" })
        @POST("v2/history/read/{endpointId}/next")
        Observable<Response<ResponseBody>> historyReadRawNext(@Path("endpointId") String endpointId, @Body HistoryReadNextRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyUpdateRaw" })
        @POST("v2/history/update/{endpointId}")
        Observable<Response<ResponseBody>> historyUpdateRaw(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelJToken request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyInsertValues" })
        @POST("v2/insert/{endpointId}/values")
        Observable<Response<ResponseBody>> historyInsertValues(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelInsertValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyInsertEvents" })
        @POST("v2/insert/{endpointId}/events")
        Observable<Response<ResponseBody>> historyInsertEvents(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelInsertEventsDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadEvents" })
        @POST("v2/read/{endpointId}/events")
        Observable<Response<ResponseBody>> historyReadEvents(@Path("endpointId") String endpointId, @Body HistoryReadRequestApiModelReadEventsDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadEventsNext" })
        @POST("v2/read/{endpointId}/events/next")
        Observable<Response<ResponseBody>> historyReadEventsNext(@Path("endpointId") String endpointId, @Body HistoryReadNextRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadValues" })
        @POST("v2/read/{endpointId}/values")
        Observable<Response<ResponseBody>> historyReadValues(@Path("endpointId") String endpointId, @Body HistoryReadRequestApiModelReadValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadValuesAtTimes" })
        @POST("v2/read/{endpointId}/values/pick")
        Observable<Response<ResponseBody>> historyReadValuesAtTimes(@Path("endpointId") String endpointId, @Body HistoryReadRequestApiModelReadValuesAtTimesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadProcessedValues" })
        @POST("v2/read/{endpointId}/values/processed")
        Observable<Response<ResponseBody>> historyReadProcessedValues(@Path("endpointId") String endpointId, @Body HistoryReadRequestApiModelReadProcessedValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadModifiedValues" })
        @POST("v2/read/{endpointId}/values/modified")
        Observable<Response<ResponseBody>> historyReadModifiedValues(@Path("endpointId") String endpointId, @Body HistoryReadRequestApiModelReadModifiedValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadValueNext" })
        @POST("v2/read/{endpointId}/values/next")
        Observable<Response<ResponseBody>> historyReadValueNext(@Path("endpointId") String endpointId, @Body HistoryReadNextRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReplaceValues" })
        @POST("v2/replace/{endpointId}/values")
        Observable<Response<ResponseBody>> historyReplaceValues(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelReplaceValuesDetailsApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReplaceEvents" })
        @POST("v2/replace/{endpointId}/events")
        Observable<Response<ResponseBody>> historyReplaceEvents(@Path("endpointId") String endpointId, @Body HistoryUpdateRequestApiModelReplaceEventsDetailsApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient getStatus" })
        @GET("v2/status")
        Observable<Response<ResponseBody>> getStatus();

    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteValuesAtTimes(String endpointId, HistoryUpdateRequestApiModelDeleteValuesAtTimesDetailsApiModel request) {
        return historyDeleteValuesAtTimesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteValuesAtTimesAsync(String endpointId, HistoryUpdateRequestApiModelDeleteValuesAtTimesDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteValuesAtTimesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteValuesAtTimesAsync(String endpointId, HistoryUpdateRequestApiModelDeleteValuesAtTimesDetailsApiModel request) {
        return historyDeleteValuesAtTimesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteValuesAtTimesWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelDeleteValuesAtTimesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyDeleteValuesAtTimes(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteValuesAtTimesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteValuesAtTimesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteValues(String endpointId, HistoryUpdateRequestApiModelDeleteValuesDetailsApiModel request) {
        return historyDeleteValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteValuesAsync(String endpointId, HistoryUpdateRequestApiModelDeleteValuesDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteValuesAsync(String endpointId, HistoryUpdateRequestApiModelDeleteValuesDetailsApiModel request) {
        return historyDeleteValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteValuesWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelDeleteValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyDeleteValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteModifiedValues(String endpointId, HistoryUpdateRequestApiModelDeleteModifiedValuesDetailsApiModel request) {
        return historyDeleteModifiedValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteModifiedValuesAsync(String endpointId, HistoryUpdateRequestApiModelDeleteModifiedValuesDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteModifiedValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteModifiedValuesAsync(String endpointId, HistoryUpdateRequestApiModelDeleteModifiedValuesDetailsApiModel request) {
        return historyDeleteModifiedValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteModifiedValuesWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelDeleteModifiedValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyDeleteModifiedValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteModifiedValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteModifiedValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteEvents(String endpointId, HistoryUpdateRequestApiModelDeleteEventsDetailsApiModel request) {
        return historyDeleteEventsWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteEventsAsync(String endpointId, HistoryUpdateRequestApiModelDeleteEventsDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteEventsWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteEventsAsync(String endpointId, HistoryUpdateRequestApiModelDeleteEventsDetailsApiModel request) {
        return historyDeleteEventsWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteEventsWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelDeleteEventsDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyDeleteEvents(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadResponseApiModelJToken object if successful.
     */
    public HistoryReadResponseApiModelJToken historyReadRaw(String endpointId, HistoryReadRequestApiModelJToken request) {
        return historyReadRawWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadResponseApiModelJToken> historyReadRawAsync(String endpointId, HistoryReadRequestApiModelJToken request, final ServiceCallback<HistoryReadResponseApiModelJToken> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadRawWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelJToken object
     */
    public Observable<HistoryReadResponseApiModelJToken> historyReadRawAsync(String endpointId, HistoryReadRequestApiModelJToken request) {
        return historyReadRawWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadResponseApiModelJToken>, HistoryReadResponseApiModelJToken>() {
            @Override
            public HistoryReadResponseApiModelJToken call(ServiceResponse<HistoryReadResponseApiModelJToken> response) {
                return response.body();
            }
        });
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelJToken object
     */
    public Observable<ServiceResponse<HistoryReadResponseApiModelJToken>> historyReadRawWithServiceResponseAsync(String endpointId, HistoryReadRequestApiModelJToken request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadRaw(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadResponseApiModelJToken>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadResponseApiModelJToken>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadResponseApiModelJToken> clientResponse = historyReadRawDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadResponseApiModelJToken> historyReadRawDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadResponseApiModelJToken, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadResponseApiModelJToken>() { }.getType())
                .build(response);
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadNextResponseApiModelJToken object if successful.
     */
    public HistoryReadNextResponseApiModelJToken historyReadRawNext(String endpointId, HistoryReadNextRequestApiModel request) {
        return historyReadRawNextWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadNextResponseApiModelJToken> historyReadRawNextAsync(String endpointId, HistoryReadNextRequestApiModel request, final ServiceCallback<HistoryReadNextResponseApiModelJToken> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadRawNextWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadNextResponseApiModelJToken object
     */
    public Observable<HistoryReadNextResponseApiModelJToken> historyReadRawNextAsync(String endpointId, HistoryReadNextRequestApiModel request) {
        return historyReadRawNextWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadNextResponseApiModelJToken>, HistoryReadNextResponseApiModelJToken>() {
            @Override
            public HistoryReadNextResponseApiModelJToken call(ServiceResponse<HistoryReadNextResponseApiModelJToken> response) {
                return response.body();
            }
        });
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadNextResponseApiModelJToken object
     */
    public Observable<ServiceResponse<HistoryReadNextResponseApiModelJToken>> historyReadRawNextWithServiceResponseAsync(String endpointId, HistoryReadNextRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadRawNext(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadNextResponseApiModelJToken>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadNextResponseApiModelJToken>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadNextResponseApiModelJToken> clientResponse = historyReadRawNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadNextResponseApiModelJToken> historyReadRawNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadNextResponseApiModelJToken, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadNextResponseApiModelJToken>() { }.getType())
                .build(response);
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyUpdateRaw(String endpointId, HistoryUpdateRequestApiModelJToken request) {
        return historyUpdateRawWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyUpdateRawAsync(String endpointId, HistoryUpdateRequestApiModelJToken request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyUpdateRawWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyUpdateRawAsync(String endpointId, HistoryUpdateRequestApiModelJToken request) {
        return historyUpdateRawWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyUpdateRawWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelJToken request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyUpdateRaw(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyUpdateRawDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyUpdateRawDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyInsertValues(String endpointId, HistoryUpdateRequestApiModelInsertValuesDetailsApiModel request) {
        return historyInsertValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyInsertValuesAsync(String endpointId, HistoryUpdateRequestApiModelInsertValuesDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyInsertValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyInsertValuesAsync(String endpointId, HistoryUpdateRequestApiModelInsertValuesDetailsApiModel request) {
        return historyInsertValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyInsertValuesWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelInsertValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyInsertValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyInsertValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyInsertValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyInsertEvents(String endpointId, HistoryUpdateRequestApiModelInsertEventsDetailsApiModel request) {
        return historyInsertEventsWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyInsertEventsAsync(String endpointId, HistoryUpdateRequestApiModelInsertEventsDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyInsertEventsWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyInsertEventsAsync(String endpointId, HistoryUpdateRequestApiModelInsertEventsDetailsApiModel request) {
        return historyInsertEventsWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyInsertEventsWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelInsertEventsDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyInsertEvents(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyInsertEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyInsertEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadResponseApiModelHistoricEventApiModel object if successful.
     */
    public HistoryReadResponseApiModelHistoricEventApiModel historyReadEvents(String endpointId, HistoryReadRequestApiModelReadEventsDetailsApiModel request) {
        return historyReadEventsWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadResponseApiModelHistoricEventApiModel> historyReadEventsAsync(String endpointId, HistoryReadRequestApiModelReadEventsDetailsApiModel request, final ServiceCallback<HistoryReadResponseApiModelHistoricEventApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadEventsWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricEventApiModel object
     */
    public Observable<HistoryReadResponseApiModelHistoricEventApiModel> historyReadEventsAsync(String endpointId, HistoryReadRequestApiModelReadEventsDetailsApiModel request) {
        return historyReadEventsWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel>, HistoryReadResponseApiModelHistoricEventApiModel>() {
            @Override
            public HistoryReadResponseApiModelHistoricEventApiModel call(ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricEventApiModel object
     */
    public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel>> historyReadEventsWithServiceResponseAsync(String endpointId, HistoryReadRequestApiModelReadEventsDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadEvents(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel> clientResponse = historyReadEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadResponseApiModelHistoricEventApiModel> historyReadEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadResponseApiModelHistoricEventApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadResponseApiModelHistoricEventApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadNextResponseApiModelHistoricEventApiModel object if successful.
     */
    public HistoryReadNextResponseApiModelHistoricEventApiModel historyReadEventsNext(String endpointId, HistoryReadNextRequestApiModel request) {
        return historyReadEventsNextWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadNextResponseApiModelHistoricEventApiModel> historyReadEventsNextAsync(String endpointId, HistoryReadNextRequestApiModel request, final ServiceCallback<HistoryReadNextResponseApiModelHistoricEventApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadEventsNextWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadNextResponseApiModelHistoricEventApiModel object
     */
    public Observable<HistoryReadNextResponseApiModelHistoricEventApiModel> historyReadEventsNextAsync(String endpointId, HistoryReadNextRequestApiModel request) {
        return historyReadEventsNextWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel>, HistoryReadNextResponseApiModelHistoricEventApiModel>() {
            @Override
            public HistoryReadNextResponseApiModelHistoricEventApiModel call(ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadNextResponseApiModelHistoricEventApiModel object
     */
    public Observable<ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel>> historyReadEventsNextWithServiceResponseAsync(String endpointId, HistoryReadNextRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadEventsNext(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel> clientResponse = historyReadEventsNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadNextResponseApiModelHistoricEventApiModel> historyReadEventsNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadNextResponseApiModelHistoricEventApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadNextResponseApiModelHistoricEventApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadResponseApiModelHistoricValueApiModel object if successful.
     */
    public HistoryReadResponseApiModelHistoricValueApiModel historyReadValues(String endpointId, HistoryReadRequestApiModelReadValuesDetailsApiModel request) {
        return historyReadValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadResponseApiModelHistoricValueApiModel> historyReadValuesAsync(String endpointId, HistoryReadRequestApiModelReadValuesDetailsApiModel request, final ServiceCallback<HistoryReadResponseApiModelHistoricValueApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<HistoryReadResponseApiModelHistoricValueApiModel> historyReadValuesAsync(String endpointId, HistoryReadRequestApiModelReadValuesDetailsApiModel request) {
        return historyReadValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>, HistoryReadResponseApiModelHistoricValueApiModel>() {
            @Override
            public HistoryReadResponseApiModelHistoricValueApiModel call(ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> historyReadValuesWithServiceResponseAsync(String endpointId, HistoryReadRequestApiModelReadValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> clientResponse = historyReadValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> historyReadValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadResponseApiModelHistoricValueApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadResponseApiModelHistoricValueApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadResponseApiModelHistoricValueApiModel object if successful.
     */
    public HistoryReadResponseApiModelHistoricValueApiModel historyReadValuesAtTimes(String endpointId, HistoryReadRequestApiModelReadValuesAtTimesDetailsApiModel request) {
        return historyReadValuesAtTimesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadResponseApiModelHistoricValueApiModel> historyReadValuesAtTimesAsync(String endpointId, HistoryReadRequestApiModelReadValuesAtTimesDetailsApiModel request, final ServiceCallback<HistoryReadResponseApiModelHistoricValueApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadValuesAtTimesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<HistoryReadResponseApiModelHistoricValueApiModel> historyReadValuesAtTimesAsync(String endpointId, HistoryReadRequestApiModelReadValuesAtTimesDetailsApiModel request) {
        return historyReadValuesAtTimesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>, HistoryReadResponseApiModelHistoricValueApiModel>() {
            @Override
            public HistoryReadResponseApiModelHistoricValueApiModel call(ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> historyReadValuesAtTimesWithServiceResponseAsync(String endpointId, HistoryReadRequestApiModelReadValuesAtTimesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadValuesAtTimes(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> clientResponse = historyReadValuesAtTimesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> historyReadValuesAtTimesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadResponseApiModelHistoricValueApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadResponseApiModelHistoricValueApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadResponseApiModelHistoricValueApiModel object if successful.
     */
    public HistoryReadResponseApiModelHistoricValueApiModel historyReadProcessedValues(String endpointId, HistoryReadRequestApiModelReadProcessedValuesDetailsApiModel request) {
        return historyReadProcessedValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadResponseApiModelHistoricValueApiModel> historyReadProcessedValuesAsync(String endpointId, HistoryReadRequestApiModelReadProcessedValuesDetailsApiModel request, final ServiceCallback<HistoryReadResponseApiModelHistoricValueApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadProcessedValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<HistoryReadResponseApiModelHistoricValueApiModel> historyReadProcessedValuesAsync(String endpointId, HistoryReadRequestApiModelReadProcessedValuesDetailsApiModel request) {
        return historyReadProcessedValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>, HistoryReadResponseApiModelHistoricValueApiModel>() {
            @Override
            public HistoryReadResponseApiModelHistoricValueApiModel call(ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> historyReadProcessedValuesWithServiceResponseAsync(String endpointId, HistoryReadRequestApiModelReadProcessedValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadProcessedValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> clientResponse = historyReadProcessedValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> historyReadProcessedValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadResponseApiModelHistoricValueApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadResponseApiModelHistoricValueApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadResponseApiModelHistoricValueApiModel object if successful.
     */
    public HistoryReadResponseApiModelHistoricValueApiModel historyReadModifiedValues(String endpointId, HistoryReadRequestApiModelReadModifiedValuesDetailsApiModel request) {
        return historyReadModifiedValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadResponseApiModelHistoricValueApiModel> historyReadModifiedValuesAsync(String endpointId, HistoryReadRequestApiModelReadModifiedValuesDetailsApiModel request, final ServiceCallback<HistoryReadResponseApiModelHistoricValueApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadModifiedValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<HistoryReadResponseApiModelHistoricValueApiModel> historyReadModifiedValuesAsync(String endpointId, HistoryReadRequestApiModelReadModifiedValuesDetailsApiModel request) {
        return historyReadModifiedValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>, HistoryReadResponseApiModelHistoricValueApiModel>() {
            @Override
            public HistoryReadResponseApiModelHistoricValueApiModel call(ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadResponseApiModelHistoricValueApiModel object
     */
    public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> historyReadModifiedValuesWithServiceResponseAsync(String endpointId, HistoryReadRequestApiModelReadModifiedValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadModifiedValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> clientResponse = historyReadModifiedValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadResponseApiModelHistoricValueApiModel> historyReadModifiedValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadResponseApiModelHistoricValueApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadResponseApiModelHistoricValueApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryReadNextResponseApiModelHistoricValueApiModel object if successful.
     */
    public HistoryReadNextResponseApiModelHistoricValueApiModel historyReadValueNext(String endpointId, HistoryReadNextRequestApiModel request) {
        return historyReadValueNextWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryReadNextResponseApiModelHistoricValueApiModel> historyReadValueNextAsync(String endpointId, HistoryReadNextRequestApiModel request, final ServiceCallback<HistoryReadNextResponseApiModelHistoricValueApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadValueNextWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadNextResponseApiModelHistoricValueApiModel object
     */
    public Observable<HistoryReadNextResponseApiModelHistoricValueApiModel> historyReadValueNextAsync(String endpointId, HistoryReadNextRequestApiModel request) {
        return historyReadValueNextWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel>, HistoryReadNextResponseApiModelHistoricValueApiModel>() {
            @Override
            public HistoryReadNextResponseApiModelHistoricValueApiModel call(ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryReadNextResponseApiModelHistoricValueApiModel object
     */
    public Observable<ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel>> historyReadValueNextWithServiceResponseAsync(String endpointId, HistoryReadNextRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReadValueNext(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel> clientResponse = historyReadValueNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryReadNextResponseApiModelHistoricValueApiModel> historyReadValueNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryReadNextResponseApiModelHistoricValueApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryReadNextResponseApiModelHistoricValueApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyReplaceValues(String endpointId, HistoryUpdateRequestApiModelReplaceValuesDetailsApiModel request) {
        return historyReplaceValuesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyReplaceValuesAsync(String endpointId, HistoryUpdateRequestApiModelReplaceValuesDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReplaceValuesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyReplaceValuesAsync(String endpointId, HistoryUpdateRequestApiModelReplaceValuesDetailsApiModel request) {
        return historyReplaceValuesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyReplaceValuesWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelReplaceValuesDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReplaceValues(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyReplaceValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyReplaceValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyReplaceEvents(String endpointId, HistoryUpdateRequestApiModelReplaceEventsDetailsApiModel request) {
        return historyReplaceEventsWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyReplaceEventsAsync(String endpointId, HistoryUpdateRequestApiModelReplaceEventsDetailsApiModel request, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReplaceEventsWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyReplaceEventsAsync(String endpointId, HistoryUpdateRequestApiModelReplaceEventsDetailsApiModel request) {
        return historyReplaceEventsWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyReplaceEventsWithServiceResponseAsync(String endpointId, HistoryUpdateRequestApiModelReplaceEventsDetailsApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.historyReplaceEvents(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyReplaceEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyReplaceEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StatusResponseApiModel object if successful.
     */
    public StatusResponseApiModel getStatus() {
        return getStatusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StatusResponseApiModel> getStatusAsync(final ServiceCallback<StatusResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getStatusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<StatusResponseApiModel> getStatusAsync() {
        return getStatusWithServiceResponseAsync().map(new Func1<ServiceResponse<StatusResponseApiModel>, StatusResponseApiModel>() {
            @Override
            public StatusResponseApiModel call(ServiceResponse<StatusResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<ServiceResponse<StatusResponseApiModel>> getStatusWithServiceResponseAsync() {
        return service.getStatus()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StatusResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<StatusResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StatusResponseApiModel> clientResponse = getStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StatusResponseApiModel> getStatusDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<StatusResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StatusResponseApiModel>() { }.getType())
                .build(response);
    }

}
