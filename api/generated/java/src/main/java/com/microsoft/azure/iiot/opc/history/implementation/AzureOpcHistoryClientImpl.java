/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.iiot.opc.history.implementation;

import com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.iiot.opc.history.models.DeleteEventsDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.DeleteModifiedValuesDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.DeleteValuesAtTimesDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.DeleteValuesDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoricEventApiModelHistoryReadNextResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoricEventApiModelHistoryReadResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoricValueApiModelHistoryReadNextResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoricValueApiModelHistoryReadResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryReadNextRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.HistoryUpdateResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.InsertEventsDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.InsertValuesDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.JTokenHistoryReadNextResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.JTokenHistoryReadRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.JTokenHistoryReadResponseApiModel;
import com.microsoft.azure.iiot.opc.history.models.JTokenHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReadEventsDetailsApiModelHistoryReadRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReadModifiedValuesDetailsApiModelHistoryReadRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReadProcessedValuesDetailsApiModelHistoryReadRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReadValuesAtTimesDetailsApiModelHistoryReadRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReadValuesDetailsApiModelHistoryReadRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReplaceEventsDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.azure.iiot.opc.history.models.ReplaceValuesDetailsApiModelHistoryUpdateRequestApiModel;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AzureOpcHistoryClient class.
 */
public class AzureOpcHistoryClientImpl extends ServiceClient implements AzureOpcHistoryClient {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AzureOpcHistoryClientService service;

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     */
    public AzureOpcHistoryClientImpl() {
        this("http://localhost:9080");
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param baseUrl the base URL of the host
     */
    public AzureOpcHistoryClientImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcHistoryClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://localhost:9080", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcHistoryClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcHistoryClient client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AzureOpcHistoryClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AzureOpcHistoryClientService.class);
    }

    /**
     * The interface defining all the services for AzureOpcHistoryClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AzureOpcHistoryClientService {
        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteValuesAtTimes" })
        @POST("v2/delete/{endpointId}/values/pick")
        Observable<Response<ResponseBody>> historyDeleteValuesAtTimes(@Path("endpointId") String endpointId, @Body DeleteValuesAtTimesDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteValues" })
        @POST("v2/delete/{endpointId}/values")
        Observable<Response<ResponseBody>> historyDeleteValues(@Path("endpointId") String endpointId, @Body DeleteValuesDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteModifiedValues" })
        @POST("v2/delete/{endpointId}/values/modified")
        Observable<Response<ResponseBody>> historyDeleteModifiedValues(@Path("endpointId") String endpointId, @Body DeleteModifiedValuesDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyDeleteEvents" })
        @POST("v2/delete/{endpointId}/events")
        Observable<Response<ResponseBody>> historyDeleteEvents(@Path("endpointId") String endpointId, @Body DeleteEventsDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadRaw" })
        @POST("v2/history/read/{endpointId}")
        Observable<Response<ResponseBody>> historyReadRaw(@Path("endpointId") String endpointId, @Body JTokenHistoryReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadRawNext" })
        @POST("v2/history/read/{endpointId}/next")
        Observable<Response<ResponseBody>> historyReadRawNext(@Path("endpointId") String endpointId, @Body HistoryReadNextRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyUpdateRaw" })
        @POST("v2/history/update/{endpointId}")
        Observable<Response<ResponseBody>> historyUpdateRaw(@Path("endpointId") String endpointId, @Body JTokenHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyInsertValues" })
        @POST("v2/insert/{endpointId}/values")
        Observable<Response<ResponseBody>> historyInsertValues(@Path("endpointId") String endpointId, @Body InsertValuesDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyInsertEvents" })
        @POST("v2/insert/{endpointId}/events")
        Observable<Response<ResponseBody>> historyInsertEvents(@Path("endpointId") String endpointId, @Body InsertEventsDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadEvents" })
        @POST("v2/read/{endpointId}/events")
        Observable<Response<ResponseBody>> historyReadEvents(@Path("endpointId") String endpointId, @Body ReadEventsDetailsApiModelHistoryReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadEventsNext" })
        @POST("v2/read/{endpointId}/events/next")
        Observable<Response<ResponseBody>> historyReadEventsNext(@Path("endpointId") String endpointId, @Body HistoryReadNextRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadValues" })
        @POST("v2/read/{endpointId}/values")
        Observable<Response<ResponseBody>> historyReadValues(@Path("endpointId") String endpointId, @Body ReadValuesDetailsApiModelHistoryReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadValuesAtTimes" })
        @POST("v2/read/{endpointId}/values/pick")
        Observable<Response<ResponseBody>> historyReadValuesAtTimes(@Path("endpointId") String endpointId, @Body ReadValuesAtTimesDetailsApiModelHistoryReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadProcessedValues" })
        @POST("v2/read/{endpointId}/values/processed")
        Observable<Response<ResponseBody>> historyReadProcessedValues(@Path("endpointId") String endpointId, @Body ReadProcessedValuesDetailsApiModelHistoryReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadModifiedValues" })
        @POST("v2/read/{endpointId}/values/modified")
        Observable<Response<ResponseBody>> historyReadModifiedValues(@Path("endpointId") String endpointId, @Body ReadModifiedValuesDetailsApiModelHistoryReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReadValueNext" })
        @POST("v2/read/{endpointId}/values/next")
        Observable<Response<ResponseBody>> historyReadValueNext(@Path("endpointId") String endpointId, @Body HistoryReadNextRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReplaceValues" })
        @POST("v2/replace/{endpointId}/values")
        Observable<Response<ResponseBody>> historyReplaceValues(@Path("endpointId") String endpointId, @Body ReplaceValuesDetailsApiModelHistoryUpdateRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.history.AzureOpcHistoryClient historyReplaceEvents" })
        @POST("v2/replace/{endpointId}/events")
        Observable<Response<ResponseBody>> historyReplaceEvents(@Path("endpointId") String endpointId, @Body ReplaceEventsDetailsApiModelHistoryUpdateRequestApiModel body);

    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteValuesAtTimes(String endpointId, DeleteValuesAtTimesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteValuesAtTimesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteValuesAtTimesAsync(String endpointId, DeleteValuesAtTimesDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteValuesAtTimesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteValuesAtTimesAsync(String endpointId, DeleteValuesAtTimesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteValuesAtTimesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete value history at specified times.
     * Delete value history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteValuesAtTimesWithServiceResponseAsync(String endpointId, DeleteValuesAtTimesDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyDeleteValuesAtTimes(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteValuesAtTimesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteValuesAtTimesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteValues(String endpointId, DeleteValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteValuesAsync(String endpointId, DeleteValuesDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteValuesAsync(String endpointId, DeleteValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteValuesWithServiceResponseAsync(String endpointId, DeleteValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyDeleteValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteModifiedValues(String endpointId, DeleteModifiedValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteModifiedValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteModifiedValuesAsync(String endpointId, DeleteModifiedValuesDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteModifiedValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteModifiedValuesAsync(String endpointId, DeleteModifiedValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteModifiedValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete historic values.
     * Delete historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteModifiedValuesWithServiceResponseAsync(String endpointId, DeleteModifiedValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyDeleteModifiedValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteModifiedValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteModifiedValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyDeleteEvents(String endpointId, DeleteEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteEventsWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyDeleteEventsAsync(String endpointId, DeleteEventsDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyDeleteEventsWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyDeleteEventsAsync(String endpointId, DeleteEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyDeleteEventsWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete historic events.
     * Delete historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyDeleteEventsWithServiceResponseAsync(String endpointId, DeleteEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyDeleteEvents(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyDeleteEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyDeleteEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JTokenHistoryReadResponseApiModel object if successful.
     */
    public JTokenHistoryReadResponseApiModel historyReadRaw(String endpointId, JTokenHistoryReadRequestApiModel body) {
        return historyReadRawWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JTokenHistoryReadResponseApiModel> historyReadRawAsync(String endpointId, JTokenHistoryReadRequestApiModel body, final ServiceCallback<JTokenHistoryReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadRawWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JTokenHistoryReadResponseApiModel object
     */
    public Observable<JTokenHistoryReadResponseApiModel> historyReadRawAsync(String endpointId, JTokenHistoryReadRequestApiModel body) {
        return historyReadRawWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<JTokenHistoryReadResponseApiModel>, JTokenHistoryReadResponseApiModel>() {
            @Override
            public JTokenHistoryReadResponseApiModel call(ServiceResponse<JTokenHistoryReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read history using json details.
     * Read node history if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JTokenHistoryReadResponseApiModel object
     */
    public Observable<ServiceResponse<JTokenHistoryReadResponseApiModel>> historyReadRawWithServiceResponseAsync(String endpointId, JTokenHistoryReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadRaw(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JTokenHistoryReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<JTokenHistoryReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JTokenHistoryReadResponseApiModel> clientResponse = historyReadRawDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JTokenHistoryReadResponseApiModel> historyReadRawDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<JTokenHistoryReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<JTokenHistoryReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JTokenHistoryReadNextResponseApiModel object if successful.
     */
    public JTokenHistoryReadNextResponseApiModel historyReadRawNext(String endpointId, HistoryReadNextRequestApiModel body) {
        return historyReadRawNextWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JTokenHistoryReadNextResponseApiModel> historyReadRawNextAsync(String endpointId, HistoryReadNextRequestApiModel body, final ServiceCallback<JTokenHistoryReadNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadRawNextWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JTokenHistoryReadNextResponseApiModel object
     */
    public Observable<JTokenHistoryReadNextResponseApiModel> historyReadRawNextAsync(String endpointId, HistoryReadNextRequestApiModel body) {
        return historyReadRawNextWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<JTokenHistoryReadNextResponseApiModel>, JTokenHistoryReadNextResponseApiModel>() {
            @Override
            public JTokenHistoryReadNextResponseApiModel call(ServiceResponse<JTokenHistoryReadNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read next batch of history as json.
     * Read next batch of node history values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JTokenHistoryReadNextResponseApiModel object
     */
    public Observable<ServiceResponse<JTokenHistoryReadNextResponseApiModel>> historyReadRawNextWithServiceResponseAsync(String endpointId, HistoryReadNextRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadRawNext(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JTokenHistoryReadNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<JTokenHistoryReadNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JTokenHistoryReadNextResponseApiModel> clientResponse = historyReadRawNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JTokenHistoryReadNextResponseApiModel> historyReadRawNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<JTokenHistoryReadNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<JTokenHistoryReadNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyUpdateRaw(String endpointId, JTokenHistoryUpdateRequestApiModel body) {
        return historyUpdateRawWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyUpdateRawAsync(String endpointId, JTokenHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyUpdateRawWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyUpdateRawAsync(String endpointId, JTokenHistoryUpdateRequestApiModel body) {
        return historyUpdateRawWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Update node history using raw json.
     * Update node history using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyUpdateRawWithServiceResponseAsync(String endpointId, JTokenHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyUpdateRaw(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyUpdateRawDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyUpdateRawDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyInsertValues(String endpointId, InsertValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyInsertValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyInsertValuesAsync(String endpointId, InsertValuesDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyInsertValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyInsertValuesAsync(String endpointId, InsertValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyInsertValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Insert historic values.
     * Insert historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyInsertValuesWithServiceResponseAsync(String endpointId, InsertValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyInsertValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyInsertValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyInsertValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyInsertEvents(String endpointId, InsertEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyInsertEventsWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyInsertEventsAsync(String endpointId, InsertEventsDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyInsertEventsWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyInsertEventsAsync(String endpointId, InsertEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyInsertEventsWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Insert historic events.
     * Insert historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history insert request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyInsertEventsWithServiceResponseAsync(String endpointId, InsertEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyInsertEvents(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyInsertEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyInsertEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricEventApiModelHistoryReadResponseApiModel object if successful.
     */
    public HistoricEventApiModelHistoryReadResponseApiModel historyReadEvents(String endpointId, ReadEventsDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadEventsWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricEventApiModelHistoryReadResponseApiModel> historyReadEventsAsync(String endpointId, ReadEventsDetailsApiModelHistoryReadRequestApiModel body, final ServiceCallback<HistoricEventApiModelHistoryReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadEventsWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricEventApiModelHistoryReadResponseApiModel object
     */
    public Observable<HistoricEventApiModelHistoryReadResponseApiModel> historyReadEventsAsync(String endpointId, ReadEventsDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadEventsWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel>, HistoricEventApiModelHistoryReadResponseApiModel>() {
            @Override
            public HistoricEventApiModelHistoryReadResponseApiModel call(ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic events.
     * Read historic events of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricEventApiModelHistoryReadResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel>> historyReadEventsWithServiceResponseAsync(String endpointId, ReadEventsDetailsApiModelHistoryReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadEvents(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel> clientResponse = historyReadEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricEventApiModelHistoryReadResponseApiModel> historyReadEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricEventApiModelHistoryReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricEventApiModelHistoryReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricEventApiModelHistoryReadNextResponseApiModel object if successful.
     */
    public HistoricEventApiModelHistoryReadNextResponseApiModel historyReadEventsNext(String endpointId, HistoryReadNextRequestApiModel body) {
        return historyReadEventsNextWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricEventApiModelHistoryReadNextResponseApiModel> historyReadEventsNextAsync(String endpointId, HistoryReadNextRequestApiModel body, final ServiceCallback<HistoricEventApiModelHistoryReadNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadEventsNextWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricEventApiModelHistoryReadNextResponseApiModel object
     */
    public Observable<HistoricEventApiModelHistoryReadNextResponseApiModel> historyReadEventsNextAsync(String endpointId, HistoryReadNextRequestApiModel body) {
        return historyReadEventsNextWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel>, HistoricEventApiModelHistoryReadNextResponseApiModel>() {
            @Override
            public HistoricEventApiModelHistoryReadNextResponseApiModel call(ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read next batch of historic events.
     * Read next batch of historic events of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricEventApiModelHistoryReadNextResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel>> historyReadEventsNextWithServiceResponseAsync(String endpointId, HistoryReadNextRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadEventsNext(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel> clientResponse = historyReadEventsNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricEventApiModelHistoryReadNextResponseApiModel> historyReadEventsNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricEventApiModelHistoryReadNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricEventApiModelHistoryReadNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricValueApiModelHistoryReadResponseApiModel object if successful.
     */
    public HistoricValueApiModelHistoryReadResponseApiModel historyReadValues(String endpointId, ReadValuesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricValueApiModelHistoryReadResponseApiModel> historyReadValuesAsync(String endpointId, ReadValuesDetailsApiModelHistoryReadRequestApiModel body, final ServiceCallback<HistoricValueApiModelHistoryReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<HistoricValueApiModelHistoryReadResponseApiModel> historyReadValuesAsync(String endpointId, ReadValuesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>, HistoricValueApiModelHistoryReadResponseApiModel>() {
            @Override
            public HistoricValueApiModelHistoryReadResponseApiModel call(ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> historyReadValuesWithServiceResponseAsync(String endpointId, ReadValuesDetailsApiModelHistoryReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> clientResponse = historyReadValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> historyReadValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricValueApiModelHistoryReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricValueApiModelHistoryReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricValueApiModelHistoryReadResponseApiModel object if successful.
     */
    public HistoricValueApiModelHistoryReadResponseApiModel historyReadValuesAtTimes(String endpointId, ReadValuesAtTimesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadValuesAtTimesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricValueApiModelHistoryReadResponseApiModel> historyReadValuesAtTimesAsync(String endpointId, ReadValuesAtTimesDetailsApiModelHistoryReadRequestApiModel body, final ServiceCallback<HistoricValueApiModelHistoryReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadValuesAtTimesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<HistoricValueApiModelHistoryReadResponseApiModel> historyReadValuesAtTimesAsync(String endpointId, ReadValuesAtTimesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadValuesAtTimesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>, HistoricValueApiModelHistoryReadResponseApiModel>() {
            @Override
            public HistoricValueApiModelHistoryReadResponseApiModel call(ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic values at specified times.
     * Read historic values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> historyReadValuesAtTimesWithServiceResponseAsync(String endpointId, ReadValuesAtTimesDetailsApiModelHistoryReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadValuesAtTimes(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> clientResponse = historyReadValuesAtTimesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> historyReadValuesAtTimesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricValueApiModelHistoryReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricValueApiModelHistoryReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricValueApiModelHistoryReadResponseApiModel object if successful.
     */
    public HistoricValueApiModelHistoryReadResponseApiModel historyReadProcessedValues(String endpointId, ReadProcessedValuesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadProcessedValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricValueApiModelHistoryReadResponseApiModel> historyReadProcessedValuesAsync(String endpointId, ReadProcessedValuesDetailsApiModelHistoryReadRequestApiModel body, final ServiceCallback<HistoricValueApiModelHistoryReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadProcessedValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<HistoricValueApiModelHistoryReadResponseApiModel> historyReadProcessedValuesAsync(String endpointId, ReadProcessedValuesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadProcessedValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>, HistoricValueApiModelHistoryReadResponseApiModel>() {
            @Override
            public HistoricValueApiModelHistoryReadResponseApiModel call(ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic processed values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> historyReadProcessedValuesWithServiceResponseAsync(String endpointId, ReadProcessedValuesDetailsApiModelHistoryReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadProcessedValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> clientResponse = historyReadProcessedValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> historyReadProcessedValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricValueApiModelHistoryReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricValueApiModelHistoryReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricValueApiModelHistoryReadResponseApiModel object if successful.
     */
    public HistoricValueApiModelHistoryReadResponseApiModel historyReadModifiedValues(String endpointId, ReadModifiedValuesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadModifiedValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricValueApiModelHistoryReadResponseApiModel> historyReadModifiedValuesAsync(String endpointId, ReadModifiedValuesDetailsApiModelHistoryReadRequestApiModel body, final ServiceCallback<HistoricValueApiModelHistoryReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadModifiedValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<HistoricValueApiModelHistoryReadResponseApiModel> historyReadModifiedValuesAsync(String endpointId, ReadModifiedValuesDetailsApiModelHistoryReadRequestApiModel body) {
        return historyReadModifiedValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>, HistoricValueApiModelHistoryReadResponseApiModel>() {
            @Override
            public HistoricValueApiModelHistoryReadResponseApiModel call(ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read historic modified values at specified times.
     * Read processed history values of a node if available using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> historyReadModifiedValuesWithServiceResponseAsync(String endpointId, ReadModifiedValuesDetailsApiModelHistoryReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadModifiedValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> clientResponse = historyReadModifiedValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricValueApiModelHistoryReadResponseApiModel> historyReadModifiedValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricValueApiModelHistoryReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricValueApiModelHistoryReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoricValueApiModelHistoryReadNextResponseApiModel object if successful.
     */
    public HistoricValueApiModelHistoryReadNextResponseApiModel historyReadValueNext(String endpointId, HistoryReadNextRequestApiModel body) {
        return historyReadValueNextWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoricValueApiModelHistoryReadNextResponseApiModel> historyReadValueNextAsync(String endpointId, HistoryReadNextRequestApiModel body, final ServiceCallback<HistoricValueApiModelHistoryReadNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReadValueNextWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadNextResponseApiModel object
     */
    public Observable<HistoricValueApiModelHistoryReadNextResponseApiModel> historyReadValueNextAsync(String endpointId, HistoryReadNextRequestApiModel body) {
        return historyReadValueNextWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel>, HistoricValueApiModelHistoryReadNextResponseApiModel>() {
            @Override
            public HistoricValueApiModelHistoryReadNextResponseApiModel call(ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read next batch of historic values.
     * Read next batch of historic values of a node using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history read next request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoricValueApiModelHistoryReadNextResponseApiModel object
     */
    public Observable<ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel>> historyReadValueNextWithServiceResponseAsync(String endpointId, HistoryReadNextRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReadValueNext(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel> clientResponse = historyReadValueNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoricValueApiModelHistoryReadNextResponseApiModel> historyReadValueNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoricValueApiModelHistoryReadNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoricValueApiModelHistoryReadNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyReplaceValues(String endpointId, ReplaceValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyReplaceValuesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyReplaceValuesAsync(String endpointId, ReplaceValuesDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReplaceValuesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyReplaceValuesAsync(String endpointId, ReplaceValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyReplaceValuesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Replace historic values.
     * Replace historic values using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyReplaceValuesWithServiceResponseAsync(String endpointId, ReplaceValuesDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReplaceValues(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyReplaceValuesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyReplaceValuesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HistoryUpdateResponseApiModel object if successful.
     */
    public HistoryUpdateResponseApiModel historyReplaceEvents(String endpointId, ReplaceEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyReplaceEventsWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HistoryUpdateResponseApiModel> historyReplaceEventsAsync(String endpointId, ReplaceEventsDetailsApiModelHistoryUpdateRequestApiModel body, final ServiceCallback<HistoryUpdateResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(historyReplaceEventsWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<HistoryUpdateResponseApiModel> historyReplaceEventsAsync(String endpointId, ReplaceEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        return historyReplaceEventsWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<HistoryUpdateResponseApiModel>, HistoryUpdateResponseApiModel>() {
            @Override
            public HistoryUpdateResponseApiModel call(ServiceResponse<HistoryUpdateResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Replace historic events.
     * Replace historic events using historic access. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The history replace request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HistoryUpdateResponseApiModel object
     */
    public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> historyReplaceEventsWithServiceResponseAsync(String endpointId, ReplaceEventsDetailsApiModelHistoryUpdateRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.historyReplaceEvents(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HistoryUpdateResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<HistoryUpdateResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HistoryUpdateResponseApiModel> clientResponse = historyReplaceEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HistoryUpdateResponseApiModel> historyReplaceEventsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<HistoryUpdateResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HistoryUpdateResponseApiModel>() { }.getType())
                .build(response);
    }

}
