/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.iiot.opc.twin.implementation;

import com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.iiot.opc.twin.models.BrowseNextRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowseNextResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowsePathRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowsePathResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowseRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowseResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodCallRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodCallResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodMetadataRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodMetadataResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ReadRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ReadResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueReadRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueReadResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueWriteRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueWriteResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.WriteRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.WriteResponseApiModel;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AzureOpcTwinClient class.
 */
public class AzureOpcTwinClientImpl extends ServiceClient implements AzureOpcTwinClient {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AzureOpcTwinClientService service;

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     */
    public AzureOpcTwinClientImpl() {
        this("http://localhost:9080");
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param baseUrl the base URL of the host
     */
    public AzureOpcTwinClientImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcTwinClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://localhost:9080", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcTwinClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AzureOpcTwinClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AzureOpcTwinClientService.class);
    }

    /**
     * The interface defining all the services for AzureOpcTwinClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AzureOpcTwinClientService {
        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient browse" })
        @POST("v2/browse/{endpointId}")
        Observable<Response<ResponseBody>> browse(@Path("endpointId") String endpointId, @Body BrowseRequestApiModel body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getSetOfUniqueNodes" })
        @GET("v2/browse/{endpointId}")
        Observable<Response<ResponseBody>> getSetOfUniqueNodes(@Path("endpointId") String endpointId, @Query("nodeId") String nodeId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient browseNext" })
        @POST("v2/browse/{endpointId}/next")
        Observable<Response<ResponseBody>> browseNext(@Path("endpointId") String endpointId, @Body BrowseNextRequestApiModel body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getNextSetOfUniqueNodes" })
        @GET("v2/browse/{endpointId}/next")
        Observable<Response<ResponseBody>> getNextSetOfUniqueNodes(@Path("endpointId") String endpointId, @Query("continuationToken") String continuationToken);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient browseUsingPath" })
        @POST("v2/browse/{endpointId}/path")
        Observable<Response<ResponseBody>> browseUsingPath(@Path("endpointId") String endpointId, @Body BrowsePathRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getCallMetadata" })
        @POST("v2/call/{endpointId}/metadata")
        Observable<Response<ResponseBody>> getCallMetadata(@Path("endpointId") String endpointId, @Body MethodMetadataRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient callMethod" })
        @POST("v2/call/{endpointId}")
        Observable<Response<ResponseBody>> callMethod(@Path("endpointId") String endpointId, @Body MethodCallRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient readValue" })
        @POST("v2/read/{endpointId}")
        Observable<Response<ResponseBody>> readValue(@Path("endpointId") String endpointId, @Body ValueReadRequestApiModel body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getValue" })
        @GET("v2/read/{endpointId}")
        Observable<Response<ResponseBody>> getValue(@Path("endpointId") String endpointId, @Query("nodeId") String nodeId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient readAttributes" })
        @POST("v2/read/{endpointId}/attributes")
        Observable<Response<ResponseBody>> readAttributes(@Path("endpointId") String endpointId, @Body ReadRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient writeValue" })
        @POST("v2/write/{endpointId}")
        Observable<Response<ResponseBody>> writeValue(@Path("endpointId") String endpointId, @Body ValueWriteRequestApiModel body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient writeAttributes" })
        @POST("v2/write/{endpointId}/attributes")
        Observable<Response<ResponseBody>> writeAttributes(@Path("endpointId") String endpointId, @Body WriteRequestApiModel body);

    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseResponseApiModel object if successful.
     */
    public BrowseResponseApiModel browse(String endpointId, BrowseRequestApiModel body) {
        return browseWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseResponseApiModel> browseAsync(String endpointId, BrowseRequestApiModel body, final ServiceCallback<BrowseResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(browseWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<BrowseResponseApiModel> browseAsync(String endpointId, BrowseRequestApiModel body) {
        return browseWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<BrowseResponseApiModel>, BrowseResponseApiModel>() {
            @Override
            public BrowseResponseApiModel call(ServiceResponse<BrowseResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseResponseApiModel>> browseWithServiceResponseAsync(String endpointId, BrowseRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.browse(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseResponseApiModel> clientResponse = browseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseResponseApiModel> browseDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseResponseApiModel object if successful.
     */
    public BrowseResponseApiModel getSetOfUniqueNodes(String endpointId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId, final ServiceCallback<BrowseResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSetOfUniqueNodesWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponse<BrowseResponseApiModel>, BrowseResponseApiModel>() {
            @Override
            public BrowseResponseApiModel call(ServiceResponse<BrowseResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseResponseApiModel>> getSetOfUniqueNodesWithServiceResponseAsync(String endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        final String nodeId = null;
        return service.getSetOfUniqueNodes(endpointId, nodeId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseResponseApiModel> clientResponse = getSetOfUniqueNodesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseResponseApiModel object if successful.
     */
    public BrowseResponseApiModel getSetOfUniqueNodes(String endpointId, String nodeId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId, nodeId).toBlocking().single().body();
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId, String nodeId, final ServiceCallback<BrowseResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSetOfUniqueNodesWithServiceResponseAsync(endpointId, nodeId), serviceCallback);
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId, String nodeId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId, nodeId).map(new Func1<ServiceResponse<BrowseResponseApiModel>, BrowseResponseApiModel>() {
            @Override
            public BrowseResponseApiModel call(ServiceResponse<BrowseResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. The root node id to browse from can be provided as part of the query parameters. If it is not provided, the RootFolder node is browsed. Note that this is the same as the POST method with the model containing the node id and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseResponseApiModel>> getSetOfUniqueNodesWithServiceResponseAsync(String endpointId, String nodeId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.getSetOfUniqueNodes(endpointId, nodeId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseResponseApiModel> clientResponse = getSetOfUniqueNodesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseResponseApiModel> getSetOfUniqueNodesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The request body with continuation token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseNextResponseApiModel object if successful.
     */
    public BrowseNextResponseApiModel browseNext(String endpointId, BrowseNextRequestApiModel body) {
        return browseNextWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The request body with continuation token.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseNextResponseApiModel> browseNextAsync(String endpointId, BrowseNextRequestApiModel body, final ServiceCallback<BrowseNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(browseNextWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The request body with continuation token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<BrowseNextResponseApiModel> browseNextAsync(String endpointId, BrowseNextRequestApiModel body) {
        return browseNextWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<BrowseNextResponseApiModel>, BrowseNextResponseApiModel>() {
            @Override
            public BrowseNextResponseApiModel call(ServiceResponse<BrowseNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The request body with continuation token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseNextResponseApiModel>> browseNextWithServiceResponseAsync(String endpointId, BrowseNextRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.browseNext(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseNextResponseApiModel> clientResponse = browseNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseNextResponseApiModel> browseNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. Note that this is the same as the POST method with the model containing the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseNextResponseApiModel object if successful.
     */
    public BrowseNextResponseApiModel getNextSetOfUniqueNodes(String endpointId, String continuationToken) {
        return getNextSetOfUniqueNodesWithServiceResponseAsync(endpointId, continuationToken).toBlocking().single().body();
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. Note that this is the same as the POST method with the model containing the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseNextResponseApiModel> getNextSetOfUniqueNodesAsync(String endpointId, String continuationToken, final ServiceCallback<BrowseNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getNextSetOfUniqueNodesWithServiceResponseAsync(endpointId, continuationToken), serviceCallback);
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. Note that this is the same as the POST method with the model containing the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<BrowseNextResponseApiModel> getNextSetOfUniqueNodesAsync(String endpointId, String continuationToken) {
        return getNextSetOfUniqueNodesWithServiceResponseAsync(endpointId, continuationToken).map(new Func1<ServiceResponse<BrowseNextResponseApiModel>, BrowseNextResponseApiModel>() {
            @Override
            public BrowseNextResponseApiModel call(ServiceResponse<BrowseNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the endpoint. The endpoint must be activated and connected and the module client and server must trust each other. Note that this is the same as the POST method with the model containing the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseNextResponseApiModel>> getNextSetOfUniqueNodesWithServiceResponseAsync(String endpointId, String continuationToken) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (continuationToken == null) {
            throw new IllegalArgumentException("Parameter continuationToken is required and cannot be null.");
        }
        return service.getNextSetOfUniqueNodes(endpointId, continuationToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseNextResponseApiModel> clientResponse = getNextSetOfUniqueNodesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseNextResponseApiModel> getNextSetOfUniqueNodesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id. This call uses TranslateBrowsePathsToNodeIds service under the hood. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse path request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowsePathResponseApiModel object if successful.
     */
    public BrowsePathResponseApiModel browseUsingPath(String endpointId, BrowsePathRequestApiModel body) {
        return browseUsingPathWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id. This call uses TranslateBrowsePathsToNodeIds service under the hood. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse path request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowsePathResponseApiModel> browseUsingPathAsync(String endpointId, BrowsePathRequestApiModel body, final ServiceCallback<BrowsePathResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(browseUsingPathWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id. This call uses TranslateBrowsePathsToNodeIds service under the hood. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse path request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowsePathResponseApiModel object
     */
    public Observable<BrowsePathResponseApiModel> browseUsingPathAsync(String endpointId, BrowsePathRequestApiModel body) {
        return browseUsingPathWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<BrowsePathResponseApiModel>, BrowsePathResponseApiModel>() {
            @Override
            public BrowsePathResponseApiModel call(ServiceResponse<BrowsePathResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id. This call uses TranslateBrowsePathsToNodeIds service under the hood. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The browse path request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowsePathResponseApiModel object
     */
    public Observable<ServiceResponse<BrowsePathResponseApiModel>> browseUsingPathWithServiceResponseAsync(String endpointId, BrowsePathRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.browseUsingPath(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowsePathResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowsePathResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowsePathResponseApiModel> clientResponse = browseUsingPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowsePathResponseApiModel> browseUsingPathDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowsePathResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowsePathResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to input and output arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method metadata request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MethodMetadataResponseApiModel object if successful.
     */
    public MethodMetadataResponseApiModel getCallMetadata(String endpointId, MethodMetadataRequestApiModel body) {
        return getCallMetadataWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to input and output arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method metadata request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MethodMetadataResponseApiModel> getCallMetadataAsync(String endpointId, MethodMetadataRequestApiModel body, final ServiceCallback<MethodMetadataResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getCallMetadataWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to input and output arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method metadata request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodMetadataResponseApiModel object
     */
    public Observable<MethodMetadataResponseApiModel> getCallMetadataAsync(String endpointId, MethodMetadataRequestApiModel body) {
        return getCallMetadataWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<MethodMetadataResponseApiModel>, MethodMetadataResponseApiModel>() {
            @Override
            public MethodMetadataResponseApiModel call(ServiceResponse<MethodMetadataResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to input and output arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method metadata request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodMetadataResponseApiModel object
     */
    public Observable<ServiceResponse<MethodMetadataResponseApiModel>> getCallMetadataWithServiceResponseAsync(String endpointId, MethodMetadataRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.getCallMetadata(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MethodMetadataResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<MethodMetadataResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MethodMetadataResponseApiModel> clientResponse = getCallMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MethodMetadataResponseApiModel> getCallMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<MethodMetadataResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MethodMetadataResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method call request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MethodCallResponseApiModel object if successful.
     */
    public MethodCallResponseApiModel callMethod(String endpointId, MethodCallRequestApiModel body) {
        return callMethodWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method call request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MethodCallResponseApiModel> callMethodAsync(String endpointId, MethodCallRequestApiModel body, final ServiceCallback<MethodCallResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(callMethodWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method call request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodCallResponseApiModel object
     */
    public Observable<MethodCallResponseApiModel> callMethodAsync(String endpointId, MethodCallRequestApiModel body) {
        return callMethodWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<MethodCallResponseApiModel>, MethodCallResponseApiModel>() {
            @Override
            public MethodCallResponseApiModel call(ServiceResponse<MethodCallResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The method call request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodCallResponseApiModel object
     */
    public Observable<ServiceResponse<MethodCallResponseApiModel>> callMethodWithServiceResponseAsync(String endpointId, MethodCallRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.callMethod(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MethodCallResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<MethodCallResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MethodCallResponseApiModel> clientResponse = callMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MethodCallResponseApiModel> callMethodDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<MethodCallResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MethodCallResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read variable value.
     * Read a variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValueReadResponseApiModel object if successful.
     */
    public ValueReadResponseApiModel readValue(String endpointId, ValueReadRequestApiModel body) {
        return readValueWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read variable value.
     * Read a variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read value request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValueReadResponseApiModel> readValueAsync(String endpointId, ValueReadRequestApiModel body, final ServiceCallback<ValueReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(readValueWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read variable value.
     * Read a variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ValueReadResponseApiModel> readValueAsync(String endpointId, ValueReadRequestApiModel body) {
        return readValueWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<ValueReadResponseApiModel>, ValueReadResponseApiModel>() {
            @Override
            public ValueReadResponseApiModel call(ServiceResponse<ValueReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read variable value.
     * Read a variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ServiceResponse<ValueReadResponseApiModel>> readValueWithServiceResponseAsync(String endpointId, ValueReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.readValue(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValueReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ValueReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValueReadResponseApiModel> clientResponse = readValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValueReadResponseApiModel> readValueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValueReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValueReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValueReadResponseApiModel object if successful.
     */
    public ValueReadResponseApiModel getValue(String endpointId, String nodeId) {
        return getValueWithServiceResponseAsync(endpointId, nodeId).toBlocking().single().body();
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValueReadResponseApiModel> getValueAsync(String endpointId, String nodeId, final ServiceCallback<ValueReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getValueWithServiceResponseAsync(endpointId, nodeId), serviceCallback);
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ValueReadResponseApiModel> getValueAsync(String endpointId, String nodeId) {
        return getValueWithServiceResponseAsync(endpointId, nodeId).map(new Func1<ServiceResponse<ValueReadResponseApiModel>, ValueReadResponseApiModel>() {
            @Override
            public ValueReadResponseApiModel call(ServiceResponse<ValueReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ServiceResponse<ValueReadResponseApiModel>> getValueWithServiceResponseAsync(String endpointId, String nodeId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (nodeId == null) {
            throw new IllegalArgumentException("Parameter nodeId is required and cannot be null.");
        }
        return service.getValue(endpointId, nodeId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValueReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ValueReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValueReadResponseApiModel> clientResponse = getValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValueReadResponseApiModel> getValueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValueReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValueReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read node attributes.
     * Read attributes of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReadResponseApiModel object if successful.
     */
    public ReadResponseApiModel readAttributes(String endpointId, ReadRequestApiModel body) {
        return readAttributesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Read node attributes.
     * Read attributes of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReadResponseApiModel> readAttributesAsync(String endpointId, ReadRequestApiModel body, final ServiceCallback<ReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(readAttributesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Read node attributes.
     * Read attributes of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReadResponseApiModel object
     */
    public Observable<ReadResponseApiModel> readAttributesAsync(String endpointId, ReadRequestApiModel body) {
        return readAttributesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<ReadResponseApiModel>, ReadResponseApiModel>() {
            @Override
            public ReadResponseApiModel call(ServiceResponse<ReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read node attributes.
     * Read attributes of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReadResponseApiModel object
     */
    public Observable<ServiceResponse<ReadResponseApiModel>> readAttributesWithServiceResponseAsync(String endpointId, ReadRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.readAttributes(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReadResponseApiModel> clientResponse = readAttributesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReadResponseApiModel> readAttributesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Write variable value.
     * Write variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The write value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValueWriteResponseApiModel object if successful.
     */
    public ValueWriteResponseApiModel writeValue(String endpointId, ValueWriteRequestApiModel body) {
        return writeValueWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Write variable value.
     * Write variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The write value request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValueWriteResponseApiModel> writeValueAsync(String endpointId, ValueWriteRequestApiModel body, final ServiceCallback<ValueWriteResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(writeValueWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Write variable value.
     * Write variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The write value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueWriteResponseApiModel object
     */
    public Observable<ValueWriteResponseApiModel> writeValueAsync(String endpointId, ValueWriteRequestApiModel body) {
        return writeValueWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<ValueWriteResponseApiModel>, ValueWriteResponseApiModel>() {
            @Override
            public ValueWriteResponseApiModel call(ServiceResponse<ValueWriteResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Write variable value.
     * Write variable node's value. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The write value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueWriteResponseApiModel object
     */
    public Observable<ServiceResponse<ValueWriteResponseApiModel>> writeValueWithServiceResponseAsync(String endpointId, ValueWriteRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.writeValue(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValueWriteResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ValueWriteResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValueWriteResponseApiModel> clientResponse = writeValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValueWriteResponseApiModel> writeValueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValueWriteResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValueWriteResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Write node attributes.
     * Write any attribute of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The batch write request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WriteResponseApiModel object if successful.
     */
    public WriteResponseApiModel writeAttributes(String endpointId, WriteRequestApiModel body) {
        return writeAttributesWithServiceResponseAsync(endpointId, body).toBlocking().single().body();
    }

    /**
     * Write node attributes.
     * Write any attribute of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The batch write request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WriteResponseApiModel> writeAttributesAsync(String endpointId, WriteRequestApiModel body, final ServiceCallback<WriteResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(writeAttributesWithServiceResponseAsync(endpointId, body), serviceCallback);
    }

    /**
     * Write node attributes.
     * Write any attribute of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The batch write request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WriteResponseApiModel object
     */
    public Observable<WriteResponseApiModel> writeAttributesAsync(String endpointId, WriteRequestApiModel body) {
        return writeAttributesWithServiceResponseAsync(endpointId, body).map(new Func1<ServiceResponse<WriteResponseApiModel>, WriteResponseApiModel>() {
            @Override
            public WriteResponseApiModel call(ServiceResponse<WriteResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Write node attributes.
     * Write any attribute of a node. The endpoint must be activated and connected and the module client and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param body The batch write request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WriteResponseApiModel object
     */
    public Observable<ServiceResponse<WriteResponseApiModel>> writeAttributesWithServiceResponseAsync(String endpointId, WriteRequestApiModel body) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.writeAttributes(endpointId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WriteResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<WriteResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WriteResponseApiModel> clientResponse = writeAttributesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WriteResponseApiModel> writeAttributesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<WriteResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WriteResponseApiModel>() { }.getType())
                .build(response);
    }

}
