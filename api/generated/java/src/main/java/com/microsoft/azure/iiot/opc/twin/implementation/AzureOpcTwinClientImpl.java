/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.iiot.opc.twin.implementation;

import com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.iiot.opc.twin.models.BrowseNextRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowseNextResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowsePathRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowsePathResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowseRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.BrowseResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodCallRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodCallResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodMetadataRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.MethodMetadataResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ReadRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ReadResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.StatusResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueReadRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueReadResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueWriteRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.ValueWriteResponseApiModel;
import com.microsoft.azure.iiot.opc.twin.models.WriteRequestApiModel;
import com.microsoft.azure.iiot.opc.twin.models.WriteResponseApiModel;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AzureOpcTwinClient class.
 */
public class AzureOpcTwinClientImpl extends ServiceClient implements AzureOpcTwinClient {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AzureOpcTwinClientService service;

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     */
    public AzureOpcTwinClientImpl() {
        this("https:///twin");
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param baseUrl the base URL of the host
     */
    public AzureOpcTwinClientImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcTwinClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https:///twin", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcTwinClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcTwinClient client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AzureOpcTwinClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AzureOpcTwinClientService.class);
    }

    /**
     * The interface defining all the services for AzureOpcTwinClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AzureOpcTwinClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getSetOfUniqueNodes" })
        @GET("v2/browse/{endpointId}")
        Observable<Response<ResponseBody>> getSetOfUniqueNodes(@Path("endpointId") String endpointId, @Query("nodeId") String nodeId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient browse" })
        @POST("v2/browse/{endpointId}")
        Observable<Response<ResponseBody>> browse(@Path("endpointId") String endpointId, @Body BrowseRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getNextSetOfUniqueNodes" })
        @GET("v2/browse/{endpointId}/next")
        Observable<Response<ResponseBody>> getNextSetOfUniqueNodes(@Path("endpointId") String endpointId, @Query("continuationToken") String continuationToken);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient browseNext" })
        @POST("v2/browse/{endpointId}/next")
        Observable<Response<ResponseBody>> browseNext(@Path("endpointId") String endpointId, @Body BrowseNextRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient browseUsingPath" })
        @POST("v2/browse/{endpointId}/path")
        Observable<Response<ResponseBody>> browseUsingPath(@Path("endpointId") String endpointId, @Body BrowsePathRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getCallMetadata" })
        @POST("v2/call/{endpointId}/metadata")
        Observable<Response<ResponseBody>> getCallMetadata(@Path("endpointId") String endpointId, @Body MethodMetadataRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient callMethod" })
        @POST("v2/call/{endpointId}")
        Observable<Response<ResponseBody>> callMethod(@Path("endpointId") String endpointId, @Body MethodCallRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getValue" })
        @GET("v2/read/{endpointId}")
        Observable<Response<ResponseBody>> getValue(@Path("endpointId") String endpointId, @Query("nodeId") String nodeId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient readValue" })
        @POST("v2/read/{endpointId}")
        Observable<Response<ResponseBody>> readValue(@Path("endpointId") String endpointId, @Body ValueReadRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient readAttributes" })
        @POST("v2/read/{endpointId}/attributes")
        Observable<Response<ResponseBody>> readAttributes(@Path("endpointId") String endpointId, @Body ReadRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient getStatus" })
        @GET("v2/status")
        Observable<Response<ResponseBody>> getStatus();

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient writeValue" })
        @POST("v2/write/{endpointId}")
        Observable<Response<ResponseBody>> writeValue(@Path("endpointId") String endpointId, @Body ValueWriteRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.twin.AzureOpcTwinClient writeAttributes" })
        @POST("v2/write/{endpointId}/attributes")
        Observable<Response<ResponseBody>> writeAttributes(@Path("endpointId") String endpointId, @Body WriteRequestApiModel request);

    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseResponseApiModel object if successful.
     */
    public BrowseResponseApiModel getSetOfUniqueNodes(String endpointId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId, final ServiceCallback<BrowseResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSetOfUniqueNodesWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponse<BrowseResponseApiModel>, BrowseResponseApiModel>() {
            @Override
            public BrowseResponseApiModel call(ServiceResponse<BrowseResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseResponseApiModel>> getSetOfUniqueNodesWithServiceResponseAsync(String endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        final String nodeId = null;
        return service.getSetOfUniqueNodes(endpointId, nodeId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseResponseApiModel> clientResponse = getSetOfUniqueNodesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseResponseApiModel object if successful.
     */
    public BrowseResponseApiModel getSetOfUniqueNodes(String endpointId, String nodeId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId, nodeId).toBlocking().single().body();
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId, String nodeId, final ServiceCallback<BrowseResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSetOfUniqueNodesWithServiceResponseAsync(endpointId, nodeId), serviceCallback);
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<BrowseResponseApiModel> getSetOfUniqueNodesAsync(String endpointId, String nodeId) {
        return getSetOfUniqueNodesWithServiceResponseAsync(endpointId, nodeId).map(new Func1<ServiceResponse<BrowseResponseApiModel>, BrowseResponseApiModel>() {
            @Override
            public BrowseResponseApiModel call(ServiceResponse<BrowseResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse set of unique target nodes.
     * Browse the set of unique hierarchically referenced target nodes on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     The root node id to browse from can be provided as part of the query
     parameters.
     If it is not provided, the RootFolder node is browsed. Note that this
     is the same as the POST method with the model containing the node id
     and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to browse or omit to browse the root node (i=84)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseResponseApiModel>> getSetOfUniqueNodesWithServiceResponseAsync(String endpointId, String nodeId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.getSetOfUniqueNodes(endpointId, nodeId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseResponseApiModel> clientResponse = getSetOfUniqueNodesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseResponseApiModel> getSetOfUniqueNodesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseResponseApiModel object if successful.
     */
    public BrowseResponseApiModel browse(String endpointId, BrowseRequestApiModel request) {
        return browseWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseResponseApiModel> browseAsync(String endpointId, BrowseRequestApiModel request, final ServiceCallback<BrowseResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(browseWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<BrowseResponseApiModel> browseAsync(String endpointId, BrowseRequestApiModel request) {
        return browseWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<BrowseResponseApiModel>, BrowseResponseApiModel>() {
            @Override
            public BrowseResponseApiModel call(ServiceResponse<BrowseResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse node references.
     * Browse a node on the specified endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseResponseApiModel>> browseWithServiceResponseAsync(String endpointId, BrowseRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.browse(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseResponseApiModel> clientResponse = browseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseResponseApiModel> browseDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the
     endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     Note that this is the same as the POST method with the model containing
     the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseNextResponseApiModel object if successful.
     */
    public BrowseNextResponseApiModel getNextSetOfUniqueNodes(String endpointId, String continuationToken) {
        return getNextSetOfUniqueNodesWithServiceResponseAsync(endpointId, continuationToken).toBlocking().single().body();
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the
     endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     Note that this is the same as the POST method with the model containing
     the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseNextResponseApiModel> getNextSetOfUniqueNodesAsync(String endpointId, String continuationToken, final ServiceCallback<BrowseNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getNextSetOfUniqueNodesWithServiceResponseAsync(endpointId, continuationToken), serviceCallback);
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the
     endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     Note that this is the same as the POST method with the model containing
     the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<BrowseNextResponseApiModel> getNextSetOfUniqueNodesAsync(String endpointId, String continuationToken) {
        return getNextSetOfUniqueNodesWithServiceResponseAsync(endpointId, continuationToken).map(new Func1<ServiceResponse<BrowseNextResponseApiModel>, BrowseNextResponseApiModel>() {
            @Override
            public BrowseNextResponseApiModel call(ServiceResponse<BrowseNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse next set of unique target nodes.
     * Browse the next set of unique hierarchically referenced target nodes on the
     endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     Note that this is the same as the POST method with the model containing
     the continuation token and the targetNodesOnly flag set to true.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param continuationToken Continuation token from GetSetOfUniqueNodes operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseNextResponseApiModel>> getNextSetOfUniqueNodesWithServiceResponseAsync(String endpointId, String continuationToken) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (continuationToken == null) {
            throw new IllegalArgumentException("Parameter continuationToken is required and cannot be null.");
        }
        return service.getNextSetOfUniqueNodes(endpointId, continuationToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseNextResponseApiModel> clientResponse = getNextSetOfUniqueNodesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseNextResponseApiModel> getNextSetOfUniqueNodesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The request body with continuation token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowseNextResponseApiModel object if successful.
     */
    public BrowseNextResponseApiModel browseNext(String endpointId, BrowseNextRequestApiModel request) {
        return browseNextWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The request body with continuation token.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowseNextResponseApiModel> browseNextAsync(String endpointId, BrowseNextRequestApiModel request, final ServiceCallback<BrowseNextResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(browseNextWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The request body with continuation token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<BrowseNextResponseApiModel> browseNextAsync(String endpointId, BrowseNextRequestApiModel request) {
        return browseNextWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<BrowseNextResponseApiModel>, BrowseNextResponseApiModel>() {
            @Override
            public BrowseNextResponseApiModel call(ServiceResponse<BrowseNextResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse next set of references.
     * Browse next set of references on the endpoint.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The request body with continuation token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowseNextResponseApiModel object
     */
    public Observable<ServiceResponse<BrowseNextResponseApiModel>> browseNextWithServiceResponseAsync(String endpointId, BrowseNextRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.browseNext(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowseNextResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowseNextResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowseNextResponseApiModel> clientResponse = browseNextDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowseNextResponseApiModel> browseNextDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowseNextResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowseNextResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id.
     This call uses TranslateBrowsePathsToNodeIds service under the hood.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse path request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BrowsePathResponseApiModel object if successful.
     */
    public BrowsePathResponseApiModel browseUsingPath(String endpointId, BrowsePathRequestApiModel request) {
        return browseUsingPathWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id.
     This call uses TranslateBrowsePathsToNodeIds service under the hood.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse path request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BrowsePathResponseApiModel> browseUsingPathAsync(String endpointId, BrowsePathRequestApiModel request, final ServiceCallback<BrowsePathResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(browseUsingPathWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id.
     This call uses TranslateBrowsePathsToNodeIds service under the hood.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse path request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowsePathResponseApiModel object
     */
    public Observable<BrowsePathResponseApiModel> browseUsingPathAsync(String endpointId, BrowsePathRequestApiModel request) {
        return browseUsingPathWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<BrowsePathResponseApiModel>, BrowsePathResponseApiModel>() {
            @Override
            public BrowsePathResponseApiModel call(ServiceResponse<BrowsePathResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Browse using a browse path.
     * Browse using a path from the specified node id.
     This call uses TranslateBrowsePathsToNodeIds service under the hood.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The browse path request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BrowsePathResponseApiModel object
     */
    public Observable<ServiceResponse<BrowsePathResponseApiModel>> browseUsingPathWithServiceResponseAsync(String endpointId, BrowsePathRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.browseUsingPath(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BrowsePathResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<BrowsePathResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BrowsePathResponseApiModel> clientResponse = browseUsingPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BrowsePathResponseApiModel> browseUsingPathDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BrowsePathResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BrowsePathResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to
     input and output arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method metadata request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MethodMetadataResponseApiModel object if successful.
     */
    public MethodMetadataResponseApiModel getCallMetadata(String endpointId, MethodMetadataRequestApiModel request) {
        return getCallMetadataWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to
     input and output arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method metadata request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MethodMetadataResponseApiModel> getCallMetadataAsync(String endpointId, MethodMetadataRequestApiModel request, final ServiceCallback<MethodMetadataResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getCallMetadataWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to
     input and output arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method metadata request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodMetadataResponseApiModel object
     */
    public Observable<MethodMetadataResponseApiModel> getCallMetadataAsync(String endpointId, MethodMetadataRequestApiModel request) {
        return getCallMetadataWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<MethodMetadataResponseApiModel>, MethodMetadataResponseApiModel>() {
            @Override
            public MethodMetadataResponseApiModel call(ServiceResponse<MethodMetadataResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get method meta data.
     * Return method meta data to support a user interface displaying forms to
     input and output arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method metadata request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodMetadataResponseApiModel object
     */
    public Observable<ServiceResponse<MethodMetadataResponseApiModel>> getCallMetadataWithServiceResponseAsync(String endpointId, MethodMetadataRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.getCallMetadata(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MethodMetadataResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<MethodMetadataResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MethodMetadataResponseApiModel> clientResponse = getCallMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MethodMetadataResponseApiModel> getCallMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<MethodMetadataResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MethodMetadataResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method call request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MethodCallResponseApiModel object if successful.
     */
    public MethodCallResponseApiModel callMethod(String endpointId, MethodCallRequestApiModel request) {
        return callMethodWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method call request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MethodCallResponseApiModel> callMethodAsync(String endpointId, MethodCallRequestApiModel request, final ServiceCallback<MethodCallResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(callMethodWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method call request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodCallResponseApiModel object
     */
    public Observable<MethodCallResponseApiModel> callMethodAsync(String endpointId, MethodCallRequestApiModel request) {
        return callMethodWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<MethodCallResponseApiModel>, MethodCallResponseApiModel>() {
            @Override
            public MethodCallResponseApiModel call(ServiceResponse<MethodCallResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Call a method.
     * Invoke method node with specified input arguments.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The method call request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MethodCallResponseApiModel object
     */
    public Observable<ServiceResponse<MethodCallResponseApiModel>> callMethodWithServiceResponseAsync(String endpointId, MethodCallRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.callMethod(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MethodCallResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<MethodCallResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MethodCallResponseApiModel> clientResponse = callMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MethodCallResponseApiModel> callMethodDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<MethodCallResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MethodCallResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValueReadResponseApiModel object if successful.
     */
    public ValueReadResponseApiModel getValue(String endpointId, String nodeId) {
        return getValueWithServiceResponseAsync(endpointId, nodeId).toBlocking().single().body();
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValueReadResponseApiModel> getValueAsync(String endpointId, String nodeId, final ServiceCallback<ValueReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getValueWithServiceResponseAsync(endpointId, nodeId), serviceCallback);
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ValueReadResponseApiModel> getValueAsync(String endpointId, String nodeId) {
        return getValueWithServiceResponseAsync(endpointId, nodeId).map(new Func1<ServiceResponse<ValueReadResponseApiModel>, ValueReadResponseApiModel>() {
            @Override
            public ValueReadResponseApiModel call(ServiceResponse<ValueReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get variable value.
     * Get a variable node's value using its node id.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param nodeId The node to read
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ServiceResponse<ValueReadResponseApiModel>> getValueWithServiceResponseAsync(String endpointId, String nodeId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (nodeId == null) {
            throw new IllegalArgumentException("Parameter nodeId is required and cannot be null.");
        }
        return service.getValue(endpointId, nodeId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValueReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ValueReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValueReadResponseApiModel> clientResponse = getValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValueReadResponseApiModel> getValueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValueReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValueReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read variable value.
     * Read a variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValueReadResponseApiModel object if successful.
     */
    public ValueReadResponseApiModel readValue(String endpointId, ValueReadRequestApiModel request) {
        return readValueWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read variable value.
     * Read a variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read value request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValueReadResponseApiModel> readValueAsync(String endpointId, ValueReadRequestApiModel request, final ServiceCallback<ValueReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(readValueWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read variable value.
     * Read a variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ValueReadResponseApiModel> readValueAsync(String endpointId, ValueReadRequestApiModel request) {
        return readValueWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<ValueReadResponseApiModel>, ValueReadResponseApiModel>() {
            @Override
            public ValueReadResponseApiModel call(ServiceResponse<ValueReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read variable value.
     * Read a variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueReadResponseApiModel object
     */
    public Observable<ServiceResponse<ValueReadResponseApiModel>> readValueWithServiceResponseAsync(String endpointId, ValueReadRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.readValue(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValueReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ValueReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValueReadResponseApiModel> clientResponse = readValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValueReadResponseApiModel> readValueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValueReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValueReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Read node attributes.
     * Read attributes of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReadResponseApiModel object if successful.
     */
    public ReadResponseApiModel readAttributes(String endpointId, ReadRequestApiModel request) {
        return readAttributesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Read node attributes.
     * Read attributes of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReadResponseApiModel> readAttributesAsync(String endpointId, ReadRequestApiModel request, final ServiceCallback<ReadResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(readAttributesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Read node attributes.
     * Read attributes of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReadResponseApiModel object
     */
    public Observable<ReadResponseApiModel> readAttributesAsync(String endpointId, ReadRequestApiModel request) {
        return readAttributesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<ReadResponseApiModel>, ReadResponseApiModel>() {
            @Override
            public ReadResponseApiModel call(ServiceResponse<ReadResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Read node attributes.
     * Read attributes of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The read request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReadResponseApiModel object
     */
    public Observable<ServiceResponse<ReadResponseApiModel>> readAttributesWithServiceResponseAsync(String endpointId, ReadRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.readAttributes(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReadResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ReadResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReadResponseApiModel> clientResponse = readAttributesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReadResponseApiModel> readAttributesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ReadResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ReadResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StatusResponseApiModel object if successful.
     */
    public StatusResponseApiModel getStatus() {
        return getStatusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StatusResponseApiModel> getStatusAsync(final ServiceCallback<StatusResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getStatusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<StatusResponseApiModel> getStatusAsync() {
        return getStatusWithServiceResponseAsync().map(new Func1<ServiceResponse<StatusResponseApiModel>, StatusResponseApiModel>() {
            @Override
            public StatusResponseApiModel call(ServiceResponse<StatusResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<ServiceResponse<StatusResponseApiModel>> getStatusWithServiceResponseAsync() {
        return service.getStatus()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StatusResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<StatusResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StatusResponseApiModel> clientResponse = getStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StatusResponseApiModel> getStatusDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<StatusResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StatusResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Write variable value.
     * Write variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The write value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ValueWriteResponseApiModel object if successful.
     */
    public ValueWriteResponseApiModel writeValue(String endpointId, ValueWriteRequestApiModel request) {
        return writeValueWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Write variable value.
     * Write variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The write value request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ValueWriteResponseApiModel> writeValueAsync(String endpointId, ValueWriteRequestApiModel request, final ServiceCallback<ValueWriteResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(writeValueWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Write variable value.
     * Write variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The write value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueWriteResponseApiModel object
     */
    public Observable<ValueWriteResponseApiModel> writeValueAsync(String endpointId, ValueWriteRequestApiModel request) {
        return writeValueWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<ValueWriteResponseApiModel>, ValueWriteResponseApiModel>() {
            @Override
            public ValueWriteResponseApiModel call(ServiceResponse<ValueWriteResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Write variable value.
     * Write variable node's value.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The write value request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ValueWriteResponseApiModel object
     */
    public Observable<ServiceResponse<ValueWriteResponseApiModel>> writeValueWithServiceResponseAsync(String endpointId, ValueWriteRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.writeValue(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValueWriteResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ValueWriteResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValueWriteResponseApiModel> clientResponse = writeValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValueWriteResponseApiModel> writeValueDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValueWriteResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValueWriteResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Write node attributes.
     * Write any attribute of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The batch write request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WriteResponseApiModel object if successful.
     */
    public WriteResponseApiModel writeAttributes(String endpointId, WriteRequestApiModel request) {
        return writeAttributesWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Write node attributes.
     * Write any attribute of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The batch write request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WriteResponseApiModel> writeAttributesAsync(String endpointId, WriteRequestApiModel request, final ServiceCallback<WriteResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(writeAttributesWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Write node attributes.
     * Write any attribute of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The batch write request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WriteResponseApiModel object
     */
    public Observable<WriteResponseApiModel> writeAttributesAsync(String endpointId, WriteRequestApiModel request) {
        return writeAttributesWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<WriteResponseApiModel>, WriteResponseApiModel>() {
            @Override
            public WriteResponseApiModel call(ServiceResponse<WriteResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Write node attributes.
     * Write any attribute of a node.
     The endpoint must be activated and connected and the module client
     and server must trust each other.
     *
     * @param endpointId The identifier of the activated endpoint.
     * @param request The batch write request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WriteResponseApiModel object
     */
    public Observable<ServiceResponse<WriteResponseApiModel>> writeAttributesWithServiceResponseAsync(String endpointId, WriteRequestApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.writeAttributes(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WriteResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<WriteResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WriteResponseApiModel> clientResponse = writeAttributesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WriteResponseApiModel> writeAttributesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<WriteResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WriteResponseApiModel>() { }.getType())
                .build(response);
    }

}
