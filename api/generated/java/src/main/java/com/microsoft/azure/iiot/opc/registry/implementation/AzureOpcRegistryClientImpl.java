/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.iiot.opc.registry.implementation;

import com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationInfoListApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRecordListApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRecordQueryApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRegistrationApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRegistrationQueryApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRegistrationRequestApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRegistrationResponseApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationRegistrationUpdateApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ApplicationSiteListApiModel;
import com.microsoft.azure.iiot.opc.registry.models.DiscoveryRequestApiModel;
import com.microsoft.azure.iiot.opc.registry.models.EndpointInfoApiModel;
import com.microsoft.azure.iiot.opc.registry.models.EndpointInfoListApiModel;
import com.microsoft.azure.iiot.opc.registry.models.EndpointRegistrationQueryApiModel;
import com.microsoft.azure.iiot.opc.registry.models.EndpointRegistrationUpdateApiModel;
import com.microsoft.azure.iiot.opc.registry.models.ServerRegistrationRequestApiModel;
import com.microsoft.azure.iiot.opc.registry.models.StatusResponseApiModel;
import com.microsoft.azure.iiot.opc.registry.models.SupervisorApiModel;
import com.microsoft.azure.iiot.opc.registry.models.SupervisorListApiModel;
import com.microsoft.azure.iiot.opc.registry.models.SupervisorQueryApiModel;
import com.microsoft.azure.iiot.opc.registry.models.SupervisorStatusApiModel;
import com.microsoft.azure.iiot.opc.registry.models.SupervisorUpdateApiModel;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import org.apache.commons.codec.binary.Base64;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AzureOpcRegistryClient class.
 */
public class AzureOpcRegistryClientImpl extends ServiceClient implements AzureOpcRegistryClient {
    /**
     * The Retrofit service to perform REST calls.
     */
    private AzureOpcRegistryClientService service;

    /**
     * Initializes an instance of AzureOpcRegistryClient client.
     */
    public AzureOpcRegistryClientImpl() {
        this("http://localhost");
    }

    /**
     * Initializes an instance of AzureOpcRegistryClient client.
     *
     * @param baseUrl the base URL of the host
     */
    public AzureOpcRegistryClientImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcRegistryClient client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcRegistryClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://localhost", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcRegistryClient client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public AzureOpcRegistryClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of AzureOpcRegistryClient client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public AzureOpcRegistryClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(AzureOpcRegistryClientService.class);
    }

    /**
     * The interface defining all the services for AzureOpcRegistryClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AzureOpcRegistryClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getListOfApplications" })
        @GET("v2/applications")
        Observable<Response<ResponseBody>> getListOfApplications(@Query("continuationToken") String continuationToken, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient createApplication" })
        @PUT("v2/applications")
        Observable<Response<ResponseBody>> createApplication(@Body ApplicationRegistrationRequestApiModel request);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient registerServer" })
        @POST("v2/applications")
        Observable<Response<ResponseBody>> registerServer(@Body ServerRegistrationRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient deleteAllDisabledApplications" })
        @HTTP(path = "v2/applications", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAllDisabledApplications(@Query("notSeenFor") String notSeenFor);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient disableApplication" })
        @POST("v2/applications/{applicationId}/disable")
        Observable<Response<ResponseBody>> disableApplication(@Path("applicationId") String applicationId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient enableApplication" })
        @POST("v2/applications/{applicationId}/enable")
        Observable<Response<ResponseBody>> enableApplication(@Path("applicationId") String applicationId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient discoverServer" })
        @POST("v2/applications/discover")
        Observable<Response<ResponseBody>> discoverServer(@Body DiscoveryRequestApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getApplicationRegistration" })
        @GET("v2/applications/{applicationId}")
        Observable<Response<ResponseBody>> getApplicationRegistration(@Path("applicationId") String applicationId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient deleteApplication" })
        @HTTP(path = "v2/applications/{applicationId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteApplication(@Path("applicationId") String applicationId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient updateApplicationRegistration" })
        @PATCH("v2/applications/{applicationId}")
        Observable<Response<ResponseBody>> updateApplicationRegistration(@Path("applicationId") String applicationId, @Body ApplicationRegistrationUpdateApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getListOfSites" })
        @GET("v2/applications/sites")
        Observable<Response<ResponseBody>> getListOfSites(@Query("continuationToken") String continuationToken, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getFilteredListOfApplications" })
        @GET("v2/applications/query")
        Observable<Response<ResponseBody>> getFilteredListOfApplications(@Body ApplicationRegistrationQueryApiModel query, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient queryApplications" })
        @POST("v2/applications/query")
        Observable<Response<ResponseBody>> queryApplications(@Body ApplicationRegistrationQueryApiModel query, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient queryApplicationsById" })
        @POST("v2/applications/querybyid")
        Observable<Response<ResponseBody>> queryApplicationsById(@Body ApplicationRecordQueryApiModel query);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient activateEndpoint" })
        @POST("v2/endpoints/{endpointId}/activate")
        Observable<Response<ResponseBody>> activateEndpoint(@Path("endpointId") String endpointId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getEndpoint" })
        @GET("v2/endpoints/{endpointId}")
        Observable<Response<ResponseBody>> getEndpoint(@Path("endpointId") String endpointId, @Query("onlyServerState") Boolean onlyServerState);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient updateEndpoint" })
        @PATCH("v2/endpoints/{endpointId}")
        Observable<Response<ResponseBody>> updateEndpoint(@Path("endpointId") String endpointId, @Body EndpointRegistrationUpdateApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getListOfEndpoints" })
        @GET("v2/endpoints")
        Observable<Response<ResponseBody>> getListOfEndpoints(@Query("onlyServerState") Boolean onlyServerState, @Query("continuationToken") String continuationToken, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getFilteredListOfEndpoints" })
        @GET("v2/endpoints/query")
        Observable<Response<ResponseBody>> getFilteredListOfEndpoints(@Query("Url") String url, @Query("UserAuthentication") String userAuthentication, @Query("Certificate") String certificate, @Query("SecurityMode") String securityMode, @Query("SecurityPolicy") String securityPolicy, @Query("Activated") Boolean activated, @Query("Connected") Boolean connected, @Query("EndpointState") String endpointState, @Query("IncludeNotSeenSince") Boolean includeNotSeenSince, @Query("onlyServerState") Boolean onlyServerState, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient queryEndpoints" })
        @POST("v2/endpoints/query")
        Observable<Response<ResponseBody>> queryEndpoints(@Body EndpointRegistrationQueryApiModel query, @Query("onlyServerState") Boolean onlyServerState, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient deactivateEndpoint" })
        @POST("v2/endpoints/{endpointId}/deactivate")
        Observable<Response<ResponseBody>> deactivateEndpoint(@Path("endpointId") String endpointId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getStatus" })
        @GET("v2/status")
        Observable<Response<ResponseBody>> getStatus();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getSupervisor" })
        @GET("v2/supervisors/{supervisorId}")
        Observable<Response<ResponseBody>> getSupervisor(@Path("supervisorId") String supervisorId, @Query("onlyServerState") Boolean onlyServerState);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient updateSupervisor" })
        @PATCH("v2/supervisors/{supervisorId}")
        Observable<Response<ResponseBody>> updateSupervisor(@Path("supervisorId") String supervisorId, @Body SupervisorUpdateApiModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getSupervisorStatus" })
        @GET("v2/supervisors/{supervisorId}/status")
        Observable<Response<ResponseBody>> getSupervisorStatus(@Path("supervisorId") String supervisorId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient resetSupervisor" })
        @POST("v2/supervisors/{supervisorId}/reset")
        Observable<Response<ResponseBody>> resetSupervisor(@Path("supervisorId") String supervisorId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getListOfSupervisors" })
        @GET("v2/supervisors")
        Observable<Response<ResponseBody>> getListOfSupervisors(@Query("onlyServerState") Boolean onlyServerState, @Query("continuationToken") String continuationToken, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient getFilteredListOfSupervisors" })
        @GET("v2/supervisors/query")
        Observable<Response<ResponseBody>> getFilteredListOfSupervisors(@Query("SiteId") String siteId, @Query("Discovery") String discovery, @Query("Connected") Boolean connected, @Query("onlyServerState") Boolean onlyServerState, @Query("pageSize") Integer pageSize);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.iiot.opc.registry.AzureOpcRegistryClient querySupervisors" })
        @POST("v2/supervisors/query")
        Observable<Response<ResponseBody>> querySupervisors(@Body SupervisorQueryApiModel query, @Query("onlyServerState") Boolean onlyServerState, @Query("pageSize") Integer pageSize);

    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoListApiModel object if successful.
     */
    public ApplicationInfoListApiModel getListOfApplications() {
        return getListOfApplicationsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoListApiModel> getListOfApplicationsAsync(final ServiceCallback<ApplicationInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfApplicationsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ApplicationInfoListApiModel> getListOfApplicationsAsync() {
        return getListOfApplicationsWithServiceResponseAsync().map(new Func1<ServiceResponse<ApplicationInfoListApiModel>, ApplicationInfoListApiModel>() {
            @Override
            public ApplicationInfoListApiModel call(ServiceResponse<ApplicationInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ServiceResponse<ApplicationInfoListApiModel>> getListOfApplicationsWithServiceResponseAsync() {
        final String continuationToken = null;
        final Integer pageSize = null;
        return service.getListOfApplications(continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoListApiModel> clientResponse = getListOfApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoListApiModel object if successful.
     */
    public ApplicationInfoListApiModel getListOfApplications(String continuationToken, Integer pageSize) {
        return getListOfApplicationsWithServiceResponseAsync(continuationToken, pageSize).toBlocking().single().body();
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoListApiModel> getListOfApplicationsAsync(String continuationToken, Integer pageSize, final ServiceCallback<ApplicationInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfApplicationsWithServiceResponseAsync(continuationToken, pageSize), serviceCallback);
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ApplicationInfoListApiModel> getListOfApplicationsAsync(String continuationToken, Integer pageSize) {
        return getListOfApplicationsWithServiceResponseAsync(continuationToken, pageSize).map(new Func1<ServiceResponse<ApplicationInfoListApiModel>, ApplicationInfoListApiModel>() {
            @Override
            public ApplicationInfoListApiModel call(ServiceResponse<ApplicationInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of applications.
     * Get all registered applications in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ServiceResponse<ApplicationInfoListApiModel>> getListOfApplicationsWithServiceResponseAsync(String continuationToken, Integer pageSize) {
        return service.getListOfApplications(continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoListApiModel> clientResponse = getListOfApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationInfoListApiModel> getListOfApplicationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<ApplicationInfoListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationInfoListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Create new application.
     * The application is registered using the provided information, but it
     is not associated with a supervisor.  This is useful for when you need
     to register clients or you want to register a server that is located
     in a network not reachable through a Twin module.
     *
     * @param request Application registration request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationRegistrationResponseApiModel object if successful.
     */
    public ApplicationRegistrationResponseApiModel createApplication(ApplicationRegistrationRequestApiModel request) {
        return createApplicationWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Create new application.
     * The application is registered using the provided information, but it
     is not associated with a supervisor.  This is useful for when you need
     to register clients or you want to register a server that is located
     in a network not reachable through a Twin module.
     *
     * @param request Application registration request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationRegistrationResponseApiModel> createApplicationAsync(ApplicationRegistrationRequestApiModel request, final ServiceCallback<ApplicationRegistrationResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(createApplicationWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Create new application.
     * The application is registered using the provided information, but it
     is not associated with a supervisor.  This is useful for when you need
     to register clients or you want to register a server that is located
     in a network not reachable through a Twin module.
     *
     * @param request Application registration request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRegistrationResponseApiModel object
     */
    public Observable<ApplicationRegistrationResponseApiModel> createApplicationAsync(ApplicationRegistrationRequestApiModel request) {
        return createApplicationWithServiceResponseAsync(request).map(new Func1<ServiceResponse<ApplicationRegistrationResponseApiModel>, ApplicationRegistrationResponseApiModel>() {
            @Override
            public ApplicationRegistrationResponseApiModel call(ServiceResponse<ApplicationRegistrationResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Create new application.
     * The application is registered using the provided information, but it
     is not associated with a supervisor.  This is useful for when you need
     to register clients or you want to register a server that is located
     in a network not reachable through a Twin module.
     *
     * @param request Application registration request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRegistrationResponseApiModel object
     */
    public Observable<ServiceResponse<ApplicationRegistrationResponseApiModel>> createApplicationWithServiceResponseAsync(ApplicationRegistrationRequestApiModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.createApplication(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationRegistrationResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationRegistrationResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationRegistrationResponseApiModel> clientResponse = createApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationRegistrationResponseApiModel> createApplicationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationRegistrationResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationRegistrationResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Register new server.
     * Registers a server solely using a discovery url. Requires that
     the onboarding agent service is running and the server can be
     located by a supervisor in its network using the discovery url.
     *
     * @param request Server registration request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void registerServer(ServerRegistrationRequestApiModel request) {
        registerServerWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Register new server.
     * Registers a server solely using a discovery url. Requires that
     the onboarding agent service is running and the server can be
     located by a supervisor in its network using the discovery url.
     *
     * @param request Server registration request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> registerServerAsync(ServerRegistrationRequestApiModel request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(registerServerWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Register new server.
     * Registers a server solely using a discovery url. Requires that
     the onboarding agent service is running and the server can be
     located by a supervisor in its network using the discovery url.
     *
     * @param request Server registration request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> registerServerAsync(ServerRegistrationRequestApiModel request) {
        return registerServerWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Register new server.
     * Registers a server solely using a discovery url. Requires that
     the onboarding agent service is running and the server can be
     located by a supervisor in its network using the discovery url.
     *
     * @param request Server registration request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> registerServerWithServiceResponseAsync(ServerRegistrationRequestApiModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.registerServer(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = registerServerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> registerServerDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteAllDisabledApplications() {
        deleteAllDisabledApplicationsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAllDisabledApplicationsAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteAllDisabledApplicationsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAllDisabledApplicationsAsync() {
        return deleteAllDisabledApplicationsWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteAllDisabledApplicationsWithServiceResponseAsync() {
        final String notSeenFor = null;
        return service.deleteAllDisabledApplications(notSeenFor)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteAllDisabledApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @param notSeenFor A duration in milliseconds
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteAllDisabledApplications(String notSeenFor) {
        deleteAllDisabledApplicationsWithServiceResponseAsync(notSeenFor).toBlocking().single().body();
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @param notSeenFor A duration in milliseconds
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAllDisabledApplicationsAsync(String notSeenFor, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteAllDisabledApplicationsWithServiceResponseAsync(notSeenFor), serviceCallback);
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @param notSeenFor A duration in milliseconds
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAllDisabledApplicationsAsync(String notSeenFor) {
        return deleteAllDisabledApplicationsWithServiceResponseAsync(notSeenFor).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Purge applications.
     * Purges all applications that have not been seen for a specified amount of time.
     *
     * @param notSeenFor A duration in milliseconds
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteAllDisabledApplicationsWithServiceResponseAsync(String notSeenFor) {
        return service.deleteAllDisabledApplications(notSeenFor)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteAllDisabledApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteAllDisabledApplicationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Disable an enabled application.
     * A manager can disable an application.
     *
     * @param applicationId The application id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableApplication(String applicationId) {
        disableApplicationWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Disable an enabled application.
     * A manager can disable an application.
     *
     * @param applicationId The application id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableApplicationAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableApplicationWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Disable an enabled application.
     * A manager can disable an application.
     *
     * @param applicationId The application id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableApplicationAsync(String applicationId) {
        return disableApplicationWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disable an enabled application.
     * A manager can disable an application.
     *
     * @param applicationId The application id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableApplicationWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        return service.disableApplication(applicationId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> disableApplicationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Re-enable a disabled application.
     * A manager can enable an application.
     *
     * @param applicationId The application id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableApplication(String applicationId) {
        enableApplicationWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Re-enable a disabled application.
     * A manager can enable an application.
     *
     * @param applicationId The application id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableApplicationAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableApplicationWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Re-enable a disabled application.
     * A manager can enable an application.
     *
     * @param applicationId The application id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableApplicationAsync(String applicationId) {
        return enableApplicationWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Re-enable a disabled application.
     * A manager can enable an application.
     *
     * @param applicationId The application id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableApplicationWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        return service.enableApplication(applicationId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enableApplicationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Discover servers.
     * Registers servers by running a discovery scan in a supervisor's
     network. Requires that the onboarding agent service is running.
     *
     * @param request Discovery request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void discoverServer(DiscoveryRequestApiModel request) {
        discoverServerWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Discover servers.
     * Registers servers by running a discovery scan in a supervisor's
     network. Requires that the onboarding agent service is running.
     *
     * @param request Discovery request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> discoverServerAsync(DiscoveryRequestApiModel request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(discoverServerWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Discover servers.
     * Registers servers by running a discovery scan in a supervisor's
     network. Requires that the onboarding agent service is running.
     *
     * @param request Discovery request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> discoverServerAsync(DiscoveryRequestApiModel request) {
        return discoverServerWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Discover servers.
     * Registers servers by running a discovery scan in a supervisor's
     network. Requires that the onboarding agent service is running.
     *
     * @param request Discovery request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> discoverServerWithServiceResponseAsync(DiscoveryRequestApiModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.discoverServer(request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = discoverServerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> discoverServerDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get application registration.
     *
     * @param applicationId Application id for the server
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationRegistrationApiModel object if successful.
     */
    public ApplicationRegistrationApiModel getApplicationRegistration(String applicationId) {
        return getApplicationRegistrationWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Get application registration.
     *
     * @param applicationId Application id for the server
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationRegistrationApiModel> getApplicationRegistrationAsync(String applicationId, final ServiceCallback<ApplicationRegistrationApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationRegistrationWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Get application registration.
     *
     * @param applicationId Application id for the server
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRegistrationApiModel object
     */
    public Observable<ApplicationRegistrationApiModel> getApplicationRegistrationAsync(String applicationId) {
        return getApplicationRegistrationWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<ApplicationRegistrationApiModel>, ApplicationRegistrationApiModel>() {
            @Override
            public ApplicationRegistrationApiModel call(ServiceResponse<ApplicationRegistrationApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get application registration.
     *
     * @param applicationId Application id for the server
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRegistrationApiModel object
     */
    public Observable<ServiceResponse<ApplicationRegistrationApiModel>> getApplicationRegistrationWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        return service.getApplicationRegistration(applicationId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationRegistrationApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationRegistrationApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationRegistrationApiModel> clientResponse = getApplicationRegistrationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationRegistrationApiModel> getApplicationRegistrationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationRegistrationApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationRegistrationApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Unregister application.
     * Unregisters and deletes application and all its associated endpoints.
     *
     * @param applicationId The identifier of the application
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteApplication(String applicationId) {
        deleteApplicationWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Unregister application.
     * Unregisters and deletes application and all its associated endpoints.
     *
     * @param applicationId The identifier of the application
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteApplicationAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteApplicationWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Unregister application.
     * Unregisters and deletes application and all its associated endpoints.
     *
     * @param applicationId The identifier of the application
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteApplicationAsync(String applicationId) {
        return deleteApplicationWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Unregister application.
     * Unregisters and deletes application and all its associated endpoints.
     *
     * @param applicationId The identifier of the application
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteApplicationWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        return service.deleteApplication(applicationId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteApplicationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Update application registration.
     * The application information is updated with new properties.  Note that
     this information might be overridden if the application is re-discovered
     during a discovery run (recurring or one-time).
     *
     * @param applicationId The identifier of the application
     * @param request Application update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateApplicationRegistration(String applicationId, ApplicationRegistrationUpdateApiModel request) {
        updateApplicationRegistrationWithServiceResponseAsync(applicationId, request).toBlocking().single().body();
    }

    /**
     * Update application registration.
     * The application information is updated with new properties.  Note that
     this information might be overridden if the application is re-discovered
     during a discovery run (recurring or one-time).
     *
     * @param applicationId The identifier of the application
     * @param request Application update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateApplicationRegistrationAsync(String applicationId, ApplicationRegistrationUpdateApiModel request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationRegistrationWithServiceResponseAsync(applicationId, request), serviceCallback);
    }

    /**
     * Update application registration.
     * The application information is updated with new properties.  Note that
     this information might be overridden if the application is re-discovered
     during a discovery run (recurring or one-time).
     *
     * @param applicationId The identifier of the application
     * @param request Application update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateApplicationRegistrationAsync(String applicationId, ApplicationRegistrationUpdateApiModel request) {
        return updateApplicationRegistrationWithServiceResponseAsync(applicationId, request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update application registration.
     * The application information is updated with new properties.  Note that
     this information might be overridden if the application is re-discovered
     during a discovery run (recurring or one-time).
     *
     * @param applicationId The identifier of the application
     * @param request Application update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateApplicationRegistrationWithServiceResponseAsync(String applicationId, ApplicationRegistrationUpdateApiModel request) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateApplicationRegistration(applicationId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateApplicationRegistrationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateApplicationRegistrationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationSiteListApiModel object if successful.
     */
    public ApplicationSiteListApiModel getListOfSites() {
        return getListOfSitesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationSiteListApiModel> getListOfSitesAsync(final ServiceCallback<ApplicationSiteListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfSitesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationSiteListApiModel object
     */
    public Observable<ApplicationSiteListApiModel> getListOfSitesAsync() {
        return getListOfSitesWithServiceResponseAsync().map(new Func1<ServiceResponse<ApplicationSiteListApiModel>, ApplicationSiteListApiModel>() {
            @Override
            public ApplicationSiteListApiModel call(ServiceResponse<ApplicationSiteListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationSiteListApiModel object
     */
    public Observable<ServiceResponse<ApplicationSiteListApiModel>> getListOfSitesWithServiceResponseAsync() {
        final String continuationToken = null;
        final Integer pageSize = null;
        return service.getListOfSites(continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationSiteListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationSiteListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationSiteListApiModel> clientResponse = getListOfSitesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationSiteListApiModel object if successful.
     */
    public ApplicationSiteListApiModel getListOfSites(String continuationToken, Integer pageSize) {
        return getListOfSitesWithServiceResponseAsync(continuationToken, pageSize).toBlocking().single().body();
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationSiteListApiModel> getListOfSitesAsync(String continuationToken, Integer pageSize, final ServiceCallback<ApplicationSiteListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfSitesWithServiceResponseAsync(continuationToken, pageSize), serviceCallback);
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationSiteListApiModel object
     */
    public Observable<ApplicationSiteListApiModel> getListOfSitesAsync(String continuationToken, Integer pageSize) {
        return getListOfSitesWithServiceResponseAsync(continuationToken, pageSize).map(new Func1<ServiceResponse<ApplicationSiteListApiModel>, ApplicationSiteListApiModel>() {
            @Override
            public ApplicationSiteListApiModel call(ServiceResponse<ApplicationSiteListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of sites.
     * List all sites applications are registered in.
     *
     * @param continuationToken Optional Continuation
                 token
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationSiteListApiModel object
     */
    public Observable<ServiceResponse<ApplicationSiteListApiModel>> getListOfSitesWithServiceResponseAsync(String continuationToken, Integer pageSize) {
        return service.getListOfSites(continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationSiteListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationSiteListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationSiteListApiModel> clientResponse = getListOfSitesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationSiteListApiModel> getListOfSitesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<ApplicationSiteListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationSiteListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoListApiModel object if successful.
     */
    public ApplicationInfoListApiModel getFilteredListOfApplications(ApplicationRegistrationQueryApiModel query) {
        return getFilteredListOfApplicationsWithServiceResponseAsync(query).toBlocking().single().body();
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoListApiModel> getFilteredListOfApplicationsAsync(ApplicationRegistrationQueryApiModel query, final ServiceCallback<ApplicationInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFilteredListOfApplicationsWithServiceResponseAsync(query), serviceCallback);
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ApplicationInfoListApiModel> getFilteredListOfApplicationsAsync(ApplicationRegistrationQueryApiModel query) {
        return getFilteredListOfApplicationsWithServiceResponseAsync(query).map(new Func1<ServiceResponse<ApplicationInfoListApiModel>, ApplicationInfoListApiModel>() {
            @Override
            public ApplicationInfoListApiModel call(ServiceResponse<ApplicationInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ServiceResponse<ApplicationInfoListApiModel>> getFilteredListOfApplicationsWithServiceResponseAsync(ApplicationRegistrationQueryApiModel query) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        final Integer pageSize = null;
        return service.getFilteredListOfApplications(query, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoListApiModel> clientResponse = getFilteredListOfApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoListApiModel object if successful.
     */
    public ApplicationInfoListApiModel getFilteredListOfApplications(ApplicationRegistrationQueryApiModel query, Integer pageSize) {
        return getFilteredListOfApplicationsWithServiceResponseAsync(query, pageSize).toBlocking().single().body();
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @param pageSize Number of results to return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoListApiModel> getFilteredListOfApplicationsAsync(ApplicationRegistrationQueryApiModel query, Integer pageSize, final ServiceCallback<ApplicationInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFilteredListOfApplicationsWithServiceResponseAsync(query, pageSize), serviceCallback);
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ApplicationInfoListApiModel> getFilteredListOfApplicationsAsync(ApplicationRegistrationQueryApiModel query, Integer pageSize) {
        return getFilteredListOfApplicationsWithServiceResponseAsync(query, pageSize).map(new Func1<ServiceResponse<ApplicationInfoListApiModel>, ApplicationInfoListApiModel>() {
            @Override
            public ApplicationInfoListApiModel call(ServiceResponse<ApplicationInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get filtered list of applications.
     * Get a list of applications filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Applications Query model
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ServiceResponse<ApplicationInfoListApiModel>> getFilteredListOfApplicationsWithServiceResponseAsync(ApplicationRegistrationQueryApiModel query, Integer pageSize) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        return service.getFilteredListOfApplications(query, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoListApiModel> clientResponse = getFilteredListOfApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationInfoListApiModel> getFilteredListOfApplicationsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationInfoListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationInfoListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoListApiModel object if successful.
     */
    public ApplicationInfoListApiModel queryApplications(ApplicationRegistrationQueryApiModel query) {
        return queryApplicationsWithServiceResponseAsync(query).toBlocking().single().body();
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoListApiModel> queryApplicationsAsync(ApplicationRegistrationQueryApiModel query, final ServiceCallback<ApplicationInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryApplicationsWithServiceResponseAsync(query), serviceCallback);
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ApplicationInfoListApiModel> queryApplicationsAsync(ApplicationRegistrationQueryApiModel query) {
        return queryApplicationsWithServiceResponseAsync(query).map(new Func1<ServiceResponse<ApplicationInfoListApiModel>, ApplicationInfoListApiModel>() {
            @Override
            public ApplicationInfoListApiModel call(ServiceResponse<ApplicationInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ServiceResponse<ApplicationInfoListApiModel>> queryApplicationsWithServiceResponseAsync(ApplicationRegistrationQueryApiModel query) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        final Integer pageSize = null;
        return service.queryApplications(query, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoListApiModel> clientResponse = queryApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoListApiModel object if successful.
     */
    public ApplicationInfoListApiModel queryApplications(ApplicationRegistrationQueryApiModel query, Integer pageSize) {
        return queryApplicationsWithServiceResponseAsync(query, pageSize).toBlocking().single().body();
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @param pageSize Optional number of results to
                 return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoListApiModel> queryApplicationsAsync(ApplicationRegistrationQueryApiModel query, Integer pageSize, final ServiceCallback<ApplicationInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryApplicationsWithServiceResponseAsync(query, pageSize), serviceCallback);
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ApplicationInfoListApiModel> queryApplicationsAsync(ApplicationRegistrationQueryApiModel query, Integer pageSize) {
        return queryApplicationsWithServiceResponseAsync(query, pageSize).map(new Func1<ServiceResponse<ApplicationInfoListApiModel>, ApplicationInfoListApiModel>() {
            @Override
            public ApplicationInfoListApiModel call(ServiceResponse<ApplicationInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query applications.
     * List applications that match a query model.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfApplications operation using the token to retrieve
     more results.
     *
     * @param query Application query
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoListApiModel object
     */
    public Observable<ServiceResponse<ApplicationInfoListApiModel>> queryApplicationsWithServiceResponseAsync(ApplicationRegistrationQueryApiModel query, Integer pageSize) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        return service.queryApplications(query, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoListApiModel> clientResponse = queryApplicationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationInfoListApiModel> queryApplicationsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationInfoListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationInfoListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationRecordListApiModel object if successful.
     */
    public ApplicationRecordListApiModel queryApplicationsById() {
        return queryApplicationsByIdWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationRecordListApiModel> queryApplicationsByIdAsync(final ServiceCallback<ApplicationRecordListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryApplicationsByIdWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRecordListApiModel object
     */
    public Observable<ApplicationRecordListApiModel> queryApplicationsByIdAsync() {
        return queryApplicationsByIdWithServiceResponseAsync().map(new Func1<ServiceResponse<ApplicationRecordListApiModel>, ApplicationRecordListApiModel>() {
            @Override
            public ApplicationRecordListApiModel call(ServiceResponse<ApplicationRecordListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRecordListApiModel object
     */
    public Observable<ServiceResponse<ApplicationRecordListApiModel>> queryApplicationsByIdWithServiceResponseAsync() {
        final ApplicationRecordQueryApiModel query = null;
        return service.queryApplicationsById(query)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationRecordListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationRecordListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationRecordListApiModel> clientResponse = queryApplicationsByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @param query the ApplicationRecordQueryApiModel value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationRecordListApiModel object if successful.
     */
    public ApplicationRecordListApiModel queryApplicationsById(ApplicationRecordQueryApiModel query) {
        return queryApplicationsByIdWithServiceResponseAsync(query).toBlocking().single().body();
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @param query the ApplicationRecordQueryApiModel value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationRecordListApiModel> queryApplicationsByIdAsync(ApplicationRecordQueryApiModel query, final ServiceCallback<ApplicationRecordListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryApplicationsByIdWithServiceResponseAsync(query), serviceCallback);
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @param query the ApplicationRecordQueryApiModel value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRecordListApiModel object
     */
    public Observable<ApplicationRecordListApiModel> queryApplicationsByIdAsync(ApplicationRecordQueryApiModel query) {
        return queryApplicationsByIdWithServiceResponseAsync(query).map(new Func1<ServiceResponse<ApplicationRecordListApiModel>, ApplicationRecordListApiModel>() {
            @Override
            public ApplicationRecordListApiModel call(ServiceResponse<ApplicationRecordListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query applications by id.
     * A query model which supports the OPC UA Global Discovery Server query.
     *
     * @param query the ApplicationRecordQueryApiModel value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationRecordListApiModel object
     */
    public Observable<ServiceResponse<ApplicationRecordListApiModel>> queryApplicationsByIdWithServiceResponseAsync(ApplicationRecordQueryApiModel query) {
        Validator.validate(query);
        return service.queryApplicationsById(query)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationRecordListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationRecordListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationRecordListApiModel> clientResponse = queryApplicationsByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationRecordListApiModel> queryApplicationsByIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<ApplicationRecordListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationRecordListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Activate endpoint.
     * Activates an endpoint for subsequent use in twin service.
     All endpoints must be activated using this API or through a
     activation filter during application registration or discovery.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void activateEndpoint(String endpointId) {
        activateEndpointWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Activate endpoint.
     * Activates an endpoint for subsequent use in twin service.
     All endpoints must be activated using this API or through a
     activation filter during application registration or discovery.
     *
     * @param endpointId endpoint identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> activateEndpointAsync(String endpointId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(activateEndpointWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Activate endpoint.
     * Activates an endpoint for subsequent use in twin service.
     All endpoints must be activated using this API or through a
     activation filter during application registration or discovery.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> activateEndpointAsync(String endpointId) {
        return activateEndpointWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate endpoint.
     * Activates an endpoint for subsequent use in twin service.
     All endpoints must be activated using this API or through a
     activation filter during application registration or discovery.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> activateEndpointWithServiceResponseAsync(String endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.activateEndpoint(endpointId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = activateEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> activateEndpointDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoApiModel object if successful.
     */
    public EndpointInfoApiModel getEndpoint(String endpointId) {
        return getEndpointWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoApiModel> getEndpointAsync(String endpointId, final ServiceCallback<EndpointInfoApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getEndpointWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoApiModel object
     */
    public Observable<EndpointInfoApiModel> getEndpointAsync(String endpointId) {
        return getEndpointWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponse<EndpointInfoApiModel>, EndpointInfoApiModel>() {
            @Override
            public EndpointInfoApiModel call(ServiceResponse<EndpointInfoApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoApiModel>> getEndpointWithServiceResponseAsync(String endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        final Boolean onlyServerState = null;
        return service.getEndpoint(endpointId, onlyServerState)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoApiModel> clientResponse = getEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoApiModel object if successful.
     */
    public EndpointInfoApiModel getEndpoint(String endpointId, Boolean onlyServerState) {
        return getEndpointWithServiceResponseAsync(endpointId, onlyServerState).toBlocking().single().body();
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoApiModel> getEndpointAsync(String endpointId, Boolean onlyServerState, final ServiceCallback<EndpointInfoApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getEndpointWithServiceResponseAsync(endpointId, onlyServerState), serviceCallback);
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoApiModel object
     */
    public Observable<EndpointInfoApiModel> getEndpointAsync(String endpointId, Boolean onlyServerState) {
        return getEndpointWithServiceResponseAsync(endpointId, onlyServerState).map(new Func1<ServiceResponse<EndpointInfoApiModel>, EndpointInfoApiModel>() {
            @Override
            public EndpointInfoApiModel call(ServiceResponse<EndpointInfoApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get endpoint information.
     * Gets information about an endpoint.
     *
     * @param endpointId endpoint identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoApiModel>> getEndpointWithServiceResponseAsync(String endpointId, Boolean onlyServerState) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.getEndpoint(endpointId, onlyServerState)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoApiModel> clientResponse = getEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInfoApiModel> getEndpointDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EndpointInfoApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointInfoApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Update endpoint information.
     *
     * @param endpointId endpoint identifier
     * @param request Endpoint update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateEndpoint(String endpointId, EndpointRegistrationUpdateApiModel request) {
        updateEndpointWithServiceResponseAsync(endpointId, request).toBlocking().single().body();
    }

    /**
     * Update endpoint information.
     *
     * @param endpointId endpoint identifier
     * @param request Endpoint update request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateEndpointAsync(String endpointId, EndpointRegistrationUpdateApiModel request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateEndpointWithServiceResponseAsync(endpointId, request), serviceCallback);
    }

    /**
     * Update endpoint information.
     *
     * @param endpointId endpoint identifier
     * @param request Endpoint update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateEndpointAsync(String endpointId, EndpointRegistrationUpdateApiModel request) {
        return updateEndpointWithServiceResponseAsync(endpointId, request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update endpoint information.
     *
     * @param endpointId endpoint identifier
     * @param request Endpoint update request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateEndpointWithServiceResponseAsync(String endpointId, EndpointRegistrationUpdateApiModel request) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateEndpoint(endpointId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateEndpointDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoListApiModel object if successful.
     */
    public EndpointInfoListApiModel getListOfEndpoints() {
        return getListOfEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoListApiModel> getListOfEndpointsAsync(final ServiceCallback<EndpointInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<EndpointInfoListApiModel> getListOfEndpointsAsync() {
        return getListOfEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponse<EndpointInfoListApiModel>, EndpointInfoListApiModel>() {
            @Override
            public EndpointInfoListApiModel call(ServiceResponse<EndpointInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoListApiModel>> getListOfEndpointsWithServiceResponseAsync() {
        final Boolean onlyServerState = null;
        final String continuationToken = null;
        final Integer pageSize = null;
        return service.getListOfEndpoints(onlyServerState, continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoListApiModel> clientResponse = getListOfEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoListApiModel object if successful.
     */
    public EndpointInfoListApiModel getListOfEndpoints(Boolean onlyServerState, String continuationToken, Integer pageSize) {
        return getListOfEndpointsWithServiceResponseAsync(onlyServerState, continuationToken, pageSize).toBlocking().single().body();
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoListApiModel> getListOfEndpointsAsync(Boolean onlyServerState, String continuationToken, Integer pageSize, final ServiceCallback<EndpointInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfEndpointsWithServiceResponseAsync(onlyServerState, continuationToken, pageSize), serviceCallback);
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<EndpointInfoListApiModel> getListOfEndpointsAsync(Boolean onlyServerState, String continuationToken, Integer pageSize) {
        return getListOfEndpointsWithServiceResponseAsync(onlyServerState, continuationToken, pageSize).map(new Func1<ServiceResponse<EndpointInfoListApiModel>, EndpointInfoListApiModel>() {
            @Override
            public EndpointInfoListApiModel call(ServiceResponse<EndpointInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of endpoints.
     * Get all registered endpoints in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoListApiModel>> getListOfEndpointsWithServiceResponseAsync(Boolean onlyServerState, String continuationToken, Integer pageSize) {
        return service.getListOfEndpoints(onlyServerState, continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoListApiModel> clientResponse = getListOfEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInfoListApiModel> getListOfEndpointsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<EndpointInfoListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointInfoListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoListApiModel object if successful.
     */
    public EndpointInfoListApiModel getFilteredListOfEndpoints() {
        return getFilteredListOfEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoListApiModel> getFilteredListOfEndpointsAsync(final ServiceCallback<EndpointInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFilteredListOfEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<EndpointInfoListApiModel> getFilteredListOfEndpointsAsync() {
        return getFilteredListOfEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponse<EndpointInfoListApiModel>, EndpointInfoListApiModel>() {
            @Override
            public EndpointInfoListApiModel call(ServiceResponse<EndpointInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoListApiModel>> getFilteredListOfEndpointsWithServiceResponseAsync() {
        final String url = null;
        final String userAuthentication = null;
        final byte[] certificate = new byte[0];
        final String securityMode = null;
        final String securityPolicy = null;
        final Boolean activated = null;
        final Boolean connected = null;
        final String endpointState = null;
        final Boolean includeNotSeenSince = null;
        final Boolean onlyServerState = null;
        final Integer pageSize = null;
        String certificateConverted = Base64.encodeBase64String(certificate);
        return service.getFilteredListOfEndpoints(url, userAuthentication, certificateConverted, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoListApiModel> clientResponse = getFilteredListOfEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param url Endoint url for direct server access
     * @param userAuthentication Type of credential selected for authentication. Possible values include: 'None', 'UserName', 'X509Certificate', 'JwtToken'
     * @param certificate Certificate of the endpoint
     * @param securityMode Security Mode. Possible values include: 'Best', 'Sign', 'SignAndEncrypt', 'None'
     * @param securityPolicy Security policy uri
     * @param activated Whether the endpoint was activated
     * @param connected Whether the endpoint is connected on supervisor.
     * @param endpointState The last state of the the activated endpoint. Possible values include: 'Connecting', 'NotReachable', 'Busy', 'NoTrust', 'CertificateInvalid', 'Ready', 'Error'
     * @param includeNotSeenSince Whether to include endpoints that were soft deleted
     * @param onlyServerState Whether to include only server state, or display
                 current client state of the endpoint if available
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoListApiModel object if successful.
     */
    public EndpointInfoListApiModel getFilteredListOfEndpoints(String url, String userAuthentication, byte[] certificate, String securityMode, String securityPolicy, Boolean activated, Boolean connected, String endpointState, Boolean includeNotSeenSince, Boolean onlyServerState, Integer pageSize) {
        return getFilteredListOfEndpointsWithServiceResponseAsync(url, userAuthentication, certificate, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize).toBlocking().single().body();
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param url Endoint url for direct server access
     * @param userAuthentication Type of credential selected for authentication. Possible values include: 'None', 'UserName', 'X509Certificate', 'JwtToken'
     * @param certificate Certificate of the endpoint
     * @param securityMode Security Mode. Possible values include: 'Best', 'Sign', 'SignAndEncrypt', 'None'
     * @param securityPolicy Security policy uri
     * @param activated Whether the endpoint was activated
     * @param connected Whether the endpoint is connected on supervisor.
     * @param endpointState The last state of the the activated endpoint. Possible values include: 'Connecting', 'NotReachable', 'Busy', 'NoTrust', 'CertificateInvalid', 'Ready', 'Error'
     * @param includeNotSeenSince Whether to include endpoints that were soft deleted
     * @param onlyServerState Whether to include only server state, or display
                 current client state of the endpoint if available
     * @param pageSize Optional number of results to
                 return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoListApiModel> getFilteredListOfEndpointsAsync(String url, String userAuthentication, byte[] certificate, String securityMode, String securityPolicy, Boolean activated, Boolean connected, String endpointState, Boolean includeNotSeenSince, Boolean onlyServerState, Integer pageSize, final ServiceCallback<EndpointInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFilteredListOfEndpointsWithServiceResponseAsync(url, userAuthentication, certificate, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize), serviceCallback);
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param url Endoint url for direct server access
     * @param userAuthentication Type of credential selected for authentication. Possible values include: 'None', 'UserName', 'X509Certificate', 'JwtToken'
     * @param certificate Certificate of the endpoint
     * @param securityMode Security Mode. Possible values include: 'Best', 'Sign', 'SignAndEncrypt', 'None'
     * @param securityPolicy Security policy uri
     * @param activated Whether the endpoint was activated
     * @param connected Whether the endpoint is connected on supervisor.
     * @param endpointState The last state of the the activated endpoint. Possible values include: 'Connecting', 'NotReachable', 'Busy', 'NoTrust', 'CertificateInvalid', 'Ready', 'Error'
     * @param includeNotSeenSince Whether to include endpoints that were soft deleted
     * @param onlyServerState Whether to include only server state, or display
                 current client state of the endpoint if available
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<EndpointInfoListApiModel> getFilteredListOfEndpointsAsync(String url, String userAuthentication, byte[] certificate, String securityMode, String securityPolicy, Boolean activated, Boolean connected, String endpointState, Boolean includeNotSeenSince, Boolean onlyServerState, Integer pageSize) {
        return getFilteredListOfEndpointsWithServiceResponseAsync(url, userAuthentication, certificate, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize).map(new Func1<ServiceResponse<EndpointInfoListApiModel>, EndpointInfoListApiModel>() {
            @Override
            public EndpointInfoListApiModel call(ServiceResponse<EndpointInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get filtered list of endpoints.
     * Get a list of endpoints filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param url Endoint url for direct server access
     * @param userAuthentication Type of credential selected for authentication. Possible values include: 'None', 'UserName', 'X509Certificate', 'JwtToken'
     * @param certificate Certificate of the endpoint
     * @param securityMode Security Mode. Possible values include: 'Best', 'Sign', 'SignAndEncrypt', 'None'
     * @param securityPolicy Security policy uri
     * @param activated Whether the endpoint was activated
     * @param connected Whether the endpoint is connected on supervisor.
     * @param endpointState The last state of the the activated endpoint. Possible values include: 'Connecting', 'NotReachable', 'Busy', 'NoTrust', 'CertificateInvalid', 'Ready', 'Error'
     * @param includeNotSeenSince Whether to include endpoints that were soft deleted
     * @param onlyServerState Whether to include only server state, or display
                 current client state of the endpoint if available
     * @param pageSize Optional number of results to
                 return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoListApiModel>> getFilteredListOfEndpointsWithServiceResponseAsync(String url, String userAuthentication, byte[] certificate, String securityMode, String securityPolicy, Boolean activated, Boolean connected, String endpointState, Boolean includeNotSeenSince, Boolean onlyServerState, Integer pageSize) {
        String certificateConverted = Base64.encodeBase64String(certificate);
        return service.getFilteredListOfEndpoints(url, userAuthentication, certificateConverted, securityMode, securityPolicy, activated, connected, endpointState, includeNotSeenSince, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoListApiModel> clientResponse = getFilteredListOfEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInfoListApiModel> getFilteredListOfEndpointsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<EndpointInfoListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointInfoListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoListApiModel object if successful.
     */
    public EndpointInfoListApiModel queryEndpoints(EndpointRegistrationQueryApiModel query) {
        return queryEndpointsWithServiceResponseAsync(query).toBlocking().single().body();
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoListApiModel> queryEndpointsAsync(EndpointRegistrationQueryApiModel query, final ServiceCallback<EndpointInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryEndpointsWithServiceResponseAsync(query), serviceCallback);
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<EndpointInfoListApiModel> queryEndpointsAsync(EndpointRegistrationQueryApiModel query) {
        return queryEndpointsWithServiceResponseAsync(query).map(new Func1<ServiceResponse<EndpointInfoListApiModel>, EndpointInfoListApiModel>() {
            @Override
            public EndpointInfoListApiModel call(ServiceResponse<EndpointInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoListApiModel>> queryEndpointsWithServiceResponseAsync(EndpointRegistrationQueryApiModel query) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        final Boolean onlyServerState = null;
        final Integer pageSize = null;
        return service.queryEndpoints(query, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoListApiModel> clientResponse = queryEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointInfoListApiModel object if successful.
     */
    public EndpointInfoListApiModel queryEndpoints(EndpointRegistrationQueryApiModel query, Boolean onlyServerState, Integer pageSize) {
        return queryEndpointsWithServiceResponseAsync(query, onlyServerState, pageSize).toBlocking().single().body();
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param pageSize Optional number of results to return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointInfoListApiModel> queryEndpointsAsync(EndpointRegistrationQueryApiModel query, Boolean onlyServerState, Integer pageSize, final ServiceCallback<EndpointInfoListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(queryEndpointsWithServiceResponseAsync(query, onlyServerState, pageSize), serviceCallback);
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<EndpointInfoListApiModel> queryEndpointsAsync(EndpointRegistrationQueryApiModel query, Boolean onlyServerState, Integer pageSize) {
        return queryEndpointsWithServiceResponseAsync(query, onlyServerState, pageSize).map(new Func1<ServiceResponse<EndpointInfoListApiModel>, EndpointInfoListApiModel>() {
            @Override
            public EndpointInfoListApiModel call(ServiceResponse<EndpointInfoListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query endpoints.
     * Return endpoints that match the specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfEndpoints operation using the token to retrieve
     more results.
     *
     * @param query Query to match
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointInfoListApiModel object
     */
    public Observable<ServiceResponse<EndpointInfoListApiModel>> queryEndpointsWithServiceResponseAsync(EndpointRegistrationQueryApiModel query, Boolean onlyServerState, Integer pageSize) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        return service.queryEndpoints(query, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInfoListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInfoListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInfoListApiModel> clientResponse = queryEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInfoListApiModel> queryEndpointsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EndpointInfoListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointInfoListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Deactivate endpoint.
     * Deactivates the endpoint and disable access through twin service.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deactivateEndpoint(String endpointId) {
        deactivateEndpointWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Deactivate endpoint.
     * Deactivates the endpoint and disable access through twin service.
     *
     * @param endpointId endpoint identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deactivateEndpointAsync(String endpointId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deactivateEndpointWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Deactivate endpoint.
     * Deactivates the endpoint and disable access through twin service.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deactivateEndpointAsync(String endpointId) {
        return deactivateEndpointWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate endpoint.
     * Deactivates the endpoint and disable access through twin service.
     *
     * @param endpointId endpoint identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deactivateEndpointWithServiceResponseAsync(String endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.deactivateEndpoint(endpointId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deactivateEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deactivateEndpointDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StatusResponseApiModel object if successful.
     */
    public StatusResponseApiModel getStatus() {
        return getStatusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StatusResponseApiModel> getStatusAsync(final ServiceCallback<StatusResponseApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getStatusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<StatusResponseApiModel> getStatusAsync() {
        return getStatusWithServiceResponseAsync().map(new Func1<ServiceResponse<StatusResponseApiModel>, StatusResponseApiModel>() {
            @Override
            public StatusResponseApiModel call(ServiceResponse<StatusResponseApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Return the service status in the form of the service status
     api model.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StatusResponseApiModel object
     */
    public Observable<ServiceResponse<StatusResponseApiModel>> getStatusWithServiceResponseAsync() {
        return service.getStatus()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StatusResponseApiModel>>>() {
                @Override
                public Observable<ServiceResponse<StatusResponseApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StatusResponseApiModel> clientResponse = getStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StatusResponseApiModel> getStatusDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<StatusResponseApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StatusResponseApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorApiModel object if successful.
     */
    public SupervisorApiModel getSupervisor(String supervisorId) {
        return getSupervisorWithServiceResponseAsync(supervisorId).toBlocking().single().body();
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorApiModel> getSupervisorAsync(String supervisorId, final ServiceCallback<SupervisorApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSupervisorWithServiceResponseAsync(supervisorId), serviceCallback);
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorApiModel object
     */
    public Observable<SupervisorApiModel> getSupervisorAsync(String supervisorId) {
        return getSupervisorWithServiceResponseAsync(supervisorId).map(new Func1<ServiceResponse<SupervisorApiModel>, SupervisorApiModel>() {
            @Override
            public SupervisorApiModel call(ServiceResponse<SupervisorApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorApiModel object
     */
    public Observable<ServiceResponse<SupervisorApiModel>> getSupervisorWithServiceResponseAsync(String supervisorId) {
        if (supervisorId == null) {
            throw new IllegalArgumentException("Parameter supervisorId is required and cannot be null.");
        }
        final Boolean onlyServerState = null;
        return service.getSupervisor(supervisorId, onlyServerState)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorApiModel> clientResponse = getSupervisorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorApiModel object if successful.
     */
    public SupervisorApiModel getSupervisor(String supervisorId, Boolean onlyServerState) {
        return getSupervisorWithServiceResponseAsync(supervisorId, onlyServerState).toBlocking().single().body();
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorApiModel> getSupervisorAsync(String supervisorId, Boolean onlyServerState, final ServiceCallback<SupervisorApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSupervisorWithServiceResponseAsync(supervisorId, onlyServerState), serviceCallback);
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorApiModel object
     */
    public Observable<SupervisorApiModel> getSupervisorAsync(String supervisorId, Boolean onlyServerState) {
        return getSupervisorWithServiceResponseAsync(supervisorId, onlyServerState).map(new Func1<ServiceResponse<SupervisorApiModel>, SupervisorApiModel>() {
            @Override
            public SupervisorApiModel call(ServiceResponse<SupervisorApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get supervisor registration information.
     * Returns a supervisor's registration and connectivity information.
     A supervisor id corresponds to the twin modules module identity.
     *
     * @param supervisorId Supervisor identifier
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorApiModel object
     */
    public Observable<ServiceResponse<SupervisorApiModel>> getSupervisorWithServiceResponseAsync(String supervisorId, Boolean onlyServerState) {
        if (supervisorId == null) {
            throw new IllegalArgumentException("Parameter supervisorId is required and cannot be null.");
        }
        return service.getSupervisor(supervisorId, onlyServerState)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorApiModel> clientResponse = getSupervisorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SupervisorApiModel> getSupervisorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SupervisorApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SupervisorApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Update supervisor information.
     * Allows a caller to configure recurring discovery runs on the twin module
     identified by the supervisor id or update site information.
     *
     * @param supervisorId supervisor identifier
     * @param request Patch request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateSupervisor(String supervisorId, SupervisorUpdateApiModel request) {
        updateSupervisorWithServiceResponseAsync(supervisorId, request).toBlocking().single().body();
    }

    /**
     * Update supervisor information.
     * Allows a caller to configure recurring discovery runs on the twin module
     identified by the supervisor id or update site information.
     *
     * @param supervisorId supervisor identifier
     * @param request Patch request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateSupervisorAsync(String supervisorId, SupervisorUpdateApiModel request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateSupervisorWithServiceResponseAsync(supervisorId, request), serviceCallback);
    }

    /**
     * Update supervisor information.
     * Allows a caller to configure recurring discovery runs on the twin module
     identified by the supervisor id or update site information.
     *
     * @param supervisorId supervisor identifier
     * @param request Patch request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateSupervisorAsync(String supervisorId, SupervisorUpdateApiModel request) {
        return updateSupervisorWithServiceResponseAsync(supervisorId, request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update supervisor information.
     * Allows a caller to configure recurring discovery runs on the twin module
     identified by the supervisor id or update site information.
     *
     * @param supervisorId supervisor identifier
     * @param request Patch request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateSupervisorWithServiceResponseAsync(String supervisorId, SupervisorUpdateApiModel request) {
        if (supervisorId == null) {
            throw new IllegalArgumentException("Parameter supervisorId is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.updateSupervisor(supervisorId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateSupervisorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateSupervisorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get runtime status of supervisor.
     * Allows a caller to get runtime status for a supervisor.
     *
     * @param supervisorId supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorStatusApiModel object if successful.
     */
    public SupervisorStatusApiModel getSupervisorStatus(String supervisorId) {
        return getSupervisorStatusWithServiceResponseAsync(supervisorId).toBlocking().single().body();
    }

    /**
     * Get runtime status of supervisor.
     * Allows a caller to get runtime status for a supervisor.
     *
     * @param supervisorId supervisor identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorStatusApiModel> getSupervisorStatusAsync(String supervisorId, final ServiceCallback<SupervisorStatusApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSupervisorStatusWithServiceResponseAsync(supervisorId), serviceCallback);
    }

    /**
     * Get runtime status of supervisor.
     * Allows a caller to get runtime status for a supervisor.
     *
     * @param supervisorId supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorStatusApiModel object
     */
    public Observable<SupervisorStatusApiModel> getSupervisorStatusAsync(String supervisorId) {
        return getSupervisorStatusWithServiceResponseAsync(supervisorId).map(new Func1<ServiceResponse<SupervisorStatusApiModel>, SupervisorStatusApiModel>() {
            @Override
            public SupervisorStatusApiModel call(ServiceResponse<SupervisorStatusApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get runtime status of supervisor.
     * Allows a caller to get runtime status for a supervisor.
     *
     * @param supervisorId supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorStatusApiModel object
     */
    public Observable<ServiceResponse<SupervisorStatusApiModel>> getSupervisorStatusWithServiceResponseAsync(String supervisorId) {
        if (supervisorId == null) {
            throw new IllegalArgumentException("Parameter supervisorId is required and cannot be null.");
        }
        return service.getSupervisorStatus(supervisorId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorStatusApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorStatusApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorStatusApiModel> clientResponse = getSupervisorStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SupervisorStatusApiModel> getSupervisorStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SupervisorStatusApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SupervisorStatusApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Reset supervisor.
     * Allows a caller to reset the twin module using its supervisor
     identity identifier.
     *
     * @param supervisorId supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetSupervisor(String supervisorId) {
        resetSupervisorWithServiceResponseAsync(supervisorId).toBlocking().single().body();
    }

    /**
     * Reset supervisor.
     * Allows a caller to reset the twin module using its supervisor
     identity identifier.
     *
     * @param supervisorId supervisor identifier
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetSupervisorAsync(String supervisorId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetSupervisorWithServiceResponseAsync(supervisorId), serviceCallback);
    }

    /**
     * Reset supervisor.
     * Allows a caller to reset the twin module using its supervisor
     identity identifier.
     *
     * @param supervisorId supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetSupervisorAsync(String supervisorId) {
        return resetSupervisorWithServiceResponseAsync(supervisorId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Reset supervisor.
     * Allows a caller to reset the twin module using its supervisor
     identity identifier.
     *
     * @param supervisorId supervisor identifier
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetSupervisorWithServiceResponseAsync(String supervisorId) {
        if (supervisorId == null) {
            throw new IllegalArgumentException("Parameter supervisorId is required and cannot be null.");
        }
        return service.resetSupervisor(supervisorId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetSupervisorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resetSupervisorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorListApiModel object if successful.
     */
    public SupervisorListApiModel getListOfSupervisors() {
        return getListOfSupervisorsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorListApiModel> getListOfSupervisorsAsync(final ServiceCallback<SupervisorListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfSupervisorsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<SupervisorListApiModel> getListOfSupervisorsAsync() {
        return getListOfSupervisorsWithServiceResponseAsync().map(new Func1<ServiceResponse<SupervisorListApiModel>, SupervisorListApiModel>() {
            @Override
            public SupervisorListApiModel call(ServiceResponse<SupervisorListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<ServiceResponse<SupervisorListApiModel>> getListOfSupervisorsWithServiceResponseAsync() {
        final Boolean onlyServerState = null;
        final String continuationToken = null;
        final Integer pageSize = null;
        return service.getListOfSupervisors(onlyServerState, continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorListApiModel> clientResponse = getListOfSupervisorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorListApiModel object if successful.
     */
    public SupervisorListApiModel getListOfSupervisors(Boolean onlyServerState, String continuationToken, Integer pageSize) {
        return getListOfSupervisorsWithServiceResponseAsync(onlyServerState, continuationToken, pageSize).toBlocking().single().body();
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorListApiModel> getListOfSupervisorsAsync(Boolean onlyServerState, String continuationToken, Integer pageSize, final ServiceCallback<SupervisorListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getListOfSupervisorsWithServiceResponseAsync(onlyServerState, continuationToken, pageSize), serviceCallback);
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<SupervisorListApiModel> getListOfSupervisorsAsync(Boolean onlyServerState, String continuationToken, Integer pageSize) {
        return getListOfSupervisorsWithServiceResponseAsync(onlyServerState, continuationToken, pageSize).map(new Func1<ServiceResponse<SupervisorListApiModel>, SupervisorListApiModel>() {
            @Override
            public SupervisorListApiModel call(ServiceResponse<SupervisorListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of supervisors.
     * Get all registered supervisors and therefore twin modules in paged form.
     The returned model can contain a continuation token if more results are
     available.
     Call this operation again using the token to retrieve more results.
     *
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if available
     * @param continuationToken Optional Continuation token
     * @param pageSize Optional number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<ServiceResponse<SupervisorListApiModel>> getListOfSupervisorsWithServiceResponseAsync(Boolean onlyServerState, String continuationToken, Integer pageSize) {
        return service.getListOfSupervisors(onlyServerState, continuationToken, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorListApiModel> clientResponse = getListOfSupervisorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SupervisorListApiModel> getListOfSupervisorsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<SupervisorListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SupervisorListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorListApiModel object if successful.
     */
    public SupervisorListApiModel getFilteredListOfSupervisors() {
        return getFilteredListOfSupervisorsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorListApiModel> getFilteredListOfSupervisorsAsync(final ServiceCallback<SupervisorListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFilteredListOfSupervisorsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<SupervisorListApiModel> getFilteredListOfSupervisorsAsync() {
        return getFilteredListOfSupervisorsWithServiceResponseAsync().map(new Func1<ServiceResponse<SupervisorListApiModel>, SupervisorListApiModel>() {
            @Override
            public SupervisorListApiModel call(ServiceResponse<SupervisorListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<ServiceResponse<SupervisorListApiModel>> getFilteredListOfSupervisorsWithServiceResponseAsync() {
        final String siteId = null;
        final String discovery = null;
        final Boolean connected = null;
        final Boolean onlyServerState = null;
        final Integer pageSize = null;
        return service.getFilteredListOfSupervisors(siteId, discovery, connected, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorListApiModel> clientResponse = getFilteredListOfSupervisorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param siteId Site of the supervisor
     * @param discovery Discovery mode of supervisor. Possible values include: 'Off', 'Local', 'Network', 'Fast', 'Scan'
     * @param connected Included connected or disconnected
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorListApiModel object if successful.
     */
    public SupervisorListApiModel getFilteredListOfSupervisors(String siteId, String discovery, Boolean connected, Boolean onlyServerState, Integer pageSize) {
        return getFilteredListOfSupervisorsWithServiceResponseAsync(siteId, discovery, connected, onlyServerState, pageSize).toBlocking().single().body();
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param siteId Site of the supervisor
     * @param discovery Discovery mode of supervisor. Possible values include: 'Off', 'Local', 'Network', 'Fast', 'Scan'
     * @param connected Included connected or disconnected
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorListApiModel> getFilteredListOfSupervisorsAsync(String siteId, String discovery, Boolean connected, Boolean onlyServerState, Integer pageSize, final ServiceCallback<SupervisorListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(getFilteredListOfSupervisorsWithServiceResponseAsync(siteId, discovery, connected, onlyServerState, pageSize), serviceCallback);
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param siteId Site of the supervisor
     * @param discovery Discovery mode of supervisor. Possible values include: 'Off', 'Local', 'Network', 'Fast', 'Scan'
     * @param connected Included connected or disconnected
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<SupervisorListApiModel> getFilteredListOfSupervisorsAsync(String siteId, String discovery, Boolean connected, Boolean onlyServerState, Integer pageSize) {
        return getFilteredListOfSupervisorsWithServiceResponseAsync(siteId, discovery, connected, onlyServerState, pageSize).map(new Func1<ServiceResponse<SupervisorListApiModel>, SupervisorListApiModel>() {
            @Override
            public SupervisorListApiModel call(ServiceResponse<SupervisorListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Get filtered list of supervisors.
     * Get a list of supervisors filtered using the specified query parameters.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param siteId Site of the supervisor
     * @param discovery Discovery mode of supervisor. Possible values include: 'Off', 'Local', 'Network', 'Fast', 'Scan'
     * @param connected Included connected or disconnected
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<ServiceResponse<SupervisorListApiModel>> getFilteredListOfSupervisorsWithServiceResponseAsync(String siteId, String discovery, Boolean connected, Boolean onlyServerState, Integer pageSize) {
        return service.getFilteredListOfSupervisors(siteId, discovery, connected, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorListApiModel> clientResponse = getFilteredListOfSupervisorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SupervisorListApiModel> getFilteredListOfSupervisorsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<SupervisorListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SupervisorListApiModel>() { }.getType())
                .build(response);
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorListApiModel object if successful.
     */
    public SupervisorListApiModel querySupervisors(SupervisorQueryApiModel query) {
        return querySupervisorsWithServiceResponseAsync(query).toBlocking().single().body();
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorListApiModel> querySupervisorsAsync(SupervisorQueryApiModel query, final ServiceCallback<SupervisorListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(querySupervisorsWithServiceResponseAsync(query), serviceCallback);
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<SupervisorListApiModel> querySupervisorsAsync(SupervisorQueryApiModel query) {
        return querySupervisorsWithServiceResponseAsync(query).map(new Func1<ServiceResponse<SupervisorListApiModel>, SupervisorListApiModel>() {
            @Override
            public SupervisorListApiModel call(ServiceResponse<SupervisorListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<ServiceResponse<SupervisorListApiModel>> querySupervisorsWithServiceResponseAsync(SupervisorQueryApiModel query) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        final Boolean onlyServerState = null;
        final Integer pageSize = null;
        return service.querySupervisors(query, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorListApiModel> clientResponse = querySupervisorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SupervisorListApiModel object if successful.
     */
    public SupervisorListApiModel querySupervisors(SupervisorQueryApiModel query, Boolean onlyServerState, Integer pageSize) {
        return querySupervisorsWithServiceResponseAsync(query, onlyServerState, pageSize).toBlocking().single().body();
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SupervisorListApiModel> querySupervisorsAsync(SupervisorQueryApiModel query, Boolean onlyServerState, Integer pageSize, final ServiceCallback<SupervisorListApiModel> serviceCallback) {
        return ServiceFuture.fromResponse(querySupervisorsWithServiceResponseAsync(query, onlyServerState, pageSize), serviceCallback);
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<SupervisorListApiModel> querySupervisorsAsync(SupervisorQueryApiModel query, Boolean onlyServerState, Integer pageSize) {
        return querySupervisorsWithServiceResponseAsync(query, onlyServerState, pageSize).map(new Func1<ServiceResponse<SupervisorListApiModel>, SupervisorListApiModel>() {
            @Override
            public SupervisorListApiModel call(ServiceResponse<SupervisorListApiModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Query supervisors.
     * Get all supervisors that match a specified query.
     The returned model can contain a continuation token if more results are
     available.
     Call the GetListOfSupervisors operation using the token to retrieve
     more results.
     *
     * @param query Supervisors query model
     * @param onlyServerState Whether to include only server
                 state, or display current client state of the endpoint if
                 available
     * @param pageSize Number of results to return
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SupervisorListApiModel object
     */
    public Observable<ServiceResponse<SupervisorListApiModel>> querySupervisorsWithServiceResponseAsync(SupervisorQueryApiModel query, Boolean onlyServerState, Integer pageSize) {
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        Validator.validate(query);
        return service.querySupervisors(query, onlyServerState, pageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SupervisorListApiModel>>>() {
                @Override
                public Observable<ServiceResponse<SupervisorListApiModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SupervisorListApiModel> clientResponse = querySupervisorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SupervisorListApiModel> querySupervisorsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SupervisorListApiModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SupervisorListApiModel>() { }.getType())
                .build(response);
    }

}
